# Comparing `tmp/RsCmwLteMeas-3.7.62.23.tar.gz` & `tmp/RsCmwLteMeas-4.0.110.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\RsCmwLteMeas-3.7.62.23.tar", last modified: Sun May 16 18:20:12 2021, max compression
+gzip compressed data, was "dist\RsCmwLteMeas-4.0.110.tar", last modified: Wed Apr 17 13:01:45 2024, max compression
```

## Comparing `RsCmwLteMeas-3.7.62.23.tar` & `RsCmwLteMeas-4.0.110.tar`

### file list

```diff
@@ -1,1109 +1,979 @@
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.385154 RsCmwLteMeas-3.7.62.23/
--rw-rw-rw-   0        0        0     3899 2021-05-16 18:20:12.385154 RsCmwLteMeas-3.7.62.23/PKG-INFO
--rw-rw-rw-   0        0        0     2700 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/README.md
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.060575 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.099471 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/
--rw-rw-rw-   0        0        0        0 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/__init__.py
--rw-rw-rw-   0        0        0     3304 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/events.py
--rw-rw-rw-   0        0        0     4517 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/reliability.py
--rw-rw-rw-   0        0        0    18659 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/utilities.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.138369 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/
--rw-rw-rw-   0        0        0     7189 2021-05-16 18:19:53.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.183248 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/
--rw-rw-rw-   0        0        0     2317 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.225136 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/
--rw-rw-rw-   0        0        0      901 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/ChannelBw.py
--rw-rw-rw-   0        0        0     1047 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.235110 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/Aggregated.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/__init__.py
--rw-rw-rw-   0        0        0     3721 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.250071 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/
--rw-rw-rw-   0        0        0     2745 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/Scc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/__init__.py
--rw-rw-rw-   0        0        0     1605 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Mcarrier.py
--rw-rw-rw-   0        0        0     2840 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Mode.py
--rw-rw-rw-   0        0        0     1879 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.264032 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/
--rw-rw-rw-   0        0        0     2121 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/AcSpacing.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     1924 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.276999 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Cc_/
--rw-rw-rw-   0        0        0     2762 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Cc_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     2133 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Emtc.py
--rw-rw-rw-   0        0        0    31021 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.376735 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/
--rw-rw-rw-   0        0        0     2256 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Bler.py
--rw-rw-rw-   0        0        0     1896 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.389698 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc_/
--rw-rw-rw-   0        0        0     2429 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc_/PlcId.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     1888 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.427597 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/
--rw-rw-rw-   0        0        0     1194 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.444552 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/
--rw-rw-rw-   0        0        0     1347 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.463501 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/
--rw-rw-rw-   0        0        0     3492 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.473475 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.483447 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     6131 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.493420 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     6668 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     4396 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/__init__.py
--rw-rw-rw-   0        0        0     2253 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.507383 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/
--rw-rw-rw-   0        0        0     1416 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.523341 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.533315 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     6877 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.544286 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     7405 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0     3547 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/Ocombination.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     5136 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     1041 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.555256 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/
--rw-rw-rw-   0        0        0     4514 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     3587 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.603130 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/
--rw-rw-rw-   0        0        0     3492 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EsFlatness.py
--rw-rw-rw-   0        0        0     3015 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EvMagnitude.py
--rw-rw-rw-   0        0        0     2393 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/FreqError.py
--rw-rw-rw-   0        0        0     3697 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.616094 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/
--rw-rw-rw-   0        0        0     3189 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/IqOffset.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/__init__.py
--rw-rw-rw-   0        0        0     3327 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/IqOffset.py
--rw-rw-rw-   0        0        0     2907 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Merror.py
--rw-rw-rw-   0        0        0     3127 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Perror.py
--rw-rw-rw-   0        0        0     3037 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Sflatness.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/__init__.py
--rw-rw-rw-   0        0        0    14305 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.627064 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/
--rw-rw-rw-   0        0        0     4445 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/Ibe.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/__init__.py
--rw-rw-rw-   0        0        0     1514 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.647010 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/
--rw-rw-rw-   0        0        0     4001 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/AtTolerance.py
--rw-rw-rw-   0        0        0     2425 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.667955 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/
--rw-rw-rw-   0        0        0     2200 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.683912 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/
--rw-rw-rw-   0        0        0     1418 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.697876 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2016 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.707849 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     7567 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0     4528 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/Ocombination.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     6674 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.716825 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/
--rw-rw-rw-   0        0        0     5203 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/Sidelink.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/__init__.py
--rw-rw-rw-   0        0        0     1416 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.731746 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.740721 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     7241 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.748701 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     7761 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0     3916 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/Ocombination.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     5470 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     1368 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.763660 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/
--rw-rw-rw-   0        0        0     2831 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.774631 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.783607 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     5431 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.795575 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     5971 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     3663 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     5344 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.810535 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/
--rw-rw-rw-   0        0        0     4737 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.907278 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/
--rw-rw-rw-   0        0        0     3388 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Aclr.py
--rw-rw-rw-   0        0        0     1358 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.925487 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2049 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/AcSpacing.py
--rw-rw-rw-   0        0        0     2782 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.936458 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/
--rw-rw-rw-   0        0        0     2364 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/Enhanced.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     5343 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Cc.py
--rw-rw-rw-   0        0        0      981 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.946431 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/
--rw-rw-rw-   0        0        0     2028 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/Nband.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/__init__.py
--rw-rw-rw-   0        0        0     4141 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Modulation.py
--rw-rw-rw-   0        0        0     1994 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Pmonitor.py
--rw-rw-rw-   0        0        0     2653 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Power.py
--rw-rw-rw-   0        0        0     3714 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.957402 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/
--rw-rw-rw-   0        0        0     3377 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/Sidelink.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/__init__.py
--rw-rw-rw-   0        0        0     4345 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scc.py
--rw-rw-rw-   0        0        0     3244 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SeMask.py
--rw-rw-rw-   0        0        0     6692 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py
--rw-rw-rw-   0        0        0     1043 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.967375 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/
--rw-rw-rw-   0        0        0     2688 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/Connector.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/__init__.py
--rw-rw-rw-   0        0        0     2936 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Tdd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/__init__.py
--rw-rw-rw-   0        0        0     2293 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     5075 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.990314 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/
--rw-rw-rw-   0        0        0     1971 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/CarrierAggregation.py
--rw-rw-rw-   0        0        0     2618 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.000287 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/
--rw-rw-rw-   0        0        0     3719 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/Pusch.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/__init__.py
--rw-rw-rw-   0        0        0     2865 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.011258 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/
--rw-rw-rw-   0        0        0     4057 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     3627 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/NsValue.py
--rw-rw-rw-   0        0        0     1262 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pcc.py
--rw-rw-rw-   0        0        0     2357 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.022230 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/
--rw-rw-rw-   0        0        0     2986 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/AeoPower.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1359 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Power.py
--rw-rw-rw-   0        0        0     2501 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.045168 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/
--rw-rw-rw-   0        0        0     2724 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.060128 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/
--rw-rw-rw-   0        0        0     3853 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Nrb.py
--rw-rw-rw-   0        0        0     3902 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Orb.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/__init__.py
--rw-rw-rw-   0        0        0     3899 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Nrb.py
--rw-rw-rw-   0        0        0     4447 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Orb.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/__init__.py
--rw-rw-rw-   0        0        0    34950 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.070101 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result_/
--rw-rw-rw-   0        0        0     4826 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result_/EvMagnitude.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result_/__init__.py
--rw-rw-rw-   0        0        0     3434 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.081072 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount_/
--rw-rw-rw-   0        0        0     3246 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount_/Spectrum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount_/__init__.py
--rw-rw-rw-   0        0        0     1228 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.096032 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/
--rw-rw-rw-   0        0        0     2101 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/Aclr.py
--rw-rw-rw-   0        0        0     1589 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/SeMask.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0     1620 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Srs.py
--rw-rw-rw-   0        0        0     4376 2021-05-16 18:19:55.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Tmode.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     1381 2021-05-16 18:19:57.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Pcc.py
--rw-rw-rw-   0        0        0    12401 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.139915 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/
--rw-rw-rw-   0        0        0     8902 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Limit.py
--rw-rw-rw-   0        0        0     5020 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.156873 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/
--rw-rw-rw-   0        0        0     2065 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.169836 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/
--rw-rw-rw-   0        0        0     3337 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/Pformat.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/__init__.py
--rw-rw-rw-   0        0        0     2879 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/Sindex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2940 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/PfOffset.py
--rw-rw-rw-   0        0        0     1327 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Power.py
--rw-rw-rw-   0        0        0    16393 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Result.py
--rw-rw-rw-   0        0        0     2697 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Scount.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/__init__.py
--rw-rw-rw-   0        0        0     8923 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.190779 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/
--rw-rw-rw-   0        0        0     1928 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.203747 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc_/
--rw-rw-rw-   0        0        0     3241 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     1278 2021-05-16 18:19:54.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Pcc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/__init__.py
--rw-rw-rw-   0        0        0     8645 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.223692 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs_/
--rw-rw-rw-   0        0        0     2376 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs_/Limit.py
--rw-rw-rw-   0        0        0     1543 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs_/Scount.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/__init__.py
--rw-rw-rw-   0        0        0     9844 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.314449 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/
--rw-rw-rw-   0        0        0     1740 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.339384 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/
--rw-rw-rw-   0        0        0     5936 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Average.py
--rw-rw-rw-   0        0        0     5936 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Current.py
--rw-rw-rw-   0        0        0     1939 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Dallocation.py
--rw-rw-rw-   0        0        0     1560 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/DchType.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     2349 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Bler.py
--rw-rw-rw-   0        0        0     1795 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.363320 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/
--rw-rw-rw-   0        0        0     5133 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Average.py
--rw-rw-rw-   0        0        0     5757 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.374290 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current_/
--rw-rw-rw-   0        0        0     2227 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current_/ScIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current_/__init__.py
--rw-rw-rw-   0        0        0     5133 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Extreme.py
--rw-rw-rw-   0        0        0     3318 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.397228 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/
--rw-rw-rw-   0        0        0     2768 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Average.py
--rw-rw-rw-   0        0        0     2768 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Current.py
--rw-rw-rw-   0        0        0     2768 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.418172 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/
--rw-rw-rw-   0        0        0     2805 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Average.py
--rw-rw-rw-   0        0        0     2805 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Current.py
--rw-rw-rw-   0        0        0     2805 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/__init__.py
--rw-rw-rw-   0        0        0      967 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.428146 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/
--rw-rw-rw-   0        0        0     1742 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.453079 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/
--rw-rw-rw-   0        0        0     2080 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Average.py
--rw-rw-rw-   0        0        0     2080 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Current.py
--rw-rw-rw-   0        0        0     2080 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Maximum.py
--rw-rw-rw-   0        0        0     2112 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/__init__.py
--rw-rw-rw-   0        0        0     1011 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.462055 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.472029 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/
--rw-rw-rw-   0        0        0     1762 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.495965 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/
--rw-rw-rw-   0        0        0     2398 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     3022 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.505938 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2290 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     3022 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.512919 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2290 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2420 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/__init__.py
--rw-rw-rw-   0        0        0     3038 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.557800 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/
--rw-rw-rw-   0        0        0     1703 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.580738 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/
--rw-rw-rw-   0        0        0     2309 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Dallocation.py
--rw-rw-rw-   0        0        0     1720 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/DchType.py
--rw-rw-rw-   0        0        0     1722 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.605673 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/
--rw-rw-rw-   0        0        0     2450 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Average.py
--rw-rw-rw-   0        0        0     2450 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Current.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.617640 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/
--rw-rw-rw-   0        0        0     2646 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Average.py
--rw-rw-rw-   0        0        0     2646 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/__init__.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.630605 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/
--rw-rw-rw-   0        0        0     2646 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Average.py
--rw-rw-rw-   0        0        0     2646 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/__init__.py
--rw-rw-rw-   0        0        0     2145 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.644568 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.659530 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/
--rw-rw-rw-   0        0        0     3259 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Average.py
--rw-rw-rw-   0        0        0     3259 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/__init__.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.674489 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/
--rw-rw-rw-   0        0        0     3259 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Average.py
--rw-rw-rw-   0        0        0     3259 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     1978 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.699423 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/
--rw-rw-rw-   0        0        0     2665 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.724356 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/
--rw-rw-rw-   0        0        0     3087 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Average.py
--rw-rw-rw-   0        0        0     3087 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Current.py
--rw-rw-rw-   0        0        0     3087 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Extreme.py
--rw-rw-rw-   0        0        0     1833 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/__init__.py
--rw-rw-rw-   0        0        0     2589 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.746298 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/
--rw-rw-rw-   0        0        0     2983 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Average.py
--rw-rw-rw-   0        0        0     2983 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Current.py
--rw-rw-rw-   0        0        0     2983 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Extreme.py
--rw-rw-rw-   0        0        0     1781 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/__init__.py
--rw-rw-rw-   0        0        0     2589 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.769237 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/
--rw-rw-rw-   0        0        0     2983 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Average.py
--rw-rw-rw-   0        0        0     2983 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Current.py
--rw-rw-rw-   0        0        0     2983 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Extreme.py
--rw-rw-rw-   0        0        0     1781 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/__init__.py
--rw-rw-rw-   0        0        0     2585 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.791178 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/
--rw-rw-rw-   0        0        0     2963 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Average.py
--rw-rw-rw-   0        0        0     2963 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Current.py
--rw-rw-rw-   0        0        0     2963 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Extreme.py
--rw-rw-rw-   0        0        0     1771 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/__init__.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.803147 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/
--rw-rw-rw-   0        0        0     1862 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.812122 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/
--rw-rw-rw-   0        0        0     1718 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0     1862 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.821097 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/
--rw-rw-rw-   0        0        0     1718 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1045 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.830073 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.859993 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/
--rw-rw-rw-   0        0        0     1525 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Average.py
--rw-rw-rw-   0        0        0     1525 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Current.py
--rw-rw-rw-   0        0        0     1525 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Extreme.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.873956 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/
--rw-rw-rw-   0        0        0     1376 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Current.py
--rw-rw-rw-   0        0        0     1376 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Extreme.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/__init__.py
--rw-rw-rw-   0        0        0     1547 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/__init__.py
--rw-rw-rw-   0        0        0     3956 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.934794 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/
--rw-rw-rw-   0        0        0     2327 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dallocation.py
--rw-rw-rw-   0        0        0     1738 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/DchType.py
--rw-rw-rw-   0        0        0     1665 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dmodulation.py
--rw-rw-rw-   0        0        0     1386 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.956737 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.968704 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:09.991642 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Average.py
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Current.py
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1514 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.015578 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Average.py
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Current.py
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1510 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/__init__.py
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.028543 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.049489 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Average.py
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Current.py
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1514 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.077414 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Average.py
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Current.py
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1510 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     1174 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.091376 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.114315 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/
--rw-rw-rw-   0        0        0     2457 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Average.py
--rw-rw-rw-   0        0        0     2457 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Current.py
--rw-rw-rw-   0        0        0     2457 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1509 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.136257 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/
--rw-rw-rw-   0        0        0     2449 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Average.py
--rw-rw-rw-   0        0        0     2449 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Current.py
--rw-rw-rw-   0        0        0     2449 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1505 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/__init__.py
--rw-rw-rw-   0        0        0     1789 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.161190 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/
--rw-rw-rw-   0        0        0     2341 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Average.py
--rw-rw-rw-   0        0        0     2341 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Current.py
--rw-rw-rw-   0        0        0     2341 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Extreme.py
--rw-rw-rw-   0        0        0     1447 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/__init__.py
--rw-rw-rw-   0        0        0     1780 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.184129 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/
--rw-rw-rw-   0        0        0     2325 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Average.py
--rw-rw-rw-   0        0        0     2325 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Current.py
--rw-rw-rw-   0        0        0     2325 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Extreme.py
--rw-rw-rw-   0        0        0     1439 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/__init__.py
--rw-rw-rw-   0        0        0     1410 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.202081 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.215046 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.235991 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/
--rw-rw-rw-   0        0        0     2479 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Average.py
--rw-rw-rw-   0        0        0     2479 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Current.py
--rw-rw-rw-   0        0        0     2479 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1520 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.259927 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/
--rw-rw-rw-   0        0        0     2471 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Average.py
--rw-rw-rw-   0        0        0     2471 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Current.py
--rw-rw-rw-   0        0        0     2471 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1516 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/__init__.py
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.275884 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.301815 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/
--rw-rw-rw-   0        0        0     2479 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Average.py
--rw-rw-rw-   0        0        0     2479 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Current.py
--rw-rw-rw-   0        0        0     2479 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1520 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.325751 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/
--rw-rw-rw-   0        0        0     2475 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Average.py
--rw-rw-rw-   0        0        0     2475 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Current.py
--rw-rw-rw-   0        0        0     2475 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1518 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     1174 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.338716 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.360657 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/
--rw-rw-rw-   0        0        0     2473 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Average.py
--rw-rw-rw-   0        0        0     2473 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Current.py
--rw-rw-rw-   0        0        0     2473 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1517 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.383597 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/
--rw-rw-rw-   0        0        0     2465 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Average.py
--rw-rw-rw-   0        0        0     2465 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Current.py
--rw-rw-rw-   0        0        0     2465 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1513 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/__init__.py
--rw-rw-rw-   0        0        0     1410 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.399554 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.413517 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.437454 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/
--rw-rw-rw-   0        0        0     2477 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Average.py
--rw-rw-rw-   0        0        0     2477 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Current.py
--rw-rw-rw-   0        0        0     2477 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1519 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.459394 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/
--rw-rw-rw-   0        0        0     2469 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Average.py
--rw-rw-rw-   0        0        0     2469 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Current.py
--rw-rw-rw-   0        0        0     2469 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1515 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/__init__.py
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.474355 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.497293 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/
--rw-rw-rw-   0        0        0     2477 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Average.py
--rw-rw-rw-   0        0        0     2477 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Current.py
--rw-rw-rw-   0        0        0     2477 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1519 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.521230 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/
--rw-rw-rw-   0        0        0     2469 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Average.py
--rw-rw-rw-   0        0        0     2469 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Current.py
--rw-rw-rw-   0        0        0     2469 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1515 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     1174 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.534195 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.557134 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Average.py
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Current.py
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1514 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.577081 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Average.py
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Current.py
--rw-rw-rw-   0        0        0     2459 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1510 2021-05-16 18:20:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/__init__.py
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.606004 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Average.py
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Current.py
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Maximum.py
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Minimum.py
--rw-rw-rw-   0        0        0     1442 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/__init__.py
--rw-rw-rw-   0        0        0     1973 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.631933 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/
--rw-rw-rw-   0        0        0     2315 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Average.py
--rw-rw-rw-   0        0        0     2315 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Current.py
--rw-rw-rw-   0        0        0     2315 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Maximum.py
--rw-rw-rw-   0        0        0     2315 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Minimum.py
--rw-rw-rw-   0        0        0     1434 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/__init__.py
--rw-rw-rw-   0        0        0     1442 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/SchType.py
--rw-rw-rw-   0        0        0     1762 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.653877 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/
--rw-rw-rw-   0        0        0     2365 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Average.py
--rw-rw-rw-   0        0        0     2365 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Current.py
--rw-rw-rw-   0        0        0     2365 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Extreme.py
--rw-rw-rw-   0        0        0     1459 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/__init__.py
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.680805 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/
--rw-rw-rw-   0        0        0     2317 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Average.py
--rw-rw-rw-   0        0        0     2317 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Current.py
--rw-rw-rw-   0        0        0     2317 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Maximum.py
--rw-rw-rw-   0        0        0     2317 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Minimum.py
--rw-rw-rw-   0        0        0     1435 2021-05-16 18:20:02.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     1204 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.694766 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/
--rw-rw-rw-   0        0        0     1817 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Peak.py
--rw-rw-rw-   0        0        0     1810 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Rms.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0      999 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.703743 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/
--rw-rw-rw-   0        0        0     2013 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.731668 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Average.py
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Current.py
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Maximum.py
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Minimum.py
--rw-rw-rw-   0        0        0     1285 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/__init__.py
--rw-rw-rw-   0        0        0     1962 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.757600 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/
--rw-rw-rw-   0        0        0     2315 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Dallocation.py
--rw-rw-rw-   0        0        0     1726 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/DchType.py
--rw-rw-rw-   0        0        0      983 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.765578 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/
--rw-rw-rw-   0        0        0     2039 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.779541 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/
--rw-rw-rw-   0        0        0     1501 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.796494 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/
--rw-rw-rw-   0        0        0     2401 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Average.py
--rw-rw-rw-   0        0        0     2407 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Current.py
--rw-rw-rw-   0        0        0     2401 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/__init__.py
--rw-rw-rw-   0        0        0     1501 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.813450 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/
--rw-rw-rw-   0        0        0     2441 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Average.py
--rw-rw-rw-   0        0        0     2447 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Current.py
--rw-rw-rw-   0        0        0     2441 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     1735 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.837390 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/
--rw-rw-rw-   0        0        0     2253 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Average.py
--rw-rw-rw-   0        0        0     2253 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Current.py
--rw-rw-rw-   0        0        0     2253 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Extreme.py
--rw-rw-rw-   0        0        0     1403 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/__init__.py
--rw-rw-rw-   0        0        0     2013 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.865315 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/
--rw-rw-rw-   0        0        0     2305 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Average.py
--rw-rw-rw-   0        0        0     2305 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Current.py
--rw-rw-rw-   0        0        0     2305 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Maximum.py
--rw-rw-rw-   0        0        0     2305 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Minimum.py
--rw-rw-rw-   0        0        0     1429 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0     3360 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.903215 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/
--rw-rw-rw-   0        0        0     1744 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.928148 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/
--rw-rw-rw-   0        0        0     6874 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Average.py
--rw-rw-rw-   0        0        0     6874 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Current.py
--rw-rw-rw-   0        0        0     2460 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dallocation.py
--rw-rw-rw-   0        0        0     2289 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/DchType.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     1798 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.951087 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/
--rw-rw-rw-   0        0        0     5373 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Average.py
--rw-rw-rw-   0        0        0     5997 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.960063 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/
--rw-rw-rw-   0        0        0     2767 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/ScIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/__init__.py
--rw-rw-rw-   0        0        0     5373 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Extreme.py
--rw-rw-rw-   0        0        0     3111 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1474 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.980009 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/
--rw-rw-rw-   0        0        0     1912 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:10.987989 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/
--rw-rw-rw-   0        0        0     1766 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.011925 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/
--rw-rw-rw-   0        0        0     2885 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     3509 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.019904 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2771 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     3509 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.029877 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2771 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2907 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     1764 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.051819 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/
--rw-rw-rw-   0        0        0     2151 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Average.py
--rw-rw-rw-   0        0        0     2775 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.061792 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2180 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     2775 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.072764 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2180 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2173 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     1863 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.081738 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/
--rw-rw-rw-   0        0        0     1766 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.108667 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/
--rw-rw-rw-   0        0        0     2478 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     3102 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.117643 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2507 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     3102 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.128613 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2507 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2500 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/__init__.py
--rw-rw-rw-   0        0        0     2843 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.169038 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/
--rw-rw-rw-   0        0        0    11991 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py
--rw-rw-rw-   0        0        0    11991 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py
--rw-rw-rw-   0        0        0     2478 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dallocation.py
--rw-rw-rw-   0        0        0     2307 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/DchType.py
--rw-rw-rw-   0        0        0     2230 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dmodulation.py
--rw-rw-rw-   0        0        0    12991 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Extreme.py
--rw-rw-rw-   0        0        0     2024 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/SchType.py
--rw-rw-rw-   0        0        0     6256 2021-05-16 18:20:03.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     1433 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.187987 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/
--rw-rw-rw-   0        0        0     1219 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.201949 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/
--rw-rw-rw-   0        0        0     1702 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Length.py
--rw-rw-rw-   0        0        0     1869 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Start.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/__init__.py
--rw-rw-rw-   0        0        0     2206 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Peak.py
--rw-rw-rw-   0        0        0     2197 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Rms.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.230872 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/
--rw-rw-rw-   0        0        0     3864 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Average.py
--rw-rw-rw-   0        0        0     3864 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Current.py
--rw-rw-rw-   0        0        0     3865 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Maximum.py
--rw-rw-rw-   0        0        0     3865 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Minimum.py
--rw-rw-rw-   0        0        0     2249 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/__init__.py
--rw-rw-rw-   0        0        0     2510 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.269112 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/
--rw-rw-rw-   0        0        0     4757 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Average.py
--rw-rw-rw-   0        0        0     4757 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Current.py
--rw-rw-rw-   0        0        0     2466 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dallocation.py
--rw-rw-rw-   0        0        0     2295 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/DchType.py
--rw-rw-rw-   0        0        0     5085 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Extreme.py
--rw-rw-rw-   0        0        0     1700 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.299032 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/
--rw-rw-rw-   0        0        0     3333 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/All.py
--rw-rw-rw-   0        0        0     1259 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.315985 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/
--rw-rw-rw-   0        0        0     2906 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Negativ.py
--rw-rw-rw-   0        0        0     2906 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/__init__.py
--rw-rw-rw-   0        0        0     1259 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.332940 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2912 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Negativ.py
--rw-rw-rw-   0        0        0     2912 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     1259 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.349406 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/
--rw-rw-rw-   0        0        0     2906 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Negativ.py
--rw-rw-rw-   0        0        0     2906 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     2639 2021-05-16 18:20:04.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/__init__.py
--rw-rw-rw-   0        0        0     1695 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Sreliability.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1485 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.369353 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/
--rw-rw-rw-   0        0        0     2816 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/Average.py
--rw-rw-rw-   0        0        0     2816 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/Current.py
--rw-rw-rw-   0        0        0     2816 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/__init__.py
--rw-rw-rw-   0        0        0     2839 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.414233 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/
--rw-rw-rw-   0        0        0    12229 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Average.py
--rw-rw-rw-   0        0        0    12229 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Current.py
--rw-rw-rw-   0        0        0     1957 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Dallocation.py
--rw-rw-rw-   0        0        0     1578 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/DchType.py
--rw-rw-rw-   0        0        0     1441 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Dmodulation.py
--rw-rw-rw-   0        0        0    13131 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Extreme.py
--rw-rw-rw-   0        0        0     1290 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/SchType.py
--rw-rw-rw-   0        0        0     6480 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2030 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.444663 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/
--rw-rw-rw-   0        0        0     6322 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     6322 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     6322 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0     6322 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Minimum.py
--rw-rw-rw-   0        0        0     3993 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1485 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.462616 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/
--rw-rw-rw-   0        0        0     2796 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/Average.py
--rw-rw-rw-   0        0        0     2796 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/Current.py
--rw-rw-rw-   0        0        0     2796 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/__init__.py
--rw-rw-rw-   0        0        0     2223 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.498521 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/
--rw-rw-rw-   0        0        0     3105 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Average.py
--rw-rw-rw-   0        0        0     2893 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.530434 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/
--rw-rw-rw-   0        0        0     2792 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Average.py
--rw-rw-rw-   0        0        0     2792 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Current.py
--rw-rw-rw-   0        0        0     2792 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Maximum.py
--rw-rw-rw-   0        0        0     2792 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Minimum.py
--rw-rw-rw-   0        0        0     2824 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     3105 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Current.py
--rw-rw-rw-   0        0        0     3105 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Maximum.py
--rw-rw-rw-   0        0        0     3105 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Minimum.py
--rw-rw-rw-   0        0        0     2079 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0     2506 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.568334 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/
--rw-rw-rw-   0        0        0     4318 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Average.py
--rw-rw-rw-   0        0        0     4318 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Current.py
--rw-rw-rw-   0        0        0     1945 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Dallocation.py
--rw-rw-rw-   0        0        0     1566 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/DchType.py
--rw-rw-rw-   0        0        0     4498 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Extreme.py
--rw-rw-rw-   0        0        0     1696 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.590275 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/
--rw-rw-rw-   0        0        0     3063 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/All.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.604238 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/
--rw-rw-rw-   0        0        0     2559 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Negativ.py
--rw-rw-rw-   0        0        0     2559 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/__init__.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.617203 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2565 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Negativ.py
--rw-rw-rw-   0        0        0     2565 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.631166 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/
--rw-rw-rw-   0        0        0     2559 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Negativ.py
--rw-rw-rw-   0        0        0     2559 2021-05-16 18:20:00.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     2750 2021-05-16 18:19:59.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0     1839 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.640143 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/State_/
--rw-rw-rw-   0        0        0     2454 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/State_/__init__.py
--rw-rw-rw-   0        0        0     3159 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.688016 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/
--rw-rw-rw-   0        0        0     1232 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.701979 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/
--rw-rw-rw-   0        0        0     3045 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/Average.py
--rw-rw-rw-   0        0        0     3045 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     2685 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.710953 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/
--rw-rw-rw-   0        0        0     2099 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/Phase.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.730901 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/
--rw-rw-rw-   0        0        0     1999 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Average.py
--rw-rw-rw-   0        0        0     1999 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Current.py
--rw-rw-rw-   0        0        0     1999 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/__init__.py
--rw-rw-rw-   0        0        0     1968 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Evmc.py
--rw-rw-rw-   0        0        0      989 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.741873 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions_/
--rw-rw-rw-   0        0        0     3981 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Cc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions_/__init__.py
--rw-rw-rw-   0        0        0     1162 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.754837 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/
--rw-rw-rw-   0        0        0     1873 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/High.py
--rw-rw-rw-   0        0        0     1867 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/Low.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/__init__.py
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.772788 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/
--rw-rw-rw-   0        0        0     2655 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     2655 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     2655 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0      977 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.781765 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/
--rw-rw-rw-   0        0        0     3891 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Cc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0      977 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.790741 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable_/
--rw-rw-rw-   0        0        0     5597 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Cc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable_/__init__.py
--rw-rw-rw-   0        0        0      973 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.798720 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/
--rw-rw-rw-   0        0        0     2294 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.816671 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/
--rw-rw-rw-   0        0        0     3467 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Average.py
--rw-rw-rw-   0        0        0     3467 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Current.py
--rw-rw-rw-   0        0        0     3467 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/__init__.py
--rw-rw-rw-   0        0        0     1151 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/VfThroughput.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     6725 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.839610 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/
--rw-rw-rw-   0        0        0     2839 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.879503 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/
--rw-rw-rw-   0        0        0     8817 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Average.py
--rw-rw-rw-   0        0        0     8817 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Current.py
--rw-rw-rw-   0        0        0     1853 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.888479 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset_/
--rw-rw-rw-   0        0        0     2788 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset_/Preamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset_/__init__.py
--rw-rw-rw-   0        0        0     1816 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.896458 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex_/
--rw-rw-rw-   0        0        0     2763 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex_/Preamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex_/__init__.py
--rw-rw-rw-   0        0        0     9446 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Extreme.py
--rw-rw-rw-   0        0        0     6483 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Preamble.py
--rw-rw-rw-   0        0        0     2107 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.905435 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation_/
--rw-rw-rw-   0        0        0     3022 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation_/Preamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation_/__init__.py
--rw-rw-rw-   0        0        0     4978 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2030 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.933360 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/
--rw-rw-rw-   0        0        0     5194 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     5194 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     5194 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0     5194 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Minimum.py
--rw-rw-rw-   0        0        0     3192 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1823 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.943334 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/State_/
--rw-rw-rw-   0        0        0     2438 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/State_/__init__.py
--rw-rw-rw-   0        0        0     2414 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.982230 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/
--rw-rw-rw-   0        0        0     1948 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/EvPreamble.py
--rw-rw-rw-   0        0        0     1463 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:11.998187 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/
--rw-rw-rw-   0        0        0     2321 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Average.py
--rw-rw-rw-   0        0        0     2321 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Current.py
--rw-rw-rw-   0        0        0     2321 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/__init__.py
--rw-rw-rw-   0        0        0     1894 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Iq.py
--rw-rw-rw-   0        0        0     1487 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.017137 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/
--rw-rw-rw-   0        0        0     2329 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Average.py
--rw-rw-rw-   0        0        0     2329 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Current.py
--rw-rw-rw-   0        0        0     2329 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/__init__.py
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.035089 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/
--rw-rw-rw-   0        0        0     2455 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     2455 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     2455 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1487 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.052044 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/
--rw-rw-rw-   0        0        0     2329 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Average.py
--rw-rw-rw-   0        0        0     2329 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Current.py
--rw-rw-rw-   0        0        0     2329 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/__init__.py
--rw-rw-rw-   0        0        0     1960 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/PvPreamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/__init__.py
--rw-rw-rw-   0        0        0     2574 2021-05-16 18:19:53.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.060021 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/
--rw-rw-rw-   0        0        0     3741 2021-05-16 18:19:53.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/Scenario.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.072988 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/Scenario_/
--rw-rw-rw-   0        0        0     4964 2021-05-16 18:19:53.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/Scenario_/CombinedSignalPath.py
--rw-rw-rw-   0        0        0     1198 2021-05-16 18:19:53.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/Scenario_/MaProtocol.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/Scenario_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/__init__.py
--rw-rw-rw-   0        0        0     1339 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.086951 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/
--rw-rw-rw-   0        0        0     1213 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/CarrierAggregation.py
--rw-rw-rw-   0        0        0     1029 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.095926 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/
--rw-rw-rw-   0        0        0     1009 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.104903 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/
--rw-rw-rw-   0        0        0      975 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.113878 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/
--rw-rw-rw-   0        0        0     1483 2021-05-16 18:19:58.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/Rbw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/__init__.py
--rw-rw-rw-   0        0        0     6409 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.130833 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/
--rw-rw-rw-   0        0        0     2030 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.160753 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/
--rw-rw-rw-   0        0        0     5924 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     5924 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     5924 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0     5924 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Minimum.py
--rw-rw-rw-   0        0        0     3554 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1817 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.168733 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/State_/
--rw-rw-rw-   0        0        0     2432 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/State_/__init__.py
--rw-rw-rw-   0        0        0     1013 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.178705 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.195660 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/
--rw-rw-rw-   0        0        0     2723 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     2723 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     2723 2021-05-16 18:20:06.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/__init__.py
--rw-rw-rw-   0        0        0     1460 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.215607 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/
--rw-rw-rw-   0        0        0    11182 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.228572 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval_/
--rw-rw-rw-   0        0        0     1010 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval_/Catalog.py
--rw-rw-rw-   0        0        0     2440 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval_/ListPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     7154 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Prach.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.237549 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Prach_/
--rw-rw-rw-   0        0        0      990 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Prach_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Prach_/__init__.py
--rw-rw-rw-   0        0        0     7082 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Srs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.245527 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Srs_/
--rw-rw-rw-   0        0        0      982 2021-05-16 18:20:05.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Srs_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Srs_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/__init__.py
--rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/__init__.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:12.377176 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/
--rw-rw-rw-   0        0        0      541 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgLinkedEventArgs.py
--rw-rw-rw-   0        0        0     4003 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgSingle.py
--rw-rw-rw-   0        0        0     1061 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgSingleList.py
--rw-rw-rw-   0        0        0     1000 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgSingleSuppressed.py
--rw-rw-rw-   0        0        0     9026 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStringComposer.py
--rw-rw-rw-   0        0        0     5624 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStruct.py
--rw-rw-rw-   0        0        0     3354 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStructList.py
--rw-rw-rw-   0        0        0     2446 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStructStringParser.py
--rw-rw-rw-   0        0        0     5176 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/CommandsGroup.py
--rw-rw-rw-   0        0        0    20227 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Conversions.py
--rw-rw-rw-   0        0        0     3618 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ConverterFromScpiString.py
--rw-rw-rw-   0        0        0     4409 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ConverterToScpiString.py
--rw-rw-rw-   0        0        0    10299 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Core.py
--rw-rw-rw-   0        0        0    38340 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Instrument.py
--rw-rw-rw-   0        0        0     3918 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InstrumentErrors.py
--rw-rw-rw-   0        0        0     2081 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InstrumentOptions.py
--rw-rw-rw-   0        0        0     5101 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InstrumentSettings.py
--rw-rw-rw-   0        0        0     3380 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InternalLinker.py
--rw-rw-rw-   0        0        0     4331 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/IoTransferEventArgs.py
--rw-rw-rw-   0        0        0     3841 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/RepeatedCapability.py
--rw-rw-rw-   0        0        0     4719 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/StreamReader.py
--rw-rw-rw-   0        0        0     4938 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/StreamWriter.py
--rw-rw-rw-   0        0        0     1040 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/StructBase.py
--rw-rw-rw-   0        0        0     2893 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Types.py
--rw-rw-rw-   0        0        0     4530 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Utilities.py
--rw-rw-rw-   0        0        0     4850 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/VisaPluginSocketIo.py
--rw-rw-rw-   0        0        0    44232 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/VisaSession.py
--rw-rw-rw-   0        0        0     6999 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/VisaSessionSim.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/__init__.py
--rw-rw-rw-   0        0        0     9263 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/RsCmwLteMeas.py
--rw-rw-rw-   0        0        0      837 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/__init__.py
--rw-rw-rw-   0        0        0    13351 2021-05-16 18:19:49.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/enums.py
--rw-rw-rw-   0        0        0    11391 2021-05-16 18:19:49.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/repcap.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:20:08.082516 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/
--rw-rw-rw-   0        0        0     3899 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    65645 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        7 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/requires.txt
--rw-rw-rw-   0        0        0       13 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2021-05-16 18:20:12.390141 RsCmwLteMeas-3.7.62.23/setup.cfg
--rw-rw-rw-   0        0        0      861 2021-05-16 18:20:07.000000 RsCmwLteMeas-3.7.62.23/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.956714 RsCmwLteMeas-4.0.110/
+-rw-rw-rw-   0        0        0     4330 2024-04-17 13:01:45.956714 RsCmwLteMeas-4.0.110/PKG-INFO
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/README.rst
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.041982 RsCmwLteMeas-4.0.110/RsCmwLteMeas/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.061974 RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/
+-rw-rw-rw-   0        0        0       90 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/__init__.py
+-rw-rw-rw-   0        0        0     3725 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/events.py
+-rw-rw-rw-   0        0        0     4916 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/reliability.py
+-rw-rw-rw-   0        0        0    21849 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/utilities.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.061974 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.071967 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.081961 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/
+-rw-rw-rw-   0        0        0      914 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/ChannelBw.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.081961 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/
+-rw-rw-rw-   0        0        0     1903 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/Aggregated.py
+-rw-rw-rw-   0        0        0     1071 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.091958 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/
+-rw-rw-rw-   0        0        0     2775 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/Scc.py
+-rw-rw-rw-   0        0        0     3756 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/__init__.py
+-rw-rw-rw-   0        0        0     1612 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Mcarrier.py
+-rw-rw-rw-   0        0        0     2849 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Mode.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.091958 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/
+-rw-rw-rw-   0        0        0     2275 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/AcSpacing.py
+-rw-rw-rw-   0        0        0     1933 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/__init__.py
+-rw-rw-rw-   0        0        0     2287 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.101951 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Cc/
+-rw-rw-rw-   0        0        0     2814 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Cc/ChannelBw.py
+-rw-rw-rw-   0        0        0     1989 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Cc/__init__.py
+-rw-rw-rw-   0        0        0     3254 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Emtc.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.121941 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.121941 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/
+-rw-rw-rw-   0        0        0     2820 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/Sframes.py
+-rw-rw-rw-   0        0        0     1022 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.131936 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/
+-rw-rw-rw-   0        0        0     2487 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/PlcId.py
+-rw-rw-rw-   0        0        0     1961 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.131936 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.131936 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.147029 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.153960 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.157682 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.162124 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     7162 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     6638 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2063 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     3214 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1422 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     4875 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/ChannelBw.py
+-rw-rw-rw-   0        0        0     1379 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.162124 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.171383 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.171383 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.181378 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     7918 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     7394 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2063 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     3990 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1422 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     5625 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/ChannelBw.py
+-rw-rw-rw-   0        0        0     2317 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/__init__.py
+-rw-rw-rw-   0        0        0     1228 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.188227 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Pdynamics/
+-rw-rw-rw-   0        0        0     5426 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Pdynamics/ChannelBw.py
+-rw-rw-rw-   0        0        0     1065 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.210032 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/
+-rw-rw-rw-   0        0        0     3864 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/EsFlatness.py
+-rw-rw-rw-   0        0        0     3334 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/EvMagnitude.py
+-rw-rw-rw-   0        0        0     2331 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/FreqError.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.215017 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/
+-rw-rw-rw-   0        0        0     3798 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/IqOffset.py
+-rw-rw-rw-   0        0        0     4515 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/__init__.py
+-rw-rw-rw-   0        0        0     4146 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/IqOffset.py
+-rw-rw-rw-   0        0        0     3236 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Merror.py
+-rw-rw-rw-   0        0        0     3468 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Perror.py
+-rw-rw-rw-   0        0        0     3361 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Sflatness.py
+-rw-rw-rw-   0        0        0     3683 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.222046 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/
+-rw-rw-rw-   0        0        0     2642 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/EvMagnitude.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.232042 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Ibe/
+-rw-rw-rw-   0        0        0     3121 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Ibe/IqOffset.py
+-rw-rw-rw-   0        0        0     3844 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Ibe/__init__.py
+-rw-rw-rw-   0        0        0     3470 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/IqOffset.py
+-rw-rw-rw-   0        0        0     2546 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Merror.py
+-rw-rw-rw-   0        0        0     2778 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Perror.py
+-rw-rw-rw-   0        0        0     8356 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.232042 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/
+-rw-rw-rw-   0        0        0     4070 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/AtTolerance.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.242036 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.242036 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.252031 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.252031 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/
+-rw-rw-rw-   0        0        0     8790 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/ChannelBw2nd.py
+-rw-rw-rw-   0        0        0     2067 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     5685 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1424 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.262025 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/
+-rw-rw-rw-   0        0        0     5624 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/Sidelink.py
+-rw-rw-rw-   0        0        0     8038 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/__init__.py
+-rw-rw-rw-   0        0        0     2234 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.262025 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.262025 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.272020 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     8982 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     8458 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2063 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     5058 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1422 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     6638 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/ChannelBw.py
+-rw-rw-rw-   0        0        0     2473 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.282015 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.282015 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.282015 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.292010 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     5954 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     5426 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2063 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     2765 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     3634 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/ChannelBw.py
+-rw-rw-rw-   0        0        0     1394 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/__init__.py
+-rw-rw-rw-   0        0        0     1547 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     1932 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.292010 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/
+-rw-rw-rw-   0        0        0     2533 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Lrange.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.321994 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/
+-rw-rw-rw-   0        0        0     4708 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Aclr.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.331989 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/
+-rw-rw-rw-   0        0        0     2201 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/AcSpacing.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.331989 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/
+-rw-rw-rw-   0        0        0     2384 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/Enhanced.py
+-rw-rw-rw-   0        0        0     2823 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/__init__.py
+-rw-rw-rw-   0        0        0     1364 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     5674 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Cc.py
+-rw-rw-rw-   0        0        0     1895 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Cidx.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.341983 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/
+-rw-rw-rw-   0        0        0     2130 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/Nband.py
+-rw-rw-rw-   0        0        0     1010 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/__init__.py
+-rw-rw-rw-   0        0        0     4626 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Modulation.py
+-rw-rw-rw-   0        0        0     2102 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/PlcId.py
+-rw-rw-rw-   0        0        0     2014 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Pmonitor.py
+-rw-rw-rw-   0        0        0     3096 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Power.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.341983 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/
+-rw-rw-rw-   0        0        0     4164 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/Sidelink.py
+-rw-rw-rw-   0        0        0     4349 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/__init__.py
+-rw-rw-rw-   0        0        0     4769 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scc.py
+-rw-rw-rw-   0        0        0     4316 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SeMask.py
+-rw-rw-rw-   0        0        0     7406 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.357063 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/
+-rw-rw-rw-   0        0        0     2148 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/Connector.py
+-rw-rw-rw-   0        0        0     1067 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/__init__.py
+-rw-rw-rw-   0        0        0     3510 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Tdd.py
+-rw-rw-rw-   0        0        0     5251 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/__init__.py
+-rw-rw-rw-   0        0        0     1510 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/SingleCmw.py
+-rw-rw-rw-   0        0        0     7417 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.357063 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/
+-rw-rw-rw-   0        0        0     1978 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/CarrierAggregation.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.367060 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/
+-rw-rw-rw-   0        0        0     3726 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/Pusch.py
+-rw-rw-rw-   0        0        0     2643 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.371220 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/
+-rw-rw-rw-   0        0        0     4528 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/ChannelBw.py
+-rw-rw-rw-   0        0        0     3310 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/__init__.py
+-rw-rw-rw-   0        0        0     5122 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/__init__.py
+-rw-rw-rw-   0        0        0     2966 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/MsubFrames.py
+-rw-rw-rw-   0        0        0     3638 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/NsValue.py
+-rw-rw-rw-   0        0        0     1269 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pcc.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.371220 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/
+-rw-rw-rw-   0        0        0     3025 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/AeoPower.py
+-rw-rw-rw-   0        0        0     2383 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/__init__.py
+-rw-rw-rw-   0        0        0     1366 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Power.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.381215 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.388010 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/
+-rw-rw-rw-   0        0        0     3986 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/Nrb.py
+-rw-rw-rw-   0        0        0     4037 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/Orb.py
+-rw-rw-rw-   0        0        0     2785 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/__init__.py
+-rw-rw-rw-   0        0        0     3954 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Nrb.py
+-rw-rw-rw-   0        0        0     4502 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Orb.py
+-rw-rw-rw-   0        0        0     2517 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.388010 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Result/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.398005 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Result/EvMagnitude/
+-rw-rw-rw-   0        0        0     2874 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Result/EvMagnitude/EvmSymbol.py
+-rw-rw-rw-   0        0        0     3420 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Result/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0    34684 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Result/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.406046 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/
+-rw-rw-rw-   0        0        0     3125 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/Spectrum.py
+-rw-rw-rw-   0        0        0     3350 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.411034 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.416020 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/
+-rw-rw-rw-   0        0        0     2468 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/Enable.py
+-rw-rw-rw-   0        0        0     1016 2024-04-17 13:01:34.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/__init__.py
+-rw-rw-rw-   0        0        0     1596 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/SeMask.py
+-rw-rw-rw-   0        0        0     1254 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/__init__.py
+-rw-rw-rw-   0        0        0     1649 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Srs.py
+-rw-rw-rw-   0        0        0     4421 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Tmode.py
+-rw-rw-rw-   0        0        0    29423 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/__init__.py
+-rw-rw-rw-   0        0        0     2239 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Network.py
+-rw-rw-rw-   0        0        0     1388 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Pcc.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.427002 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.439009 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Limit/
+-rw-rw-rw-   0        0        0     2557 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Limit/EvMagnitude.py
+-rw-rw-rw-   0        0        0     2459 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Limit/Merror.py
+-rw-rw-rw-   0        0        0     3249 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Limit/Pdynamics.py
+-rw-rw-rw-   0        0        0     2691 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Limit/Perror.py
+-rw-rw-rw-   0        0        0     2979 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.442014 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.442014 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/
+-rw-rw-rw-   0        0        0     3400 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/Pformat.py
+-rw-rw-rw-   0        0        0     2091 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/__init__.py
+-rw-rw-rw-   0        0        0     2902 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/Sindex.py
+-rw-rw-rw-   0        0        0     5080 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/__init__.py
+-rw-rw-rw-   0        0        0     2965 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/PfOffset.py
+-rw-rw-rw-   0        0        0     1334 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Power.py
+-rw-rw-rw-   0        0        0    17374 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Result.py
+-rw-rw-rw-   0        0        0     2608 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Scount.py
+-rw-rw-rw-   0        0        0    13643 2024-04-17 13:01:35.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.452013 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.452013 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/
+-rw-rw-rw-   0        0        0     2969 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/Frequency.py
+-rw-rw-rw-   0        0        0     1993 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/__init__.py
+-rw-rw-rw-   0        0        0     1285 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Pcc.py
+-rw-rw-rw-   0        0        0     9266 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.462007 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.472003 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/Limit/
+-rw-rw-rw-   0        0        0     3237 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/Limit/Pdynamics.py
+-rw-rw-rw-   0        0        0     1043 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/Limit/__init__.py
+-rw-rw-rw-   0        0        0     1566 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/Scount.py
+-rw-rw-rw-   0        0        0     8619 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/__init__.py
+-rw-rw-rw-   0        0        0     8354 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.472003 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.491992 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/
+-rw-rw-rw-   0        0        0     6043 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/Average.py
+-rw-rw-rw-   0        0        0     6043 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/Current.py
+-rw-rw-rw-   0        0        0     1970 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/Dallocation.py
+-rw-rw-rw-   0        0        0     1567 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/DchType.py
+-rw-rw-rw-   0        0        0     1784 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.501986 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.501986 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/EvMagnitude/
+-rw-rw-rw-   0        0        0     2300 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/EvMagnitude/Peak.py
+-rw-rw-rw-   0        0        0     2931 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     2267 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Merror.py
+-rw-rw-rw-   0        0        0     2136 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Pdynamics.py
+-rw-rw-rw-   0        0        0     2267 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Perror.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.511981 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Pmonitor/
+-rw-rw-rw-   0        0        0     3439 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1002 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Pmonitor/__init__.py
+-rw-rw-rw-   0        0        0     2923 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/__init__.py
+-rw-rw-rw-   0        0        0     2401 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Bler.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.521977 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.531970 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/EvMagnitude/
+-rw-rw-rw-   0        0        0     2398 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/EvMagnitude/Peak.py
+-rw-rw-rw-   0        0        0     3029 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     2365 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Merror.py
+-rw-rw-rw-   0        0        0     2231 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pdynamics.py
+-rw-rw-rw-   0        0        0     2365 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Perror.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.531970 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pmonitor/
+-rw-rw-rw-   0        0        0     3534 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1002 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pmonitor/__init__.py
+-rw-rw-rw-   0        0        0     2949 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.541966 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/
+-rw-rw-rw-   0        0        0     5274 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.551960 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/
+-rw-rw-rw-   0        0        0     2265 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/ScIndex.py
+-rw-rw-rw-   0        0        0     5919 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/__init__.py
+-rw-rw-rw-   0        0        0     5274 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Extreme.py
+-rw-rw-rw-   0        0        0     3372 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/StandardDev.py
+-rw-rw-rw-   0        0        0     1815 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.561954 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/
+-rw-rw-rw-   0        0        0     2753 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Average.py
+-rw-rw-rw-   0        0        0     2753 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Current.py
+-rw-rw-rw-   0        0        0     2753 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Maximum.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.575796 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/
+-rw-rw-rw-   0        0        0     2790 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Average.py
+-rw-rw-rw-   0        0        0     2790 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Current.py
+-rw-rw-rw-   0        0        0     2790 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     1510 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/__init__.py
+-rw-rw-rw-   0        0        0     1764 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.577383 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.588318 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/
+-rw-rw-rw-   0        0        0     2099 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Average.py
+-rw-rw-rw-   0        0        0     2099 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Current.py
+-rw-rw-rw-   0        0        0     2099 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     2131 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/StandardDev.py
+-rw-rw-rw-   0        0        0     1786 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/__init__.py
+-rw-rw-rw-   0        0        0      996 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.588318 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.588318 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.604252 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/
+-rw-rw-rw-   0        0        0     2427 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.609237 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Current/
+-rw-rw-rw-   0        0        0     2321 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     3073 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.613226 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2321 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     3073 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2449 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1798 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1969 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/__init__.py
+-rw-rw-rw-   0        0        0     1030 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.618213 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.625021 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/
+-rw-rw-rw-   0        0        0     2318 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Dallocation.py
+-rw-rw-rw-   0        0        0     1703 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/DchType.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.633000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/
+-rw-rw-rw-   0        0        0     2469 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Average.py
+-rw-rw-rw-   0        0        0     2469 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Current.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.642031 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/
+-rw-rw-rw-   0        0        0     2665 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/Average.py
+-rw-rw-rw-   0        0        0     2665 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/Current.py
+-rw-rw-rw-   0        0        0     1285 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.642031 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/
+-rw-rw-rw-   0        0        0     2665 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/Average.py
+-rw-rw-rw-   0        0        0     2665 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/Current.py
+-rw-rw-rw-   0        0        0     1285 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/__init__.py
+-rw-rw-rw-   0        0        0     1762 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.652031 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.652031 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/
+-rw-rw-rw-   0        0        0     3276 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/Average.py
+-rw-rw-rw-   0        0        0     3276 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/Current.py
+-rw-rw-rw-   0        0        0     1285 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.662026 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/
+-rw-rw-rw-   0        0        0     3276 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/Average.py
+-rw-rw-rw-   0        0        0     3276 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/Current.py
+-rw-rw-rw-   0        0        0     1285 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/__init__.py
+-rw-rw-rw-   0        0        0     2209 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/__init__.py
+-rw-rw-rw-   0        0        0     1747 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.662026 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.682014 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/
+-rw-rw-rw-   0        0        0     3215 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Average.py
+-rw-rw-rw-   0        0        0     3215 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Current.py
+-rw-rw-rw-   0        0        0     3215 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Extreme.py
+-rw-rw-rw-   0        0        0     1851 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/StandardDev.py
+-rw-rw-rw-   0        0        0     2707 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.692009 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/
+-rw-rw-rw-   0        0        0     3113 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Average.py
+-rw-rw-rw-   0        0        0     3113 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Current.py
+-rw-rw-rw-   0        0        0     3113 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Extreme.py
+-rw-rw-rw-   0        0        0     1800 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/StandardDev.py
+-rw-rw-rw-   0        0        0     2651 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.711999 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/
+-rw-rw-rw-   0        0        0     3113 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Average.py
+-rw-rw-rw-   0        0        0     3113 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Current.py
+-rw-rw-rw-   0        0        0     3113 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Extreme.py
+-rw-rw-rw-   0        0        0     1800 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/StandardDev.py
+-rw-rw-rw-   0        0        0     2651 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.721993 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/
+-rw-rw-rw-   0        0        0     3091 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Average.py
+-rw-rw-rw-   0        0        0     3091 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Current.py
+-rw-rw-rw-   0        0        0     3091 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Extreme.py
+-rw-rw-rw-   0        0        0     1789 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/StandardDev.py
+-rw-rw-rw-   0        0        0     2635 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.721993 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.731988 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/
+-rw-rw-rw-   0        0        0     1730 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/Current.py
+-rw-rw-rw-   0        0        0     1906 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.731988 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/
+-rw-rw-rw-   0        0        0     1730 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/Current.py
+-rw-rw-rw-   0        0        0     1906 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/__init__.py
+-rw-rw-rw-   0        0        0     1283 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/__init__.py
+-rw-rw-rw-   0        0        0     1997 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.731988 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.751978 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/
+-rw-rw-rw-   0        0        0     1538 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Average.py
+-rw-rw-rw-   0        0        0     1538 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Current.py
+-rw-rw-rw-   0        0        0     1538 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Extreme.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.761972 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/
+-rw-rw-rw-   0        0        0     1391 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Current.py
+-rw-rw-rw-   0        0        0     1391 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Extreme.py
+-rw-rw-rw-   0        0        0     1285 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/__init__.py
+-rw-rw-rw-   0        0        0     1560 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     2042 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1064 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.777059 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/
+-rw-rw-rw-   0        0        0     2336 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Dallocation.py
+-rw-rw-rw-   0        0        0     1721 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/DchType.py
+-rw-rw-rw-   0        0        0     1672 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Dmodulation.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.777059 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.777059 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.798545 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Average.py
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Current.py
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Extreme.py
+-rw-rw-rw-   0        0        0     1527 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.804952 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Average.py
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Current.py
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1523 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/__init__.py
+-rw-rw-rw-   0        0        0     1215 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.804952 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.825054 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Average.py
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Current.py
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Extreme.py
+-rw-rw-rw-   0        0        0     1527 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.837869 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Average.py
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Current.py
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1523 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/__init__.py
+-rw-rw-rw-   0        0        0     1215 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.840861 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.852829 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/
+-rw-rw-rw-   0        0        0     2577 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Average.py
+-rw-rw-rw-   0        0        0     2577 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Current.py
+-rw-rw-rw-   0        0        0     2577 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Extreme.py
+-rw-rw-rw-   0        0        0     1522 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.865856 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/
+-rw-rw-rw-   0        0        0     2569 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Average.py
+-rw-rw-rw-   0        0        0     2569 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Current.py
+-rw-rw-rw-   0        0        0     2569 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1518 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/__init__.py
+-rw-rw-rw-   0        0        0     1210 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/__init__.py
+-rw-rw-rw-   0        0        0     1428 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.875850 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/
+-rw-rw-rw-   0        0        0     2459 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Average.py
+-rw-rw-rw-   0        0        0     2459 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Current.py
+-rw-rw-rw-   0        0        0     2459 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Extreme.py
+-rw-rw-rw-   0        0        0     1460 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/StandardDev.py
+-rw-rw-rw-   0        0        0     1813 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.885845 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/
+-rw-rw-rw-   0        0        0     2443 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Average.py
+-rw-rw-rw-   0        0        0     2443 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Current.py
+-rw-rw-rw-   0        0        0     2443 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Extreme.py
+-rw-rw-rw-   0        0        0     1452 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/StandardDev.py
+-rw-rw-rw-   0        0        0     1808 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.885845 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.895839 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.905834 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/
+-rw-rw-rw-   0        0        0     2599 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Average.py
+-rw-rw-rw-   0        0        0     2599 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Current.py
+-rw-rw-rw-   0        0        0     2599 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Extreme.py
+-rw-rw-rw-   0        0        0     1533 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.915829 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/
+-rw-rw-rw-   0        0        0     2591 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Average.py
+-rw-rw-rw-   0        0        0     2591 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Current.py
+-rw-rw-rw-   0        0        0     2591 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1529 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/__init__.py
+-rw-rw-rw-   0        0        0     1215 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.915829 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.925824 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/
+-rw-rw-rw-   0        0        0     2599 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Average.py
+-rw-rw-rw-   0        0        0     2599 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Current.py
+-rw-rw-rw-   0        0        0     2599 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Extreme.py
+-rw-rw-rw-   0        0        0     1533 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.941823 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/
+-rw-rw-rw-   0        0        0     2595 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Average.py
+-rw-rw-rw-   0        0        0     2595 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Current.py
+-rw-rw-rw-   0        0        0     2595 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1531 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/__init__.py
+-rw-rw-rw-   0        0        0     1215 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.951822 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.961817 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/
+-rw-rw-rw-   0        0        0     2593 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Average.py
+-rw-rw-rw-   0        0        0     2593 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Current.py
+-rw-rw-rw-   0        0        0     2593 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Extreme.py
+-rw-rw-rw-   0        0        0     1530 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.971812 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/
+-rw-rw-rw-   0        0        0     2585 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Average.py
+-rw-rw-rw-   0        0        0     2585 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Current.py
+-rw-rw-rw-   0        0        0     2585 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1526 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/__init__.py
+-rw-rw-rw-   0        0        0     1210 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/__init__.py
+-rw-rw-rw-   0        0        0     1443 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.971812 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.981806 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.996373 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Average.py
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Current.py
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Extreme.py
+-rw-rw-rw-   0        0        0     1532 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.005344 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/
+-rw-rw-rw-   0        0        0     2589 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Average.py
+-rw-rw-rw-   0        0        0     2589 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Current.py
+-rw-rw-rw-   0        0        0     2589 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1528 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/__init__.py
+-rw-rw-rw-   0        0        0     1215 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.005344 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.027231 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Average.py
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Current.py
+-rw-rw-rw-   0        0        0     2597 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Extreme.py
+-rw-rw-rw-   0        0        0     1532 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.040054 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/
+-rw-rw-rw-   0        0        0     2589 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Average.py
+-rw-rw-rw-   0        0        0     2589 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Current.py
+-rw-rw-rw-   0        0        0     2589 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1528 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/__init__.py
+-rw-rw-rw-   0        0        0     1215 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.042049 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.055014 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Average.py
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Current.py
+-rw-rw-rw-   0        0        0     2587 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Extreme.py
+-rw-rw-rw-   0        0        0     1527 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1792 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.066044 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Average.py
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Current.py
+-rw-rw-rw-   0        0        0     2579 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1523 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1787 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/__init__.py
+-rw-rw-rw-   0        0        0     1210 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/__init__.py
+-rw-rw-rw-   0        0        0     1443 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.076038 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/
+-rw-rw-rw-   0        0        0     2449 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Average.py
+-rw-rw-rw-   0        0        0     2449 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Current.py
+-rw-rw-rw-   0        0        0     2449 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Maximum.py
+-rw-rw-rw-   0        0        0     2449 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Minimum.py
+-rw-rw-rw-   0        0        0     1455 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/StandardDev.py
+-rw-rw-rw-   0        0        0     2042 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.096028 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/
+-rw-rw-rw-   0        0        0     2383 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Average.py
+-rw-rw-rw-   0        0        0     2383 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Current.py
+-rw-rw-rw-   0        0        0     2383 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Maximum.py
+-rw-rw-rw-   0        0        0     2383 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Minimum.py
+-rw-rw-rw-   0        0        0     1422 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/StandardDev.py
+-rw-rw-rw-   0        0        0     2027 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/__init__.py
+-rw-rw-rw-   0        0        0     1449 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/SchType.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.106022 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/
+-rw-rw-rw-   0        0        0     2483 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Average.py
+-rw-rw-rw-   0        0        0     2483 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Current.py
+-rw-rw-rw-   0        0        0     2483 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Extreme.py
+-rw-rw-rw-   0        0        0     1472 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/StandardDev.py
+-rw-rw-rw-   0        0        0     1798 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.116017 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/
+-rw-rw-rw-   0        0        0     2435 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Average.py
+-rw-rw-rw-   0        0        0     2435 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Current.py
+-rw-rw-rw-   0        0        0     2435 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Maximum.py
+-rw-rw-rw-   0        0        0     2435 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Minimum.py
+-rw-rw-rw-   0        0        0     1448 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/StandardDev.py
+-rw-rw-rw-   0        0        0     2042 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/__init__.py
+-rw-rw-rw-   0        0        0     3967 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.126012 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/
+-rw-rw-rw-   0        0        0     1830 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/Peak.py
+-rw-rw-rw-   0        0        0     1823 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/Rms.py
+-rw-rw-rw-   0        0        0     1230 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.126012 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.142010 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/
+-rw-rw-rw-   0        0        0     2016 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Average.py
+-rw-rw-rw-   0        0        0     2016 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Current.py
+-rw-rw-rw-   0        0        0     2016 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Maximum.py
+-rw-rw-rw-   0        0        0     2016 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Minimum.py
+-rw-rw-rw-   0        0        0     1298 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/StandardDev.py
+-rw-rw-rw-   0        0        0     2047 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/__init__.py
+-rw-rw-rw-   0        0        0     1027 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.152008 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/
+-rw-rw-rw-   0        0        0     2324 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Dallocation.py
+-rw-rw-rw-   0        0        0     1709 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/DchType.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.152008 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.162003 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.162003 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/
+-rw-rw-rw-   0        0        0     2421 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Average.py
+-rw-rw-rw-   0        0        0     2427 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Current.py
+-rw-rw-rw-   0        0        0     2421 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Minimum.py
+-rw-rw-rw-   0        0        0     1531 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.171998 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/
+-rw-rw-rw-   0        0        0     2473 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Average.py
+-rw-rw-rw-   0        0        0     2479 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Current.py
+-rw-rw-rw-   0        0        0     2473 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Minimum.py
+-rw-rw-rw-   0        0        0     1531 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/__init__.py
+-rw-rw-rw-   0        0        0     2083 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/__init__.py
+-rw-rw-rw-   0        0        0     1010 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.191989 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/
+-rw-rw-rw-   0        0        0     2371 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Average.py
+-rw-rw-rw-   0        0        0     2371 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Current.py
+-rw-rw-rw-   0        0        0     2371 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Extreme.py
+-rw-rw-rw-   0        0        0     1416 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/StandardDev.py
+-rw-rw-rw-   0        0        0     1783 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.211768 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/
+-rw-rw-rw-   0        0        0     2423 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Average.py
+-rw-rw-rw-   0        0        0     2423 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Current.py
+-rw-rw-rw-   0        0        0     2423 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Maximum.py
+-rw-rw-rw-   0        0        0     2423 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Minimum.py
+-rw-rw-rw-   0        0        0     1442 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/StandardDev.py
+-rw-rw-rw-   0        0        0     2047 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/__init__.py
+-rw-rw-rw-   0        0        0     2001 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.211768 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.222023 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/
+-rw-rw-rw-   0        0        0     7039 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Average.py
+-rw-rw-rw-   0        0        0     7039 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Current.py
+-rw-rw-rw-   0        0        0     2480 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Dallocation.py
+-rw-rw-rw-   0        0        0     2291 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/DchType.py
+-rw-rw-rw-   0        0        0     1788 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.232019 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/
+-rw-rw-rw-   0        0        0     5582 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.240133 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/
+-rw-rw-rw-   0        0        0     2843 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/ScIndex.py
+-rw-rw-rw-   0        0        0     6228 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/__init__.py
+-rw-rw-rw-   0        0        0     5582 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Extreme.py
+-rw-rw-rw-   0        0        0     3195 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/StandardDev.py
+-rw-rw-rw-   0        0        0     1818 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.243124 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.245120 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.253099 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/
+-rw-rw-rw-   0        0        0     2940 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.258593 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/
+-rw-rw-rw-   0        0        0     2828 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     3586 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.263580 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2828 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     3586 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2962 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1802 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1977 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.271558 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/
+-rw-rw-rw-   0        0        0     2163 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.272603 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/
+-rw-rw-rw-   0        0        0     2192 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     2809 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.272603 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2192 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     2809 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2185 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1800 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.282597 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.282597 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/
+-rw-rw-rw-   0        0        0     2495 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.292593 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/
+-rw-rw-rw-   0        0        0     2524 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     3141 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.302588 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2524 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     3141 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2517 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1802 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1917 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/__init__.py
+-rw-rw-rw-   0        0        0     1483 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.322577 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/
+-rw-rw-rw-   0        0        0    12810 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average.py
+-rw-rw-rw-   0        0        0    12810 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current.py
+-rw-rw-rw-   0        0        0     2498 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Dallocation.py
+-rw-rw-rw-   0        0        0     2309 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/DchType.py
+-rw-rw-rw-   0        0        0     2258 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Dmodulation.py
+-rw-rw-rw-   0        0        0    13920 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Extreme.py
+-rw-rw-rw-   0        0        0     2052 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/SchType.py
+-rw-rw-rw-   0        0        0     6429 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     2859 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.332571 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.332571 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/
+-rw-rw-rw-   0        0        0     1722 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/Length.py
+-rw-rw-rw-   0        0        0     1889 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/Start.py
+-rw-rw-rw-   0        0        0     1251 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/__init__.py
+-rw-rw-rw-   0        0        0     2234 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Peak.py
+-rw-rw-rw-   0        0        0     2225 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Rms.py
+-rw-rw-rw-   0        0        0     1460 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.352079 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/
+-rw-rw-rw-   0        0        0     3939 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.372068 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/
+-rw-rw-rw-   0        0        0     4702 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Average.py
+-rw-rw-rw-   0        0        0     4702 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Current.py
+-rw-rw-rw-   0        0        0     4704 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Maximum.py
+-rw-rw-rw-   0        0        0     4704 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Minimum.py
+-rw-rw-rw-   0        0        0     2693 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/StandardDev.py
+-rw-rw-rw-   0        0        0     2993 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/__init__.py
+-rw-rw-rw-   0        0        0     3939 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Current.py
+-rw-rw-rw-   0        0        0     3934 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Maximum.py
+-rw-rw-rw-   0        0        0     3934 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Minimum.py
+-rw-rw-rw-   0        0        0     2299 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/StandardDev.py
+-rw-rw-rw-   0        0        0     2242 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.382063 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/
+-rw-rw-rw-   0        0        0     4902 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Average.py
+-rw-rw-rw-   0        0        0     4902 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Current.py
+-rw-rw-rw-   0        0        0     2486 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Dallocation.py
+-rw-rw-rw-   0        0        0     2297 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/DchType.py
+-rw-rw-rw-   0        0        0     5262 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Extreme.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.392058 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/
+-rw-rw-rw-   0        0        0     3366 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/All.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.402052 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/
+-rw-rw-rw-   0        0        0     2950 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/Negativ.py
+-rw-rw-rw-   0        0        0     2950 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/Positiv.py
+-rw-rw-rw-   0        0        0     1287 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.409124 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/
+-rw-rw-rw-   0        0        0     2956 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/Negativ.py
+-rw-rw-rw-   0        0        0     2956 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/Positiv.py
+-rw-rw-rw-   0        0        0     1287 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.423592 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/
+-rw-rw-rw-   0        0        0     2950 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Negativ.py
+-rw-rw-rw-   0        0        0     2950 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Positiv.py
+-rw-rw-rw-   0        0        0     1287 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/__init__.py
+-rw-rw-rw-   0        0        0     1736 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/__init__.py
+-rw-rw-rw-   0        0        0     2695 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/StandardDev.py
+-rw-rw-rw-   0        0        0     2555 2024-04-17 13:01:39.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     3414 2024-04-17 13:01:38.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/__init__.py
+-rw-rw-rw-   0        0        0     1710 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Sreliability.py
+-rw-rw-rw-   0        0        0     3089 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.431524 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/
+-rw-rw-rw-   0        0        0     2841 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/Average.py
+-rw-rw-rw-   0        0        0     2841 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/Current.py
+-rw-rw-rw-   0        0        0     2841 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/Maximum.py
+-rw-rw-rw-   0        0        0     1518 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.461180 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/
+-rw-rw-rw-   0        0        0    13082 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Average.py
+-rw-rw-rw-   0        0        0    13082 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Current.py
+-rw-rw-rw-   0        0        0     1988 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Dallocation.py
+-rw-rw-rw-   0        0        0     1585 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/DchType.py
+-rw-rw-rw-   0        0        0     1448 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Dmodulation.py
+-rw-rw-rw-   0        0        0    14078 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Extreme.py
+-rw-rw-rw-   0        0        0     1297 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/SchType.py
+-rw-rw-rw-   0        0        0     6650 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     2855 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.472401 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/
+-rw-rw-rw-   0        0        0     6405 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     6405 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     6405 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     6405 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Minimum.py
+-rw-rw-rw-   0        0        0     3998 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/StandardDev.py
+-rw-rw-rw-   0        0        0     2054 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.482396 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/
+-rw-rw-rw-   0        0        0     2821 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/Average.py
+-rw-rw-rw-   0        0        0     2821 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/Current.py
+-rw-rw-rw-   0        0        0     2821 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/Maximum.py
+-rw-rw-rw-   0        0        0     1518 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.501250 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/
+-rw-rw-rw-   0        0        0     3182 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.515143 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/
+-rw-rw-rw-   0        0        0     2859 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Average.py
+-rw-rw-rw-   0        0        0     2859 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Current.py
+-rw-rw-rw-   0        0        0     2859 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Maximum.py
+-rw-rw-rw-   0        0        0     2859 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Minimum.py
+-rw-rw-rw-   0        0        0     2891 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/StandardDev.py
+-rw-rw-rw-   0        0        0     2986 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/__init__.py
+-rw-rw-rw-   0        0        0     3182 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Current.py
+-rw-rw-rw-   0        0        0     3182 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Maximum.py
+-rw-rw-rw-   0        0        0     3182 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Minimum.py
+-rw-rw-rw-   0        0        0     2136 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/StandardDev.py
+-rw-rw-rw-   0        0        0     2253 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.523166 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.523166 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/EvMagnitude/
+-rw-rw-rw-   0        0        0     1963 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/EvMagnitude/Peak.py
+-rw-rw-rw-   0        0        0     2594 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     1931 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Merror.py
+-rw-rw-rw-   0        0        0     1802 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pdynamics.py
+-rw-rw-rw-   0        0        0     1931 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Perror.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.533162 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/
+-rw-rw-rw-   0        0        0     3129 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1002 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/__init__.py
+-rw-rw-rw-   0        0        0     2091 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.542169 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/
+-rw-rw-rw-   0        0        0     4421 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Average.py
+-rw-rw-rw-   0        0        0     4421 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Current.py
+-rw-rw-rw-   0        0        0     1976 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Dallocation.py
+-rw-rw-rw-   0        0        0     1573 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/DchType.py
+-rw-rw-rw-   0        0        0     4633 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Extreme.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.552168 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/
+-rw-rw-rw-   0        0        0     3086 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/All.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.562163 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/
+-rw-rw-rw-   0        0        0     2582 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/Negativ.py
+-rw-rw-rw-   0        0        0     2582 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/Positiv.py
+-rw-rw-rw-   0        0        0     1283 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.562163 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/
+-rw-rw-rw-   0        0        0     2588 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/Negativ.py
+-rw-rw-rw-   0        0        0     2588 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/Positiv.py
+-rw-rw-rw-   0        0        0     1283 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.572158 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/
+-rw-rw-rw-   0        0        0     2582 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/Negativ.py
+-rw-rw-rw-   0        0        0     2582 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/Positiv.py
+-rw-rw-rw-   0        0        0     1283 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/__init__.py
+-rw-rw-rw-   0        0        0     1732 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/__init__.py
+-rw-rw-rw-   0        0        0     2785 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/StandardDev.py
+-rw-rw-rw-   0        0        0     2551 2024-04-17 13:01:37.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.582152 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/State/
+-rw-rw-rw-   0        0        0     2028 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/State/All.py
+-rw-rw-rw-   0        0        0     2718 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.582152 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.592148 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/
+-rw-rw-rw-   0        0        0     3102 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/Average.py
+-rw-rw-rw-   0        0        0     3102 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/Current.py
+-rw-rw-rw-   0        0        0     1266 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.592148 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/
+-rw-rw-rw-   0        0        0     2118 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/Phase.py
+-rw-rw-rw-   0        0        0     2722 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.602143 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/
+-rw-rw-rw-   0        0        0     1980 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Average.py
+-rw-rw-rw-   0        0        0     1980 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Current.py
+-rw-rw-rw-   0        0        0     1980 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Maximum.py
+-rw-rw-rw-   0        0        0     1535 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/__init__.py
+-rw-rw-rw-   0        0        0     1987 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Evmc.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.612136 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/
+-rw-rw-rw-   0        0        0     4057 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/Cc.py
+-rw-rw-rw-   0        0        0     1012 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.622606 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/
+-rw-rw-rw-   0        0        0     1900 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/High.py
+-rw-rw-rw-   0        0        0     1894 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/Low.py
+-rw-rw-rw-   0        0        0     1200 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.633576 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/
+-rw-rw-rw-   0        0        0     2666 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     2666 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     2666 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     1535 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.639327 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/
+-rw-rw-rw-   0        0        0     3967 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1002 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.645918 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/
+-rw-rw-rw-   0        0        0     5684 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/Cc.py
+-rw-rw-rw-   0        0        0     1002 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.646940 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.655605 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/
+-rw-rw-rw-   0        0        0     3496 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Average.py
+-rw-rw-rw-   0        0        0     3496 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Current.py
+-rw-rw-rw-   0        0        0     3496 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Maximum.py
+-rw-rw-rw-   0        0        0     2350 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/__init__.py
+-rw-rw-rw-   0        0        0     1000 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     3223 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/__init__.py
+-rw-rw-rw-   0        0        0     1134 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/VfThroughput.py
+-rw-rw-rw-   0        0        0     9172 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.655605 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.665600 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/
+-rw-rw-rw-   0        0        0     2895 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Average.py
+-rw-rw-rw-   0        0        0     2895 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Current.py
+-rw-rw-rw-   0        0        0     2895 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Maximum.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.679749 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/
+-rw-rw-rw-   0        0        0     2932 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/Average.py
+-rw-rw-rw-   0        0        0     2932 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/Current.py
+-rw-rw-rw-   0        0        0     2932 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     1510 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/__init__.py
+-rw-rw-rw-   0        0        0     1754 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.697575 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/
+-rw-rw-rw-   0        0        0     9400 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Average.py
+-rw-rw-rw-   0        0        0     9400 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Current.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.702562 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/
+-rw-rw-rw-   0        0        0     2839 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/Preamble.py
+-rw-rw-rw-   0        0        0     1888 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.706591 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DsIndex/
+-rw-rw-rw-   0        0        0     2814 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DsIndex/Preamble.py
+-rw-rw-rw-   0        0        0     1853 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DsIndex/__init__.py
+-rw-rw-rw-   0        0        0    10043 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Extreme.py
+-rw-rw-rw-   0        0        0     1177 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Nsymbol.py
+-rw-rw-rw-   0        0        0     6658 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Preamble.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.706591 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/
+-rw-rw-rw-   0        0        0     3071 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/Preamble.py
+-rw-rw-rw-   0        0        0     2137 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/__init__.py
+-rw-rw-rw-   0        0        0     5113 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     3099 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.726581 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/
+-rw-rw-rw-   0        0        0     5361 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     5361 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     5361 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     5361 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Minimum.py
+-rw-rw-rw-   0        0        0     3239 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/StandardDev.py
+-rw-rw-rw-   0        0        0     2054 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.726581 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/State/
+-rw-rw-rw-   0        0        0     2012 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/State/All.py
+-rw-rw-rw-   0        0        0     2702 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.736575 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/
+-rw-rw-rw-   0        0        0     1963 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/EvPreamble.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.746570 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/
+-rw-rw-rw-   0        0        0     2336 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/Average.py
+-rw-rw-rw-   0        0        0     2336 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/Current.py
+-rw-rw-rw-   0        0        0     2336 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/Maximum.py
+-rw-rw-rw-   0        0        0     1505 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/__init__.py
+-rw-rw-rw-   0        0        0     1921 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Iq.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.756565 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/
+-rw-rw-rw-   0        0        0     2346 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/Average.py
+-rw-rw-rw-   0        0        0     2346 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/Current.py
+-rw-rw-rw-   0        0        0     2346 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/Maximum.py
+-rw-rw-rw-   0        0        0     1520 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.766560 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/
+-rw-rw-rw-   0        0        0     2474 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     2474 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     2474 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     1535 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.776554 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/
+-rw-rw-rw-   0        0        0     2346 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/Average.py
+-rw-rw-rw-   0        0        0     2346 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/Current.py
+-rw-rw-rw-   0        0        0     2346 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/Maximum.py
+-rw-rw-rw-   0        0        0     1520 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/__init__.py
+-rw-rw-rw-   0        0        0     1975 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/PvPreamble.py
+-rw-rw-rw-   0        0        0     2466 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/__init__.py
+-rw-rw-rw-   0        0        0     5565 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.776554 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.786549 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/Scenario/
+-rw-rw-rw-   0        0        0     4930 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/Scenario/CombinedSignalPath.py
+-rw-rw-rw-   0        0        0     1183 2024-04-17 13:01:33.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/Scenario/MaProtocol.py
+-rw-rw-rw-   0        0        0     2601 2024-04-17 13:01:32.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/Scenario/Salone.py
+-rw-rw-rw-   0        0        0     2230 2024-04-17 13:01:32.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/Scenario/__init__.py
+-rw-rw-rw-   0        0        0     2635 2024-04-17 13:01:32.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.796544 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/
+-rw-rw-rw-   0        0        0     1220 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/CarrierAggregation.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.796544 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.806538 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.806538 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/SeMask/
+-rw-rw-rw-   0        0        0     1745 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/SeMask/Rbw.py
+-rw-rw-rw-   0        0        0     1002 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     1034 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/__init__.py
+-rw-rw-rw-   0        0        0     1053 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/__init__.py
+-rw-rw-rw-   0        0        0     1371 2024-04-17 13:01:36.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.806538 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.830978 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/
+-rw-rw-rw-   0        0        0     6155 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     6155 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     6155 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     6155 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Minimum.py
+-rw-rw-rw-   0        0        0     3613 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/StandardDev.py
+-rw-rw-rw-   0        0        0     2054 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.839097 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/State/
+-rw-rw-rw-   0        0        0     2006 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/State/All.py
+-rw-rw-rw-   0        0        0     2696 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.839097 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.846603 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/
+-rw-rw-rw-   0        0        0     2742 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     2742 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     2742 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     1535 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/__init__.py
+-rw-rw-rw-   0        0        0     1041 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/__init__.py
+-rw-rw-rw-   0        0        0     5003 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.855599 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.862580 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/MultiEval/
+-rw-rw-rw-   0        0        0     1024 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/MultiEval/Catalog.py
+-rw-rw-rw-   0        0        0     3840 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/MultiEval/ListPy.py
+-rw-rw-rw-   0        0        0    11241 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/MultiEval/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.867567 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Prach/
+-rw-rw-rw-   0        0        0     1004 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Prach/Catalog.py
+-rw-rw-rw-   0        0        0     7189 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Prach/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.873153 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Srs/
+-rw-rw-rw-   0        0        0      996 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Srs/Catalog.py
+-rw-rw-rw-   0        0        0     7119 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Srs/__init__.py
+-rw-rw-rw-   0        0        0     1490 2024-04-17 13:01:40.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/__init__.py
+-rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:45.946718 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/
+-rw-rw-rw-   0        0        0      586 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgLinkedEventArgs.py
+-rw-rw-rw-   0        0        0     4165 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgSingle.py
+-rw-rw-rw-   0        0        0     1116 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgSingleList.py
+-rw-rw-rw-   0        0        0     1145 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgSingleSuppressed.py
+-rw-rw-rw-   0        0        0     9097 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStringComposer.py
+-rw-rw-rw-   0        0        0     5751 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStruct.py
+-rw-rw-rw-   0        0        0     3439 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStructList.py
+-rw-rw-rw-   0        0        0     2546 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStructStringParser.py
+-rw-rw-rw-   0        0        0     5238 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/CommandsGroup.py
+-rw-rw-rw-   0        0        0    25419 2024-04-03 11:15:31.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Conversions.py
+-rw-rw-rw-   0        0        0     3775 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ConverterFromScpiString.py
+-rw-rw-rw-   0        0        0     4768 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ConverterToScpiString.py
+-rw-rw-rw-   0        0        0    14213 2024-04-03 11:15:31.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Core.py
+-rw-rw-rw-   0        0        0     1386 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/GlobalData.py
+-rw-rw-rw-   0        0        0    60862 2024-04-03 11:15:31.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Instrument.py
+-rw-rw-rw-   0        0        0     4785 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InstrumentErrors.py
+-rw-rw-rw-   0        0        0     2225 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InstrumentOptions.py
+-rw-rw-rw-   0        0        0    16156 2024-04-03 11:15:31.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InstrumentSettings.py
+-rw-rw-rw-   0        0        0     3518 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InternalLinker.py
+-rw-rw-rw-   0        0        0     4390 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/IoTransferEventArgs.py
+-rw-rw-rw-   0        0        0      387 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Properties.py
+-rw-rw-rw-   0        0        0     4289 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/RepeatedCapability.py
+-rw-rw-rw-   0        0        0     4745 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ScpiEnums.py
+-rw-rw-rw-   0        0        0    35525 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ScpiLogger.py
+-rw-rw-rw-   0        0        0     5098 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/StreamReader.py
+-rw-rw-rw-   0        0        0     5856 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/StreamWriter.py
+-rw-rw-rw-   0        0        0     1114 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/StructBase.py
+-rw-rw-rw-   0        0        0     3608 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Types.py
+-rw-rw-rw-   0        0        0     5498 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Utilities.py
+-rw-rw-rw-   0        0        0     5716 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/VisaPluginSocketIo.py
+-rw-rw-rw-   0        0        0    51976 2024-04-03 11:15:31.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/VisaSession.py
+-rw-rw-rw-   0        0        0     7512 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/VisaSessionSim.py
+-rw-rw-rw-   0        0        0       29 2024-02-28 16:27:53.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/__init__.py
+-rw-rw-rw-   0        0        0    13521 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/RsCmwLteMeas.py
+-rw-rw-rw-   0        0        0      912 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/__init__.py
+-rw-rw-rw-   0        0        0    14343 2024-04-17 13:01:32.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/enums.py
+-rw-rw-rw-   0        0        0    11472 2024-04-17 13:01:29.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas/repcap.py
+drwxrwxrwx   0        0        0        0 2024-04-17 13:01:44.051979 RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/
+-rw-rw-rw-   0        0        0     4330 2024-04-17 13:01:43.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    52540 2024-04-17 13:01:43.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-17 13:01:43.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       15 2024-04-17 13:01:43.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       13 2024-04-17 13:01:43.000000 RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2024-04-17 13:01:45.956714 RsCmwLteMeas-4.0.110/setup.cfg
+-rw-rw-rw-   0        0        0     1474 2024-04-17 13:01:41.000000 RsCmwLteMeas-4.0.110/setup.py
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/events.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/events.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,79 +1,89 @@
-from typing import Callable
-
-from ..Internal import Core
-
-
-class Events:
-	"""Common Events class.
-	Event-related methods common for all types of drivers."""
-	def __init__(self, core: Core):
-		self._core = core
-
-	@property
-	def io_events_include_data(self) -> bool:
-		"""Returns the current state of the io_events_include_data See the setter for more details."""
-		return self._core.io.io_events_include_data
-
-	@io_events_include_data.setter
-	def io_events_include_data(self, value: bool) -> None:
-		"""If True, the on_write and on_read events include also the sent/received data.
-		Default value is False, to avoid handling potentially big data."""
-		self._core.io.io_events_include_data = value
-
-	@property
-	def before_write_handler(self) -> Callable:
-		"""Returns the handler of before_write events. \n
-		:return: current before_write_handler"""
-		return self._core.io.before_write_handler
-
-	@before_write_handler.setter
-	def before_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_write events.
-		The before_write event is invoked before each write operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, cmd: str)
-		:param handler: new handler"""
-		self._core.io.before_write_handler = handler
-
-	@property
-	def on_write_handler(self) -> Callable:
-		"""Returns the handler of on_write events. \n
-		:return: current on_write_handler"""
-		return self._core.io.on_write_handler
-
-	@on_write_handler.setter
-	def on_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_write events.
-		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all write operations"""
-		self._core.io.on_write_handler = handler
-
-	@property
-	def on_read_handler(self) -> Callable:
-		"""Returns the handler of on_read events. \n
-		:return: current on_read_handler"""
-		return self._core.io.on_read_handler
-
-	@on_read_handler.setter
-	def on_read_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_read events.
-		The on_read event is invoked every time the driver performs a read operation to the instrument.
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all read operations"""
-		self._core.io.on_read_handler = handler
-
-	@property
-	def before_query_handler(self) -> Callable:
-		"""Returns the handler of before_query events. \n
-		:return: current before_query_handler"""
-		return self._core.io.before_query_handler
-
-	@before_query_handler.setter
-	def before_query_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_query events.
-		The before_query event is invoked before each query operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, query: str)
-		:param handler: new handler"""
-		self._core.io.before_query_handler = handler
+"""Event-related methods and properties. Here you can set all the event handlers."""
+
+from typing import Callable
+
+from ..Internal import Core
+
+
+class Events:
+	"""Common Events class.
+	Event-related methods and properties. Here you can set all the event handlers."""
+	def __init__(self, core: Core):
+		self._core = core
+
+	@property
+	def io_events_include_data(self) -> bool:
+		"""Returns the current state of the io_events_include_data See the setter for more details."""
+		return self._core.io.io_events_include_data
+
+	@io_events_include_data.setter
+	def io_events_include_data(self, value: bool) -> None:
+		"""If True, the on_write and on_read events include also the transferred data.
+		Default value is False, to avoid handling potentially big data."""
+		self._core.io.io_events_include_data = value
+
+	@property
+	def before_write_handler(self) -> Callable:
+		"""Returns the handler of before_write events. \n
+		:return: current ``before_write_handler``"""
+		return self._core.io.before_write_handler
+
+	@before_write_handler.setter
+	def before_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_write events.
+		The before_write event is invoked before each write operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, cmd: str)
+		:param handler: new handler"""
+		self._core.io.before_write_handler = handler
+
+	@property
+	def on_write_handler(self) -> Callable:
+		"""Returns the handler of on_write events. \n
+		:return: current ``on_write_handler``"""
+		return self._core.io.on_write_handler
+
+	@on_write_handler.setter
+	def on_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_write events.
+		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all write operations"""
+		self._core.io.on_write_handler = handler
+
+	@property
+	def on_read_handler(self) -> Callable:
+		"""Returns the handler of on_read events. \n
+		:return: current ``on_read_handler``"""
+		return self._core.io.on_read_handler
+
+	@on_read_handler.setter
+	def on_read_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_read events.
+		The on_read event is invoked every time the driver performs a read operation to the instrument.
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all read operations"""
+		self._core.io.on_read_handler = handler
+
+	@property
+	def before_query_handler(self) -> Callable:
+		"""Returns the handler of before_query events. \n
+		:return: current ``before_query_handler``"""
+		return self._core.io.before_query_handler
+
+	@before_query_handler.setter
+	def before_query_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_query events.
+		The before_query event is invoked before each query operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, query: str)
+		:param handler: new handler"""
+		self._core.io.before_query_handler = handler
+
+	def sync_from(self, source: 'Events') -> None:
+		"""Synchronises these Events with the source."""
+		self.before_query_handler = source.before_query_handler
+		self.before_write_handler = source.before_write_handler
+		self.io_events_include_data = source.io_events_include_data
+		self.on_read_handler = source.on_read_handler
+		self.on_write_handler = source.on_write_handler
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/CustomFiles/reliability.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/CustomFiles/reliability.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Class for R&S Mobile Radio Test instruments that use reliability indicators."""
+
+
 import time
 from typing import Callable
 
 from ..Internal import ArgLinkedEventArgs
 from ..Internal import Core
 
 codes_table = {
@@ -60,25 +63,25 @@
 		self.context = context
 
 
 class Reliability:
 	"""Reliability class that handles all the necessary tasks related to reliability indicator."""
 
 	def __init__(self, core: Core):
-		self._core = core
-		self._last_value = 0
-		self._last_context = ''
+		self._core: Core = core
+		self._last_value: int = 0
+		self._last_context: str = ''
 		self._last_timestamp = None
 		self._exception_on_error = False
 		# noinspection PyTypeChecker
 		self._on_update_handler: Callable = None
 		self._core.set_link_handler('Reliability', self._permanent_on_update_handler)
 
 	@property
-	def last_value(self):
+	def last_value(self) -> int:
 		"""Returns the last updated Reliability code."""
 		return self._last_value
 
 	@property
 	def last_context(self) -> str:
 		"""Returns the last updated Context of the reliability code - usually the SCPI query on which the instrument responded with the Reliability code."""
 		return self._last_context
@@ -94,36 +97,39 @@
 		if self._last_value in codes_table:
 			return codes_table[self._last_value]
 		else:
 			return f'Undefined reliability code {self._last_value}.'
 
 	@property
 	def exception_on_error(self) -> bool:
-		"""see the exception_on_error.setter."""
+		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		return self._exception_on_error
 
 	@exception_on_error.setter
 	def exception_on_error(self, value) -> None:
 		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		self._exception_on_error = value
 
 	def on_update_handler(self, handler: Callable) -> None:
 		"""Register the handler for on_update event.
 		This handler is invoked with each update of the reliability indicator.
 		Handler API: handler(event_args: ReliabilityEventArgs)"""
 		self._on_update_handler = handler
 
-	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs):
+	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs) -> None:
 		"""Permanent on_update handler. Takes care of updating all the 'last_xxx' values and calling a user-defined updated_handler."""
 		self._last_value = int(str(event_args.value))
 		self._last_context = event_args.context
 		self._last_timestamp = event_args.timestamp
-
 		if self._on_update_handler:
 			# Call the additional handler if registered
 			rel_events_args = ReliabilityEventArgs(self._last_timestamp, self._last_value, self.last_message, self._last_context)
 			self._on_update_handler(rel_events_args)
-
 		if self._exception_on_error and self._last_value != 0:
 			raise Exception(
 				f'Reliability indicator error. Time: {time.strftime("%H:%M:%S", time.localtime(self._last_timestamp))}, '
 				f'Context: {self._last_context}, Value {self._last_value}: {self.last_message}')
+
+	def sync_from(self, source: 'Reliability') -> None:
+		"""Synchronises this Reliability with the source."""
+		self.exception_on_error = source.exception_on_error
+		self.on_update_handler(source._on_update_handler)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,119 +1,146 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal import Conversions
-from .. import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal import Conversions
+from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Configure:
-	"""Configure commands group definition. 199 total commands, 8 Sub-groups, 4 group commands"""
+class ConfigureCls:
+	"""Configure commands group definition. 209 total commands, 9 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("configure", core, parent)
+		self._cmd_group = CommandsGroup("configure", core, parent)
+
+	@property
+	def network(self):
+		"""network commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_network'):
+			from .Network import NetworkCls
+			self._network = NetworkCls(self._core, self._cmd_group)
+		return self._network
 
 	@property
 	def rfSettings(self):
 		"""rfSettings commands group. 2 Sub-classes, 5 commands."""
 		if not hasattr(self, '_rfSettings'):
-			from .Configure_.RfSettings import RfSettings
-			self._rfSettings = RfSettings(self._core, self._base)
+			from .RfSettings import RfSettingsCls
+			self._rfSettings = RfSettingsCls(self._core, self._cmd_group)
 		return self._rfSettings
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 6 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Configure_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	@property
 	def emtc(self):
-		"""emtc commands group. 0 Sub-classes, 2 commands."""
+		"""emtc commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_emtc'):
-			from .Configure_.Emtc import Emtc
-			self._emtc = Emtc(self._core, self._base)
+			from .Emtc import EmtcCls
+			self._emtc = EmtcCls(self._core, self._cmd_group)
 		return self._emtc
 
 	@property
 	def multiEval(self):
-		"""multiEval commands group. 15 Sub-classes, 19 commands."""
+		"""multiEval commands group. 16 Sub-classes, 18 commands."""
 		if not hasattr(self, '_multiEval'):
-			from .Configure_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
 		return self._multiEval
 
 	@property
 	def pcc(self):
 		"""pcc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pcc'):
-			from .Configure_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
 	@property
 	def cc(self):
 		"""cc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cc'):
-			from .Configure_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def prach(self):
-		"""prach commands group. 6 Sub-classes, 7 commands."""
+		"""prach commands group. 6 Sub-classes, 8 commands."""
 		if not hasattr(self, '_prach'):
-			from .Configure_.Prach import Prach
-			self._prach = Prach(self._core, self._base)
+			from .Prach import PrachCls
+			self._prach = PrachCls(self._core, self._cmd_group)
 		return self._prach
 
 	@property
 	def srs(self):
 		"""srs commands group. 2 Sub-classes, 5 commands."""
 		if not hasattr(self, '_srs'):
-			from .Configure_.Srs import Srs
-			self._srs = Srs(self._core, self._base)
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
 		return self._srs
 
 	# noinspection PyTypeChecker
 	def get_band(self) -> enums.Band:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:BAND \n
 		Snippet: value: enums.Band = driver.configure.get_band() \n
 		Selects the operating band (OB) .
 			INTRO_CMD_HELP: The allowed input range has dependencies: \n
-			- FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85
-			- TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB52 | OB250
+			- FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85 | OB87 | OB88
+			- TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB53 | OB250
 			- Sidelink: OB47
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:BAND
+			- CONFigure:LTE:SIGN<i>[:PCC]:BAND
 			- CONFigure:LTE:SIGN<i>:SCC<c>:BAND \n
 			:return: band: OB1 to OB250, see list above
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:BAND?')
 		return Conversions.str_to_scalar_enum(response, enums.Band)
 
 	def set_band(self, band: enums.Band) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:BAND \n
 		Snippet: driver.configure.set_band(band = enums.Band.OB1) \n
 		Selects the operating band (OB) .
 			INTRO_CMD_HELP: The allowed input range has dependencies: \n
-			- FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85
-			- TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB52 | OB250
+			- FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85 | OB87 | OB88
+			- TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB53 | OB250
 			- Sidelink: OB47
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:BAND
+			- CONFigure:LTE:SIGN<i>[:PCC]:BAND
 			- CONFigure:LTE:SIGN<i>:SCC<c>:BAND \n
 			:param band: OB1 to OB250, see list above
 		"""
 		param = Conversions.enum_scalar_to_str(band, enums.Band)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:BAND {param}')
 
 	# noinspection PyTypeChecker
+	def get_spath(self) -> enums.Path:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SPATh \n
+		Snippet: value: enums.Path = driver.configure.get_spath() \n
+		No command help available \n
+			:return: path: No help available
+		"""
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SPATh?')
+		return Conversions.str_to_scalar_enum(response, enums.Path)
+
+	def set_spath(self, path: enums.Path) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SPATh \n
+		Snippet: driver.configure.set_spath(path = enums.Path.NETWork) \n
+		No command help available \n
+			:param path: No help available
+		"""
+		param = Conversions.enum_scalar_to_str(path, enums.Path)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SPATh {param}')
+
+	# noinspection PyTypeChecker
 	def get_stype(self) -> enums.SignalType:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:STYPe \n
 		Snippet: value: enums.SignalType = driver.configure.get_stype() \n
 		Selects the type of the measured signal. \n
 			:return: signal_type: UL | SL UL: LTE uplink signal with PUSCH or PUCCH SL: V2X sidelink signal with PSSCH and PSCCH
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:STYPe?')
@@ -130,30 +157,30 @@
 
 	# noinspection PyTypeChecker
 	def get_dmode(self) -> enums.DuplexMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:DMODe \n
 		Snippet: value: enums.DuplexMode = driver.configure.get_dmode() \n
 		Selects the duplex mode of the LTE signal: FDD or TDD.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:DMODe
+			- CONFigure:LTE:SIGN<i>[:PCC]:DMODe
 			- CONFigure:LTE:SIGN<i>:SCC<c>:DMODe
-			- CONFigure:LTE:DMODe:UCSPecific \n
+			- CONFigure:LTE:SIGN<i>[:PCC]:DMODe:UCSPecific \n
 			:return: mode: FDD | TDD
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:DMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.DuplexMode)
 
 	def set_dmode(self, mode: enums.DuplexMode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:DMODe \n
 		Snippet: driver.configure.set_dmode(mode = enums.DuplexMode.FDD) \n
 		Selects the duplex mode of the LTE signal: FDD or TDD.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:DMODe
+			- CONFigure:LTE:SIGN<i>[:PCC]:DMODe
 			- CONFigure:LTE:SIGN<i>:SCC<c>:DMODe
-			- CONFigure:LTE:DMODe:UCSPecific \n
+			- CONFigure:LTE:SIGN<i>[:PCC]:DMODe:UCSPecific \n
 			:param mode: FDD | TDD
 		"""
 		param = Conversions.enum_scalar_to_str(mode, enums.DuplexMode)
 		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:DMODe {param}')
 
 	# noinspection PyTypeChecker
 	def get_fstructure(self) -> enums.FrameStructure:
@@ -162,14 +189,14 @@
 		Queries the frame structure type of the LTE signal. The value depends on the duplex mode (method RsCmwLteMeas.Configure.
 		dmode) . \n
 			:return: frame_structure: T1 | T2 T1: Type 1, FDD signal T2: Type 2, TDD signal
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:FSTRucture?')
 		return Conversions.str_to_scalar_enum(response, enums.FrameStructure)
 
-	def clone(self) -> 'Configure':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ConfigureCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Configure(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ConfigureCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 11 total commands, 6 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 11 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def mode(self):
 		"""mode commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_mode'):
-			from .CarrierAggregation_.Mode import Mode
-			self._mode = Mode(self._core, self._base)
+			from .Mode import ModeCls
+			self._mode = ModeCls(self._core, self._cmd_group)
 		return self._mode
 
 	@property
 	def mcarrier(self):
 		"""mcarrier commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_mcarrier'):
-			from .CarrierAggregation_.Mcarrier import Mcarrier
-			self._mcarrier = Mcarrier(self._core, self._base)
+			from .Mcarrier import McarrierCls
+			self._mcarrier = McarrierCls(self._core, self._cmd_group)
 		return self._mcarrier
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_frequency'):
-			from .CarrierAggregation_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .CarrierAggregation_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
 	def scc(self):
 		"""scc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_scc'):
-			from .CarrierAggregation_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def maping(self):
 		"""maping commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maping'):
-			from .CarrierAggregation_.Maping import Maping
-			self._maping = Maping(self._core, self._base)
+			from .Maping import MapingCls
+			self._maping = MapingCls(self._core, self._cmd_group)
 		return self._maping
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/ChannelBw.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
 
 	def get_aggregated(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:CBANdwidth:AGGRegated \n
 		Snippet: value: float = driver.configure.carrierAggregation.channelBw.get_aggregated() \n
 		Queries the width of the aggregated channel bandwidth. \n
-			:return: ch_bandwidth: Unit: Hz
+			:return: ch_bandwidth: float Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:CBANdwidth:AGGRegated?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	@property
 	def aggregated(self):
 		"""aggregated commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_aggregated'):
-			from .Frequency_.Aggregated import Aggregated
-			self._aggregated = Aggregated(self._core, self._base)
+			from .Aggregated import AggregatedCls
+			self._aggregated = AggregatedCls(self._core, self._cmd_group)
 		return self._aggregated
 
-	def clone(self) -> 'Frequency':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FrequencyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Frequency(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FrequencyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/Aggregated.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/Aggregated.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,39 +1,39 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aggregated:
-	"""Aggregated commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AggregatedCls:
+	"""Aggregated commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aggregated", core, parent)
+		self._cmd_group = CommandsGroup("aggregated", core, parent)
 
 	def get_low(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:LOW \n
 		Snippet: value: float = driver.configure.carrierAggregation.frequency.aggregated.get_low() \n
 		Queries the lower edge of the aggregated bandwidth. \n
-			:return: frequency_low: Range: 60 MHz to 6010 MHz, Unit: Hz
+			:return: frequency_low: float Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:LOW?')
 		return Conversions.str_to_float(response)
 
 	def get_center(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:CENTer \n
 		Snippet: value: float = driver.configure.carrierAggregation.frequency.aggregated.get_center() \n
 		Queries the center frequency of the aggregated bandwidth. \n
-			:return: frequency_center: Range: 60 MHz to 6010 MHz, Unit: Hz
+			:return: frequency_center: float Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:CENTer?')
 		return Conversions.str_to_float(response)
 
 	def get_high(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:HIGH \n
 		Snippet: value: float = driver.configure.carrierAggregation.frequency.aggregated.get_high() \n
 		Queries the upper edge of the aggregated bandwidth. \n
-			:return: frequency_high: Range: 60 MHz to 6010 MHz, Unit: Hz
+			:return: frequency_high: float Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:HIGH?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Utilities import trim_str_response
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Utilities import trim_str_response
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maping:
-	"""Maping commands group definition. 3 total commands, 1 Sub-groups, 2 group commands"""
+class MapingCls:
+	"""Maping commands group definition. 3 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maping", core, parent)
+		self._cmd_group = CommandsGroup("maping", core, parent)
 
 	@property
 	def scc(self):
 		"""scc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scc'):
-			from .Maping_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	def get_pcc(self) -> str:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:PCC \n
 		Snippet: value: str = driver.configure.carrierAggregation.maping.get_pcc() \n
 		This command is only relevant for combined signal path measurements with contiguous uplink CA. It queries to which CC the
 		PCC is mapped. The measurement identifies the aggregated carriers as CC1 to CC4. The signaling application uses PCC and
 		SCC<n>. \n
-			:return: cc: String indicating the CC, examples: 'CC1', 'CC2', 'INV' 'INV' means that the PCC is not contained in the measured set of aggregated uplink carriers.
+			:return: cc: string Examples: 'CC1', 'CC2', 'INV' 'INV' means that the PCC is not contained in the measured set of aggregated uplink carriers.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:PCC?')
 		return trim_str_response(response)
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
+	class ValueStruct(StructBase):  # From ReadStructDefinition CmdPropertyTemplate.xml
 		"""Structure for reading output parameters. Fields: \n
 			- Cc_1: enums.CarrAggrMaping: INV | PCC | SCC1 | SCC2 | SCC3 | SCC4 | SCC5 | SCC6 | SCC7 Carrier mapped to CC1
 			- Cc_2: enums.CarrAggrMaping: INV | PCC | SCC1 | SCC2 | SCC3 | SCC4 | SCC5 | SCC6 | SCC7 Carrier mapped to CC2
 			- Cc_3: enums.CarrAggrMaping: INV | PCC | SCC1 | SCC2 | SCC3 | SCC4 | SCC5 | SCC6 | SCC7 Carrier mapped to CC3
 			- Cc_4: enums.CarrAggrMaping: INV | PCC | SCC1 | SCC2 | SCC3 | SCC4 | SCC5 | SCC6 | SCC7 Carrier mapped to CC4"""
 		__meta_args_list = [
 			ArgStruct.scalar_enum('Cc_1', enums.CarrAggrMaping),
@@ -49,25 +49,24 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Cc_1: enums.CarrAggrMaping = None
 			self.Cc_2: enums.CarrAggrMaping = None
 			self.Cc_3: enums.CarrAggrMaping = None
 			self.Cc_4: enums.CarrAggrMaping = None
 
-	# noinspection PyTypeChecker
 	def get_value(self) -> ValueStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing \n
 		Snippet: value: ValueStruct = driver.configure.carrierAggregation.maping.get_value() \n
 		This command is only relevant for combined signal path measurements with contiguous uplink CA. It queries which carriers
 		are mapped to CC1 to CC4. The measurement identifies the aggregated carriers as CC1 to CC4. The signaling application
 		uses PCC and SCC<n>. A returned INV means that no carrier is mapped to the CC. \n
 			:return: structure: for return value, see the help for ValueStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing?', self.__class__.ValueStruct())
 
-	def clone(self) -> 'Maping':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MapingCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maping(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MapingCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/Scc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/Scc.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,46 +2,46 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Utilities import trim_str_response
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> str:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:SCC<Carrier> \n
 		Snippet: value: str = driver.configure.carrierAggregation.maping.scc.get(secondaryCC = repcap.SecondaryCC.Default) \n
 		This command is only relevant for combined signal path measurements with contiguous uplink CA. It queries to which CC the
 		SCC<n> is mapped. The measurement identifies the aggregated carriers as CC1 to CC4. The signaling application uses PCC
 		and SCC<n>. \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: cc: String indicating the CC, examples: 'CC1', 'CC2', 'INV' 'INV' means that the SCCn is not contained in the measured set of aggregated uplink carriers."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+			:return: cc: string Examples: 'CC1', 'CC2', 'INV' 'INV' means that the SCCn is not contained in the measured set of aggregated uplink carriers."""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:SCC{secondaryCC_cmd_val}?')
 		return trim_str_response(response)
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Mcarrier.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Mcarrier.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mcarrier:
-	"""Mcarrier commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class McarrierCls:
+	"""Mcarrier commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mcarrier", core, parent)
+		self._cmd_group = CommandsGroup("mcarrier", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_enhanced(self) -> enums.MeasCarrierEnhanced:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier:ENHanced \n
 		Snippet: value: enums.MeasCarrierEnhanced = driver.configure.carrierAggregation.mcarrier.get_enhanced() \n
 		Selects a component carrier for single-carrier measurements. \n
 			:return: meas_carrier: CC1 | CC2 | CC3 | CC4
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Mode.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Mode.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mode:
-	"""Mode commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ModeCls:
+	"""Mode commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mode", core, parent)
+		self._cmd_group = CommandsGroup("mode", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_combined_signal_path(self) -> enums.CarrAggrMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE:CSPath \n
 		Snippet: value: enums.CarrAggrMode = driver.configure.carrierAggregation.mode.get_combined_signal_path() \n
 		Queries the carrier aggregation mode in the CSP scenario. The mode is configured indirectly via method RsCmwLteMeas.Route.
 		Scenario.CombinedSignalPath.set. \n
@@ -24,22 +24,22 @@
 		return Conversions.str_to_scalar_enum(response, enums.CarrAggrMode)
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.CarrAggrMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE \n
 		Snippet: value: enums.CarrAggrMode = driver.configure.carrierAggregation.mode.get_value() \n
 		Selects how many component carriers with intra-band contiguous aggregation are measured. For the combined signal path
-		scenario, usemethod RsCmwLteMeas.Route.Scenario.CombinedSignalPath.set. \n
+		scenario, use method RsCmwLteMeas.Route.Scenario.CombinedSignalPath.set. \n
 			:return: ca_mode: OFF | INTRaband | ICD | ICE OFF: only one carrier is measured INTRaband: two carriers (BW class B & C) ICD: three carriers (BW class D) ICE: four carriers (BW class E)
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE?')
 		return Conversions.str_to_scalar_enum(response, enums.CarrAggrMode)
 
 	def set_value(self, ca_mode: enums.CarrAggrMode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE \n
 		Snippet: driver.configure.carrierAggregation.mode.set_value(ca_mode = enums.CarrAggrMode.ICD) \n
 		Selects how many component carriers with intra-band contiguous aggregation are measured. For the combined signal path
-		scenario, usemethod RsCmwLteMeas.Route.Scenario.CombinedSignalPath.set. \n
+		scenario, use method RsCmwLteMeas.Route.Scenario.CombinedSignalPath.set. \n
 			:param ca_mode: OFF | INTRaband | ICD | ICE OFF: only one carrier is measured INTRaband: two carriers (BW class B & C) ICD: three carriers (BW class D) ICE: four carriers (BW class E)
 		"""
 		param = Conversions.enum_scalar_to_str(ca_mode, enums.CarrAggrMode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def acSpacing(self):
 		"""acSpacing commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_acSpacing'):
-			from .Scc_.AcSpacing import AcSpacing
-			self._acSpacing = AcSpacing(self._core, self._base)
+			from .AcSpacing import AcSpacingCls
+			self._acSpacing = AcSpacingCls(self._core, self._cmd_group)
 		return self._acSpacing
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/AcSpacing.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/AcSpacing.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,31 +1,33 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AcSpacing:
-	"""AcSpacing commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AcSpacingCls:
+	"""AcSpacing commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("acSpacing", core, parent)
+		self._cmd_group = CommandsGroup("acSpacing", core, parent)
 
 	def set(self, secondaryCC=repcap.SecondaryCC.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation[:SCC<Nr>]:ACSPacing \n
 		Snippet: driver.configure.carrierAggregation.scc.acSpacing.set(secondaryCC = repcap.SecondaryCC.Default) \n
 		Adjusts the component carrier frequencies, so that the carriers are aggregated contiguously. For the combined signal path
-		scenario, useCONFigure:LTE:SIGN<i>:CAGGregation:SET. \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		scenario, use CONFigure:LTE:SIGN<i>:CAGGregation:SET. \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:SCC{secondaryCC_cmd_val}:ACSPacing')
 
-	def set_with_opc(self, secondaryCC=repcap.SecondaryCC.Default) -> None:
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+	def set_with_opc(self, secondaryCC=repcap.SecondaryCC.Default, opc_timeout_ms: int = -1) -> None:
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation[:SCC<Nr>]:ACSPacing \n
 		Snippet: driver.configure.carrierAggregation.scc.acSpacing.set_with_opc(secondaryCC = repcap.SecondaryCC.Default) \n
 		Adjusts the component carrier frequencies, so that the carriers are aggregated contiguously. For the combined signal path
-		scenario, useCONFigure:LTE:SIGN<i>:CAGGregation:SET. \n
+		scenario, use CONFigure:LTE:SIGN<i>:CAGGregation:SET. \n
 		Same as set, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
-		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:SCC{secondaryCC_cmd_val}:ACSPacing')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:SCC{secondaryCC_cmd_val}:ACSPacing', opc_timeout_ms)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Cc/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.RepeatedCapability import RepeatedCapability
-from ... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.RepeatedCapability import RepeatedCapability
+from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Cc_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Cc_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Cc/ChannelBw.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,40 +2,41 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
 
 	def set(self, channel_bw: enums.ChannelBandwidth, carrierComponent=repcap.CarrierComponent.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CC<Nr>:CBANdwidth \n
 		Snippet: driver.configure.cc.channelBw.set(channel_bw = enums.ChannelBandwidth.B014, carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the channel bandwidth of component carrier CC<no>. Without carrier aggregation, you can omit <no>.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:CELL:DL
+			- CONFigure:LTE:SIGN<i>:CELL:BANDwidth[:PCC]:DL
 			- CONFigure:LTE:SIGN<i>:CELL:BANDwidth:SCC<c>:DL \n
 			:param channel_bw: B014 | B030 | B050 | B100 | B150 | B200 B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
 		param = Conversions.enum_scalar_to_str(channel_bw, enums.ChannelBandwidth)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CC{carrierComponent_cmd_val}:CBANdwidth {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, carrierComponent=repcap.CarrierComponent.Default) -> enums.ChannelBandwidth:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CC<Nr>:CBANdwidth \n
 		Snippet: value: enums.ChannelBandwidth = driver.configure.cc.channelBw.get(carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the channel bandwidth of component carrier CC<no>. Without carrier aggregation, you can omit <no>.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:CELL:DL
+			- CONFigure:LTE:SIGN<i>:CELL:BANDwidth[:PCC]:DL
 			- CONFigure:LTE:SIGN<i>:CELL:BANDwidth:SCC<c>:DL \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: channel_bw: B014 | B030 | B050 | B100 | B150 | B200 B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:CC{carrierComponent_cmd_val}:CBANdwidth?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelBandwidth)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Emtc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Emtc.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,48 +1,68 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Emtc:
-	"""Emtc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EmtcCls:
+	"""Emtc commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("emtc", core, parent)
+		self._cmd_group = CommandsGroup("emtc", core, parent)
 
 	def get_enable(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle \n
 		Snippet: value: bool = driver.configure.emtc.get_enable() \n
-		Enables or disables eMTC. For the combined signal path scenario, useCONFigure:LTE:EMTC:ENABle. \n
+		Enables or disables eMTC. For the combined signal path scenario, use CONFigure:LTE:SIGN<i>[:PCC]:EMTC:ENABle. \n
 			:return: enable: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle?')
 		return Conversions.str_to_bool(response)
 
 	def set_enable(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle \n
 		Snippet: driver.configure.emtc.set_enable(enable = False) \n
-		Enables or disables eMTC. For the combined signal path scenario, useCONFigure:LTE:EMTC:ENABle. \n
+		Enables or disables eMTC. For the combined signal path scenario, use CONFigure:LTE:SIGN<i>[:PCC]:EMTC:ENABle. \n
 			:param enable: OFF | ON
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle {param}')
 
+	def get_mb(self) -> bool:
+		"""SCPI: CONFigure:LTE:MEASurement<instance>:EMTC:MB<number> \n
+		Snippet: value: bool = driver.configure.emtc.get_mb() \n
+		Selects the maximum eMTC bandwidth.
+		For the combined signal path scenario, use CONFigure:LTE:SIGN<i>[:PCC]:EMTC:MB<number>. \n
+			:return: enable: OFF | ON OFF: Max bandwidth 1.4 MHz ON: Max bandwidth 5 MHz
+		"""
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:EMTC:MB5?')
+		return Conversions.str_to_bool(response)
+
+	def set_mb(self, enable: bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<instance>:EMTC:MB<number> \n
+		Snippet: driver.configure.emtc.set_mb(enable = False) \n
+		Selects the maximum eMTC bandwidth.
+		For the combined signal path scenario, use CONFigure:LTE:SIGN<i>[:PCC]:EMTC:MB<number>. \n
+			:param enable: OFF | ON OFF: Max bandwidth 1.4 MHz ON: Max bandwidth 5 MHz
+		"""
+		param = Conversions.bool_to_str(enable)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:EMTC:MB5 {param}')
+
 	def get_nband(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd \n
 		Snippet: value: int = driver.configure.emtc.get_nband() \n
 		Selects the narrowband used for eMTC. \n
-			:return: number: The maximum depends on the channel BW, see 'eMTC narrowbands'. Range: 0 to 15
+			:return: number: numeric The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'. Range: 0 to 15
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd?')
 		return Conversions.str_to_int(response)
 
 	def set_nband(self, number: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd \n
 		Snippet: driver.configure.emtc.set_nband(number = 1) \n
 		Selects the narrowband used for eMTC. \n
-			:param number: The maximum depends on the channel BW, see 'eMTC narrowbands'. Range: 0 to 15
+			:param number: numeric The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'. Range: 0 to 15
 		"""
 		param = Conversions.decimal_value_to_str(number)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,171 +1,175 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 133 total commands, 15 Sub-groups, 19 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 138 total commands, 16 Subgroups, 18 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def listPy(self):
-		"""listPy commands group. 2 Sub-classes, 3 commands."""
+		"""listPy commands group. 3 Sub-classes, 5 commands."""
 		if not hasattr(self, '_listPy'):
-			from .MultiEval_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
 	@property
 	def tmode(self):
 		"""tmode commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_tmode'):
-			from .MultiEval_.Tmode import Tmode
-			self._tmode = Tmode(self._core, self._base)
+			from .Tmode import TmodeCls
+			self._tmode = TmodeCls(self._core, self._cmd_group)
 		return self._tmode
 
 	@property
 	def pcc(self):
 		"""pcc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pcc'):
-			from .MultiEval_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
 	@property
 	def cc(self):
 		"""cc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cc'):
-			from .MultiEval_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def nsValue(self):
 		"""nsValue commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nsValue'):
-			from .MultiEval_.NsValue import NsValue
-			self._nsValue = NsValue(self._core, self._base)
+			from .NsValue import NsValueCls
+			self._nsValue = NsValueCls(self._core, self._cmd_group)
 		return self._nsValue
 
 	@property
 	def srs(self):
 		"""srs commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_srs'):
-			from .MultiEval_.Srs import Srs
-			self._srs = Srs(self._core, self._base)
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
 		return self._srs
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 3 Sub-classes, 3 commands."""
 		if not hasattr(self, '_modulation'):
-			from .MultiEval_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def spectrum(self):
 		"""spectrum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_spectrum'):
-			from .MultiEval_.Spectrum import Spectrum
-			self._spectrum = Spectrum(self._core, self._base)
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
 		return self._spectrum
 
 	@property
 	def rbAllocation(self):
 		"""rbAllocation commands group. 3 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbAllocation'):
-			from .MultiEval_.RbAllocation import RbAllocation
-			self._rbAllocation = RbAllocation(self._core, self._base)
+			from .RbAllocation import RbAllocationCls
+			self._rbAllocation = RbAllocationCls(self._core, self._cmd_group)
 		return self._rbAllocation
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_power'):
-			from .MultiEval_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .MultiEval_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
 	@property
+	def msubFrames(self):
+		"""msubFrames commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_msubFrames'):
+			from .MsubFrames import MsubFramesCls
+			self._msubFrames = MsubFramesCls(self._core, self._cmd_group)
+		return self._msubFrames
+
+	@property
 	def scount(self):
 		"""scount commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_scount'):
-			from .MultiEval_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
 		return self._scount
 
 	@property
 	def result(self):
 		"""result commands group. 1 Sub-classes, 14 commands."""
 		if not hasattr(self, '_result'):
-			from .MultiEval_.Result import Result
-			self._result = Result(self._core, self._base)
+			from .Result import ResultCls
+			self._result = ResultCls(self._core, self._cmd_group)
 		return self._result
 
 	@property
 	def limit(self):
 		"""limit commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .MultiEval_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	@property
 	def bler(self):
-		"""bler commands group. 0 Sub-classes, 1 commands."""
+		"""bler commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_bler'):
-			from .MultiEval_.Bler import Bler
-			self._bler = Bler(self._core, self._base)
+			from .Bler import BlerCls
+			self._bler = BlerCls(self._core, self._cmd_group)
 		return self._bler
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT \n
 		Snippet: value: float = driver.configure.multiEval.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, timeout: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT \n
 		Snippet: driver.configure.multiEval.set_timeout(timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(timeout)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_mmode(self) -> enums.MeasurementMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MMODe \n
@@ -210,123 +214,123 @@
 
 	# noinspection PyTypeChecker
 	def get_scondition(self) -> enums.StopCondition:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition \n
 		Snippet: value: enums.StopCondition = driver.configure.multiEval.get_scondition() \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition?')
 		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
 
 	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition \n
 		Snippet: driver.configure.multiEval.set_scondition(stop_condition = enums.StopCondition.NONE) \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition {param}')
 
 	def get_ul_dl(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL \n
 		Snippet: value: int = driver.configure.multiEval.get_ul_dl() \n
 		Selects an UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame.
 		This parameter is only relevant for frame structure 'Type 2' (method RsCmwLteMeas.Configure.fstructure) .
 		The UL-DL configurations are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:ULDL
+			- CONFigure:LTE:SIGN<i>:CELL[:PCC]:ULDL
 			- CONFigure:LTE:SIGN<i>:CELL:SCC<c>:ULDL
 			- CONFigure:LTE:SIGN<i>:CELL:TDD:SPECific \n
-			:return: uplink_downlink: Range: 0 to 6
+			:return: uplink_downlink: integer Range: 0 to 6
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL?')
 		return Conversions.str_to_int(response)
 
 	def set_ul_dl(self, uplink_downlink: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL \n
 		Snippet: driver.configure.multiEval.set_ul_dl(uplink_downlink = 1) \n
 		Selects an UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame.
 		This parameter is only relevant for frame structure 'Type 2' (method RsCmwLteMeas.Configure.fstructure) .
 		The UL-DL configurations are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:ULDL
+			- CONFigure:LTE:SIGN<i>:CELL[:PCC]:ULDL
 			- CONFigure:LTE:SIGN<i>:CELL:SCC<c>:ULDL
 			- CONFigure:LTE:SIGN<i>:CELL:TDD:SPECific \n
-			:param uplink_downlink: Range: 0 to 6
+			:param uplink_downlink: integer Range: 0 to 6
 		"""
 		param = Conversions.decimal_value_to_str(uplink_downlink)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL {param}')
 
 	def get_ssubframe(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe \n
 		Snippet: value: int = driver.configure.multiEval.get_ssubframe() \n
 		Selects a special subframe configuration, defining the inner structure of special subframes. This parameter is only
 		relevant for frame structure 'Type 2' (method RsCmwLteMeas.Configure.fstructure) . The special subframe configurations
 		are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:SSUBframe
+			- CONFigure:LTE:SIGN<i>:CELL[:PCC]:SSUBframe
 			- CONFigure:LTE:SIGN<i>:CELL:SCC<c>:SSUBframe
 			- CONFigure:LTE:SIGN<i>:CELL:TDD:SPECific \n
-			:return: special_subframe: Range: 0 to 8
+			:return: special_subframe: integer Range: 0 to 8
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe?')
 		return Conversions.str_to_int(response)
 
 	def set_ssubframe(self, special_subframe: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe \n
 		Snippet: driver.configure.multiEval.set_ssubframe(special_subframe = 1) \n
 		Selects a special subframe configuration, defining the inner structure of special subframes. This parameter is only
 		relevant for frame structure 'Type 2' (method RsCmwLteMeas.Configure.fstructure) . The special subframe configurations
 		are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:SSUBframe
+			- CONFigure:LTE:SIGN<i>:CELL[:PCC]:SSUBframe
 			- CONFigure:LTE:SIGN<i>:CELL:SCC<c>:SSUBframe
 			- CONFigure:LTE:SIGN<i>:CELL:TDD:SPECific \n
-			:param special_subframe: Range: 0 to 8
+			:param special_subframe: integer Range: 0 to 8
 		"""
 		param = Conversions.decimal_value_to_str(special_subframe)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception \n
 		Snippet: value: bool = driver.configure.multiEval.get_mo_exception() \n
-		Specifies whether measurement results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
-			:return: meas_on_exception: OFF | ON OFF: Faulty results are rejected ON: Results are never rejected
+		Specifies whether measurement results identified as faulty or inaccurate are rejected. \n
+			:return: meas_on_exception: OFF | ON OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception?')
 		return Conversions.str_to_bool(response)
 
 	def set_mo_exception(self, meas_on_exception: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception \n
 		Snippet: driver.configure.multiEval.set_mo_exception(meas_on_exception = False) \n
-		Specifies whether measurement results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
-			:param meas_on_exception: OFF | ON OFF: Faulty results are rejected ON: Results are never rejected
+		Specifies whether measurement results identified as faulty or inaccurate are rejected. \n
+			:param meas_on_exception: OFF | ON OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		param = Conversions.bool_to_str(meas_on_exception)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception {param}')
 
 	# noinspection PyTypeChecker
 	def get_cprefix(self) -> enums.CyclicPrefix:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix \n
 		Snippet: value: enums.CyclicPrefix = driver.configure.multiEval.get_cprefix() \n
 		Selects the type of cyclic prefix of the LTE signal. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CELL:CPRefix. \n
+		use CONFigure:LTE:SIGN<i>:CELL:CPRefix. \n
 			:return: cyclic_prefix: NORMal | EXTended
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix?')
 		return Conversions.str_to_scalar_enum(response, enums.CyclicPrefix)
 
 	def set_cprefix(self, cyclic_prefix: enums.CyclicPrefix) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix \n
 		Snippet: driver.configure.multiEval.set_cprefix(cyclic_prefix = enums.CyclicPrefix.EXTended) \n
 		Selects the type of cyclic prefix of the LTE signal. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CELL:CPRefix. \n
+		use CONFigure:LTE:SIGN<i>:CELL:CPRefix. \n
 			:param cyclic_prefix: NORMal | EXTended
 		"""
 		param = Conversions.enum_scalar_to_str(cyclic_prefix, enums.CyclicPrefix)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix {param}')
 
 	# noinspection PyTypeChecker
 	def get_ctype(self) -> enums.ChannelTypeDetection:
@@ -355,15 +359,15 @@
 			:return: channel_type: PSSCh | PSCCh
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe?')
 		return Conversions.str_to_scalar_enum(response, enums.SidelinkChannelType)
 
 	def set_sch_type(self, channel_type: enums.SidelinkChannelType) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe \n
-		Snippet: driver.configure.multiEval.set_sch_type(channel_type = enums.SidelinkChannelType.PSCCh) \n
+		Snippet: driver.configure.multiEval.set_sch_type(channel_type = enums.SidelinkChannelType.PSBCh) \n
 		Configures the channel type for modulation results of sidelink measurements. \n
 			:param channel_type: PSSCh | PSCCh
 		"""
 		param = Conversions.enum_scalar_to_str(channel_type, enums.SidelinkChannelType)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe {param}')
 
 	def get_peak_search(self) -> bool:
@@ -404,146 +408,113 @@
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PFORmat {param}')
 
 	def get_nvfilter(self) -> int or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter \n
 		Snippet: value: int or bool = driver.configure.multiEval.get_nvfilter() \n
 		Specifies, enables or disables the number of resource blocks (NRB) view filter. If the filter is active, only slots with
 		a matching number of allocated resource blocks are measured. Within the indicated input range, only specific numbers are
-		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in Time and Frequency Domain'. \n
-			:return: nrb_view_filter: Number of allocated resource blocks Range: 1 to 100 Additional parameters: OFF | ON (disables | enables the filter)
+		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in time and frequency domain'. \n
+			:return: nrb_view_filter: (integer or boolean) numeric | ON | OFF Number of allocated resource blocks Range: 1 to 100 ON | OFF enables or disables the filter.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter?')
 		return Conversions.str_to_int_or_bool(response)
 
 	def set_nvfilter(self, nrb_view_filter: int or bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter \n
 		Snippet: driver.configure.multiEval.set_nvfilter(nrb_view_filter = 1) \n
 		Specifies, enables or disables the number of resource blocks (NRB) view filter. If the filter is active, only slots with
 		a matching number of allocated resource blocks are measured. Within the indicated input range, only specific numbers are
-		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in Time and Frequency Domain'. \n
-			:param nrb_view_filter: Number of allocated resource blocks Range: 1 to 100 Additional parameters: OFF | ON (disables | enables the filter)
+		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in time and frequency domain'. \n
+			:param nrb_view_filter: (integer or boolean) numeric | ON | OFF Number of allocated resource blocks Range: 1 to 100 ON | OFF enables or disables the filter.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(nrb_view_filter)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter {param}')
 
 	def get_orv_filter(self) -> int or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter \n
 		Snippet: value: int or bool = driver.configure.multiEval.get_orv_filter() \n
 		Specifies, enables or disables the RB offset view filter. If the filter is active, only slots with a matching number of
 		RB offset are measured. The indicated input range applies to a 20-MHz channel bandwidth. The maximum value depends on the
 		bandwidth (maximum number of RBs minus one) . \n
-			:return: offset_rb: Offset of the first allocated RB Range: 0 to 99 Additional parameters: OFF | ON (disables | enables the filter)
+			:return: offset_rb: (integer or boolean) numeric | ON | OFF Offset of the first allocated RB Range: 0 to 99 ON | OFF enables or disables the filter.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter?')
 		return Conversions.str_to_int_or_bool(response)
 
 	def set_orv_filter(self, offset_rb: int or bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter \n
 		Snippet: driver.configure.multiEval.set_orv_filter(offset_rb = 1) \n
 		Specifies, enables or disables the RB offset view filter. If the filter is active, only slots with a matching number of
 		RB offset are measured. The indicated input range applies to a 20-MHz channel bandwidth. The maximum value depends on the
 		bandwidth (maximum number of RBs minus one) . \n
-			:param offset_rb: Offset of the first allocated RB Range: 0 to 99 Additional parameters: OFF | ON (disables | enables the filter)
+			:param offset_rb: (integer or boolean) numeric | ON | OFF Offset of the first allocated RB Range: 0 to 99 ON | OFF enables or disables the filter.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter {param}')
 
 	# noinspection PyTypeChecker
 	def get_ctv_filter(self) -> enums.ChannelTypeVewFilter:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter \n
 		Snippet: value: enums.ChannelTypeVewFilter = driver.configure.multiEval.get_ctv_filter() \n
 		Specifies, enables or disables the channel type view filter. If the filter is active, only slots with detected channel
 		type PUSCH or PUCCH are measured. \n
-			:return: channel_type: PUSCh | PUCCh | ON | OFF PUSCh: measure only physical uplink shared channel PUCCh: measure only physical uplink control channel ON: enable the filter OFF: disable the filter
+			:return: channel_type: PUSCh | PUCCh | ON | OFF PUSCh: measure only PUSCH PUCCh: measure only PUCCH ON: enable the filter OFF: disable the filter
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelTypeVewFilter)
 
 	def set_ctv_filter(self, channel_type: enums.ChannelTypeVewFilter) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter \n
 		Snippet: driver.configure.multiEval.set_ctv_filter(channel_type = enums.ChannelTypeVewFilter.OFF) \n
 		Specifies, enables or disables the channel type view filter. If the filter is active, only slots with detected channel
 		type PUSCH or PUCCH are measured. \n
-			:param channel_type: PUSCh | PUCCh | ON | OFF PUSCh: measure only physical uplink shared channel PUCCh: measure only physical uplink control channel ON: enable the filter OFF: disable the filter
+			:param channel_type: PUSCh | PUCCh | ON | OFF PUSCh: measure only PUSCH PUCCh: measure only PUCCH ON: enable the filter OFF: disable the filter
 		"""
 		param = Conversions.enum_scalar_to_str(channel_type, enums.ChannelTypeVewFilter)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter {param}')
 
 	def get_dss_pusch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch \n
 		Snippet: value: int = driver.configure.multiEval.get_dss_pusch() \n
 		Specifies the delta sequence shift value (Δss) used to calculate the sequence shift pattern for PUSCH. \n
-			:return: delta_seq_sh_pusch: Range: 0 to 29
+			:return: delta_seq_sh_pusch: integer Range: 0 to 29
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch?')
 		return Conversions.str_to_int(response)
 
 	def set_dss_pusch(self, delta_seq_sh_pusch: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch \n
 		Snippet: driver.configure.multiEval.set_dss_pusch(delta_seq_sh_pusch = 1) \n
 		Specifies the delta sequence shift value (Δss) used to calculate the sequence shift pattern for PUSCH. \n
-			:param delta_seq_sh_pusch: Range: 0 to 29
+			:param delta_seq_sh_pusch: integer Range: 0 to 29
 		"""
 		param = Conversions.decimal_value_to_str(delta_seq_sh_pusch)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch {param}')
 
 	def get_ghopping(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping \n
 		Snippet: value: bool = driver.configure.multiEval.get_ghopping() \n
 		Specifies whether group hopping is used or not. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CONNection:GHOPping. \n
+		use CONFigure:LTE:SIGN<i>:CONNection:GHOPping. \n
 			:return: value: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping?')
 		return Conversions.str_to_bool(response)
 
 	def set_ghopping(self, value: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping \n
 		Snippet: driver.configure.multiEval.set_ghopping(value = False) \n
 		Specifies whether group hopping is used or not. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CONNection:GHOPping. \n
+		use CONFigure:LTE:SIGN<i>:CONNection:GHOPping. \n
 			:param value: OFF | ON
 		"""
 		param = Conversions.bool_to_str(value)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping {param}')
 
 	# noinspection PyTypeChecker
-	class MsubFramesStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Sub_Frame_Offset: int: Start of the measured subframe range relative to the trigger event Range: 0 to 9
-			- Sub_Frame_Count: int: Length of the measured subframe range Range: 1 to 320
-			- Meas_Subframe: int: Subframe containing the measured slots for modulation and spectrum results Range: 0 to SubframeCount-1"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Sub_Frame_Offset'),
-			ArgStruct.scalar_int('Sub_Frame_Count'),
-			ArgStruct.scalar_int('Meas_Subframe')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Sub_Frame_Offset: int = None
-			self.Sub_Frame_Count: int = None
-			self.Meas_Subframe: int = None
-
-	def get_msub_frames(self) -> MsubFramesStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes \n
-		Snippet: value: MsubFramesStruct = driver.configure.multiEval.get_msub_frames() \n
-		Configures the scope of the measurement, i.e. which subframes are measured. \n
-			:return: structure: for return value, see the help for MsubFramesStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes?', self.__class__.MsubFramesStruct())
-
-	def set_msub_frames(self, value: MsubFramesStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes \n
-		Snippet: driver.configure.multiEval.set_msub_frames(value = MsubFramesStruct()) \n
-		Configures the scope of the measurement, i.e. which subframes are measured. \n
-			:param value: see the help for MsubFramesStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes', value)
-
-	# noinspection PyTypeChecker
 	def get_mslot(self) -> enums.MeasureSlot:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot \n
 		Snippet: value: enums.MeasureSlot = driver.configure.multiEval.get_mslot() \n
 		Selects which slots of the 'Measure Subframe' are measured. \n
 			:return: measure_slot: MS0 | MS1 | ALL MS0: slot number 0 only MS1: slot number 1 only ALL: both slots
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot?')
@@ -554,14 +525,14 @@
 		Snippet: driver.configure.multiEval.set_mslot(measure_slot = enums.MeasureSlot.ALL) \n
 		Selects which slots of the 'Measure Subframe' are measured. \n
 			:param measure_slot: MS0 | MS1 | ALL MS0: slot number 0 only MS1: slot number 1 only ALL: both slots
 		"""
 		param = Conversions.enum_scalar_to_str(measure_slot, enums.MeasureSlot)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot {param}')
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Bler.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/Sframes.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,45 +1,49 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from .....Internal.ArgSingleList import ArgSingleList
+from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bler:
-	"""Bler commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SframesCls:
+	"""Sframes commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bler", core, parent)
+		self._cmd_group = CommandsGroup("sframes", core, parent)
+
+	def set(self, sub_frames: int, sched_subfr_per_fr: int = None) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames \n
+		Snippet: driver.configure.multiEval.bler.sframes.set(sub_frames = 1, sched_subfr_per_fr = 1) \n
+		Specifies the statistic count (number of measured subframes) and the number of scheduled subframes per radio frame for
+		the BLER measurement. BLER is a single shot measurement. \n
+			:param sub_frames: integer Number of subframes to be measured Range: 1 subframe to 200E+3 subframes
+			:param sched_subfr_per_fr: integer Number of scheduled subframes per radio frame in the generated downlink signal Range: 1 subframe to 10 subframes
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('sub_frames', sub_frames, DataType.Integer), ArgSingle('sched_subfr_per_fr', sched_subfr_per_fr, DataType.Integer, None, is_optional=True))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class SframesStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Sub_Frames: int: Number of subframes to be measured Range: 1 subframe to 200E+3 subframes
-			- Sched_Subfr_Per_Fr: int: Number of scheduled subframes per radio frame in the generated downlink signal Range: 1 subframe to 10 subframes"""
+		"""Response structure. Fields: \n
+			- Sub_Frames: int: integer Number of subframes to be measured Range: 1 subframe to 200E+3 subframes
+			- Sched_Subfr_Per_Fr: int: integer Number of scheduled subframes per radio frame in the generated downlink signal Range: 1 subframe to 10 subframes"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Sub_Frames'),
 			ArgStruct.scalar_int('Sched_Subfr_Per_Fr')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Sub_Frames: int = None
 			self.Sched_Subfr_Per_Fr: int = None
 
-	def get_sframes(self) -> SframesStruct:
+	def get(self) -> SframesStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames \n
-		Snippet: value: SframesStruct = driver.configure.multiEval.bler.get_sframes() \n
+		Snippet: value: SframesStruct = driver.configure.multiEval.bler.sframes.get() \n
 		Specifies the statistic count (number of measured subframes) and the number of scheduled subframes per radio frame for
 		the BLER measurement. BLER is a single shot measurement. \n
-			:return: structure: for return value, see the help for SframesStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames?', self.__class__.SframesStruct())
-
-	def set_sframes(self, value: SframesStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames \n
-		Snippet: driver.configure.multiEval.bler.set_sframes(value = SframesStruct()) \n
-		Specifies the statistic count (number of measured subframes) and the number of scheduled subframes per radio frame for
-		the BLER measurement. BLER is a single shot measurement. \n
-			:param value: see the help for SframesStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames', value)
+			:return: structure: for return value, see the help for SframesStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames?', self.__class__.SframesStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def plcId(self):
 		"""plcId commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_plcId'):
-			from .Cc_.PlcId import PlcId
-			self._plcId = PlcId(self._core, self._base)
+			from .PlcId import PlcIdCls
+			self._plcId = PlcIdCls(self._core, self._cmd_group)
 		return self._plcId
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc_/PlcId.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/PlcId.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PlcId:
-	"""PlcId commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PlcIdCls:
+	"""PlcId commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plcId", core, parent)
+		self._cmd_group = CommandsGroup("plcId", core, parent)
 
 	def set(self, phs_layer_cell_id: int, carrierComponent=repcap.CarrierComponent.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CC<Nr>:PLCid \n
 		Snippet: driver.configure.multiEval.cc.plcId.set(phs_layer_cell_id = 1, carrierComponent = repcap.CarrierComponent.Default) \n
 		Specifies the physical layer cell ID of component carrier CC<no>. Without carrier aggregation, you can omit <no>.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:PCID
+			- CONFigure:LTE:SIGN<i>:CELL[:PCC]:PCID
 			- CONFigure:LTE:SIGN<i>:CELL:SCC<c>:PCID \n
-			:param phs_layer_cell_id: Range: 0 to 503
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
+			:param phs_layer_cell_id: integer Range: 0 to 503
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
 		param = Conversions.decimal_value_to_str(phs_layer_cell_id)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CC{carrierComponent_cmd_val}:PLCid {param}')
 
 	def get(self, carrierComponent=repcap.CarrierComponent.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CC<Nr>:PLCid \n
 		Snippet: value: int = driver.configure.multiEval.cc.plcId.get(carrierComponent = repcap.CarrierComponent.Default) \n
 		Specifies the physical layer cell ID of component carrier CC<no>. Without carrier aggregation, you can omit <no>.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:PCID
+			- CONFigure:LTE:SIGN<i>:CELL[:PCC]:PCID
 			- CONFigure:LTE:SIGN<i>:CELL:SCC<c>:PCID \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: phs_layer_cell_id: Range: 0 to 503"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+			:return: phs_layer_cell_id: integer Range: 0 to 503"""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CC{carrierComponent_cmd_val}:PLCid?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 40 total commands, 5 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 40 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
 	def qpsk(self):
-		"""qpsk commands group. 1 Sub-classes, 7 commands."""
+		"""qpsk commands group. 5 Sub-classes, 3 commands."""
 		if not hasattr(self, '_qpsk'):
-			from .Limit_.Qpsk import Qpsk
-			self._qpsk = Qpsk(self._core, self._base)
+			from .Qpsk import QpskCls
+			self._qpsk = QpskCls(self._core, self._cmd_group)
 		return self._qpsk
 
 	@property
 	def qam(self):
 		"""qam commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_qam'):
-			from .Limit_.Qam import Qam
-			self._qam = Qam(self._core, self._base)
+			from .Qam import QamCls
+			self._qam = QamCls(self._core, self._cmd_group)
 		return self._qam
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_seMask'):
-			from .Limit_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aclr'):
-			from .Limit_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .Limit_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 8 total commands, 2 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 8 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def utra(self):
 		"""utra commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_utra'):
-			from .Aclr_.Utra import Utra
-			self._utra = Utra(self._core, self._base)
+			from .Utra import UtraCls
+			self._utra = UtraCls(self._core, self._cmd_group)
 		return self._utra
 
 	@property
 	def eutra(self):
 		"""eutra commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_eutra'):
-			from .Aclr_.Eutra import Eutra
-			self._eutra = Eutra(self._core, self._base)
+			from .Eutra import EutraCls
+			self._eutra = EutraCls(self._core, self._cmd_group)
 		return self._eutra
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Eutra:
-	"""Eutra commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class ObwLimitCls:
+	"""ObwLimit commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eutra", core, parent)
+		self._cmd_group = CommandsGroup("obwLimit", core, parent)
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Eutra_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Eutra_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
-	def clone(self) -> 'Eutra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ObwLimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Eutra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ObwLimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/Ocombination.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,61 +1,49 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class OcombinationCls:
+	"""Ocombination commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("ocombination", core, parent)
 
-	@property
-	def channelBw1st(self):
-		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
-		return self._channelBw1st
+	def set(self, relative_level: float or bool, absolute_level: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination \n
+		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.ocombination.set(relative_level = 1.0, absolute_level = 1.0) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings apply to all
+		'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class OcombinationStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Relative_Level: float or bool: Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def get_ocombination(self) -> OcombinationStruct:
+	def get(self) -> OcombinationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination \n
-		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.get_ocombination() \n
+		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.ocombination.get() \n
 		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings apply to all
-		'other' channel bandwidth combinations, not covered by other commands in this section. \n
-			:return: structure: for return value, see the help for OcombinationStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
-
-	def set_ocombination(self, value: OcombinationStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.set_ocombination(value = OcombinationStruct()) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings apply to all
-		'other' channel bandwidth combinations, not covered by other commands in this section. \n
-			:param value: see the help for OcombinationStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination', value)
-
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
+			:return: structure: for return value, see the help for OcombinationStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
-	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw150"""
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 1 total commands, 1 Subgroups, 0 group commands
+	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw150)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
-		Default value after init: FirstChannelBw.Bw150"""
-		self._base.set_repcap_enum_value(enum_value)
+		Default value after init: FirstChannelBw.Bw100"""
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
-		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
+		"""channelBw2nd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,84 +1,90 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw3rd(self):
 		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
 		return self._channelBw3rd
 
+	def set(self, relative_level: float or bool, absolute_level: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.set(relative_level = 1.0, absolute_level = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth combination, for two aggregated carriers. The following bandwidth combinations are
+		supported: Example: For the first line in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw2ndStruct, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth combination, for two aggregated carriers. The following bandwidth combinations are
-		supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
 	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
 		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
 		separately for each channel bandwidth combination, for two aggregated carriers. The following bandwidth combinations are
-		supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth50. \n
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+		supported: Example: For the first line in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,80 +1,96 @@
 from ..........Internal.Core import Core
 from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
 from ..........Internal.StructBase import StructBase
 from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
 from ..........Internal.RepeatedCapability import RepeatedCapability
 from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
-	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
+	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
-		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
+		Default value after init: SecondChannelBw.Bw50"""
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
-	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
+	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	@property
+	def channelBw3rd(self):
+		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_channelBw3rd'):
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
+		return self._channelBw3rd
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
+		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
+		:CBANdwidth100:CBANdwidth50. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class ChannelBw3rdStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: ON | OFF Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+	class ChannelBw2ndStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw3rdStruct, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(value = [PROPERTY_STRUCT_NAME](), firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
-		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param structure: for set value, see the help for ChannelBw3rdStruct structure arguments.
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}', structure)
-
-	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
-		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
+		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
+		:CBANdwidth100:CBANdwidth50. \n
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
-			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
+			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/ChannelBw.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,70 +1,76 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 from .......Internal.RepeatedCapability import RepeatedCapability
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth<Band> \n
+		Snippet: driver.configure.multiEval.limit.aclr.eutra.channelBw.set(relative_level = 1.0, absolute_level = 1.0, channelBw = repcap.ChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBwStruct, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.channelBw.set(value = [PROPERTY_STRUCT_NAME](), channelBw = repcap.ChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth<Band> \n
 		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.aclr.eutra.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
 		separately for each channel bandwidth. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Utra:
-	"""Utra commands group definition. 4 total commands, 2 Sub-groups, 0 group commands
+class UtraCls:
+	"""Utra commands group definition. 8 total commands, 2 Subgroups, 0 group commands
 	Repeated Capability: UtraAdjChannel, default value after init: UtraAdjChannel.Ch1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("utra", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_utraAdjChannel_get', 'repcap_utraAdjChannel_set', repcap.UtraAdjChannel.Ch1)
+		self._cmd_group = CommandsGroup("utra", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_utraAdjChannel_get', 'repcap_utraAdjChannel_set', repcap.UtraAdjChannel.Ch1)
 
-	def repcap_utraAdjChannel_set(self, enum_value: repcap.UtraAdjChannel) -> None:
+	def repcap_utraAdjChannel_set(self, utraAdjChannel: repcap.UtraAdjChannel) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to UtraAdjChannel.Default
 		Default value after init: UtraAdjChannel.Ch1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(utraAdjChannel)
 
 	def repcap_utraAdjChannel_get(self) -> repcap.UtraAdjChannel:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .Utra_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def negativ(self):
+		"""negativ commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def carrierAggregation(self):
-		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_carrierAggregation'):
-			from .Utra_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
-		return self._carrierAggregation
+	def positiv(self):
+		"""positiv commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	def clone(self) -> 'Utra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UtraCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Utra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UtraCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	@property
 	def ocombination(self):
 		"""ocombination commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ocombination'):
-			from .CarrierAggregation_.Ocombination import Ocombination
-			self._ocombination = Ocombination(self._core, self._base)
+			from .Ocombination import OcombinationCls
+			self._ocombination = OcombinationCls(self._core, self._cmd_group)
 		return self._ocombination
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.RepeatedCapability import RepeatedCapability
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
-	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw150"""
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
+	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw150)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
-		Default value after init: FirstChannelBw.Bw150"""
-		self._base.set_repcap_enum_value(enum_value)
+		Default value after init: FirstChannelBw.Bw100"""
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
 		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/ChannelBw2nd.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,90 +1,105 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import enums
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	@property
-	def channelBw3rd(self):
-		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
-		return self._channelBw3rd
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
+		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
+		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
+		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param enable: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param frequency_end: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param level: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			:param rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Level: float: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Relative_Level'),
-			ArgStruct.scalar_float_ext('Absolute_Level')]
+			ArgStruct.scalar_bool('Enable'),
+			ArgStruct.scalar_float('Frequency_Start'),
+			ArgStruct.scalar_float('Frequency_End'),
+			ArgStruct.scalar_float('Level'),
+			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Relative_Level: float or bool = None
-			self.Absolute_Level: float or bool = None
-
-	def set(self, structure: ChannelBw2ndStruct, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth200:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
-	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth200:CBANdwidth50. \n
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+			self.Enable: bool = None
+			self.Frequency_Start: float = None
+			self.Frequency_End: float = None
+			self.Level: float = None
+			self.Rbw: enums.Rbw = None
+
+	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
+		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
+		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
+		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,86 +1,86 @@
 from ..........Internal.Core import Core
 from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
 from ..........Internal.StructBase import StructBase
 from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
 from ..........Internal.RepeatedCapability import RepeatedCapability
 from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
 		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
 	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(relative_level = 1.0, absolute_level = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
+		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw3rdStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: ON | OFF Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw3rdStruct, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for three aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param structure: for set value, see the help for ChannelBw3rdStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}', structure)
-
-	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for three aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
+		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
 			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/Ocombination.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/Ocombination.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,48 +1,54 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ocombination:
-	"""Ocombination commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class OcombinationCls:
+	"""Ocombination commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ocombination", core, parent)
+		self._cmd_group = CommandsGroup("ocombination", core, parent)
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:OCOMbination \n
+		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.ocombination.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:OCOMbination {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class OcombinationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: OcombinationStruct, utraAdjChannel=repcap.UtraAdjChannel.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.ocombination.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this section. \n
-			:param structure: for set value, see the help for OcombinationStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:OCOMbination', structure)
-
 	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> OcombinationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:OCOMbination \n
 		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.ocombination.get(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this section. \n
+		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: structure: for return value, see the help for OcombinationStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/ChannelBw.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,74 +1,80 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 from .......Internal.RepeatedCapability import RepeatedCapability
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CBANdwidth<Band> \n
+		Snippet: driver.configure.multiEval.limit.aclr.utra.channelBw.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth. \n
+			:param relative_level: (float or boolean) numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			:param absolute_level: (float or boolean) numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check.
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Relative_Level: float or bool: Range: -256 dB to 256 dB, Unit: dB Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Absolute_Level: float or bool: Range: -256 dBm to 256 dBm, Unit: dBm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Relative_Level: float or bool: numeric | ON | OFF Range: -256 dB to 256 dB, Unit: dB ON | OFF enables or disables the limit check.
+			- Absolute_Level: float or bool: numeric | ON | OFF Range: -256 dBm to 256 dBm, Unit: dBm ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBwStruct, utraAdjChannel=repcap.UtraAdjChannel.Default, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.channelBw.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CBANdwidth<Band> \n
 		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.aclr.utra.channelBw.get(utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
 		<no>. The settings are defined separately for each channel bandwidth. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .Pdynamics_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
+
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/ChannelBw.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,76 +1,74 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, cyc_prefix_normal: int, cyc_prefix_extend: int, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth<Band> \n
+		Snippet: driver.configure.multiEval.modulation.ewLength.channelBw.set(cyc_prefix_normal = 1, cyc_prefix_extend = 1, channelBw = repcap.ChannelBw.Default) \n
+		Specifies the EVM window length in samples for a selected channel bandwidth, depending on the cyclic prefix (CP) type. \n
+			:param cyc_prefix_normal: integer Samples for normal CP Range: see below
+			:param cyc_prefix_extend: integer Samples for extended CP Range: see below
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('cyc_prefix_normal', cyc_prefix_normal, DataType.Integer), ArgSingle('cyc_prefix_extend', cyc_prefix_extend, DataType.Integer))
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
-			- On_Power_Upper: float: Upper limit for the 'ON power' Range: -256 dBm to 256 dBm, Unit: dBm
-			- On_Power_Lower: float: Lower limit for the 'ON power' Range: -256 dBm to 256 dBm, Unit: dBm
-			- Off_Power_Upper: float: Upper limit for the 'OFF power' and the 'SRS OFF' power Range: -256 dBm to 256 dBm, Unit: dBm"""
+		"""Response structure. Fields: \n
+			- Cyc_Prefix_Normal: int: integer Samples for normal CP Range: see below
+			- Cyc_Prefix_Extend: int: integer Samples for extended CP Range: see below"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('On_Power_Upper'),
-			ArgStruct.scalar_float('On_Power_Lower'),
-			ArgStruct.scalar_float('Off_Power_Upper')]
+			ArgStruct.scalar_int('Cyc_Prefix_Normal'),
+			ArgStruct.scalar_int('Cyc_Prefix_Extend')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.On_Power_Upper: float = None
-			self.On_Power_Lower: float = None
-			self.Off_Power_Upper: float = None
-
-	def set(self, structure: ChannelBwStruct, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.pdynamics.channelBw.set(value = [PROPERTY_STRUCT_NAME](), channelBw = repcap.ChannelBw.Default) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. Separate limits can be
-		defined for each channel bandwidth. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth{channelBw_cmd_val}', structure)
+			self.Cyc_Prefix_Normal: int = None
+			self.Cyc_Prefix_Extend: int = None
 
 	def get(self, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.pdynamics.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. Separate limits can be
-		defined for each channel bandwidth. \n
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth<Band> \n
+		Snippet: value: ChannelBwStruct = driver.configure.multiEval.modulation.ewLength.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
+		Specifies the EVM window length in samples for a selected channel bandwidth, depending on the cyclic prefix (CP) type. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Qam:
-	"""Qam commands group definition. 9 total commands, 8 Sub-groups, 0 group commands
+class QamCls:
+	"""Qam commands group definition. 9 total commands, 8 Subgroups, 0 group commands
 	Repeated Capability: QAMmodOrder, default value after init: QAMmodOrder.Qam16"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("qam", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_qAMmodOrder_get', 'repcap_qAMmodOrder_set', repcap.QAMmodOrder.Qam16)
+		self._cmd_group = CommandsGroup("qam", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_qAMmodOrder_get', 'repcap_qAMmodOrder_set', repcap.QAMmodOrder.Qam16)
 
-	def repcap_qAMmodOrder_set(self, enum_value: repcap.QAMmodOrder) -> None:
+	def repcap_qAMmodOrder_set(self, qAMmodOrder: repcap.QAMmodOrder) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to QAMmodOrder.Default
 		Default value after init: QAMmodOrder.Qam16"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(qAMmodOrder)
 
 	def repcap_qAMmodOrder_get(self) -> repcap.QAMmodOrder:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def evMagnitude(self):
 		"""evMagnitude commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_evMagnitude'):
-			from .Qam_.EvMagnitude import EvMagnitude
-			self._evMagnitude = EvMagnitude(self._core, self._base)
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
 		return self._evMagnitude
 
 	@property
 	def merror(self):
 		"""merror commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_merror'):
-			from .Qam_.Merror import Merror
-			self._merror = Merror(self._core, self._base)
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
 		return self._merror
 
 	@property
 	def perror(self):
 		"""perror commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_perror'):
-			from .Qam_.Perror import Perror
-			self._perror = Perror(self._core, self._base)
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
 		return self._perror
 
 	@property
 	def freqError(self):
 		"""freqError commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_freqError'):
-			from .Qam_.FreqError import FreqError
-			self._freqError = FreqError(self._core, self._base)
+			from .FreqError import FreqErrorCls
+			self._freqError = FreqErrorCls(self._core, self._cmd_group)
 		return self._freqError
 
 	@property
 	def iqOffset(self):
 		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_iqOffset'):
-			from .Qam_.IqOffset import IqOffset
-			self._iqOffset = IqOffset(self._core, self._base)
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
 		return self._iqOffset
 
 	@property
 	def ibe(self):
 		"""ibe commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ibe'):
-			from .Qam_.Ibe import Ibe
-			self._ibe = Ibe(self._core, self._base)
+			from .Ibe import IbeCls
+			self._ibe = IbeCls(self._core, self._cmd_group)
 		return self._ibe
 
 	@property
 	def sflatness(self):
 		"""sflatness commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sflatness'):
-			from .Qam_.Sflatness import Sflatness
-			self._sflatness = Sflatness(self._core, self._base)
+			from .Sflatness import SflatnessCls
+			self._sflatness = SflatnessCls(self._core, self._cmd_group)
 		return self._sflatness
 
 	@property
 	def esFlatness(self):
 		"""esFlatness commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_esFlatness'):
-			from .Qam_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
+			from .EsFlatness import EsFlatnessCls
+			self._esFlatness = EsFlatnessCls(self._core, self._cmd_group)
 		return self._esFlatness
 
-	def clone(self) -> 'Qam':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'QamCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Qam(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QamCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EsFlatness.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/EsFlatness.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,30 +2,30 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	# noinspection PyTypeChecker
 	class EsFlatnessStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
 			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
-			- Range_1: float: Upper limit for max(range 1) - min(range 1) Range: -256 dBpp to 256 dBpp, Unit: dBpp
-			- Range_2: float: Upper limit for max(range 2) - min(range 2) Range: -256 dBpp to 256 dBpp, Unit: dBpp
-			- Max_1_Min_2: float: Upper limit for max(range 1) - min(range 2) Range: -256 dB to 256 dB, Unit: dB
-			- Max_2_Min_1: float: Upper limit for max(range 2) - min(range 1) Range: -256 dB to 256 dB, Unit: dB
-			- Edge_Frequency: float: Frequency band edge distance of border between range 1 and range 2 Range: 0 MHz to 20 MHz, Unit: Hz"""
+			- Range_1: float: numeric Upper limit for max(range 1) - min(range 1) Range: -256 dBpp to 256 dBpp, Unit: dBpp
+			- Range_2: float: numeric Upper limit for max(range 2) - min(range 2) Range: -256 dBpp to 256 dBpp, Unit: dBpp
+			- Max_1_Min_2: float: numeric Upper limit for max(range 1) - min(range 2) Range: -256 dB to 256 dB, Unit: dB
+			- Max_2_Min_1: float: numeric Upper limit for max(range 2) - min(range 1) Range: -256 dB to 256 dB, Unit: dB
+			- Edge_Frequency: float: numeric Frequency band edge distance of border between range 1 and range 2 Range: 0 MHz to 20 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Range_1'),
 			ArgStruct.scalar_float('Range_2'),
 			ArgStruct.scalar_float('Max_1_Min_2'),
 			ArgStruct.scalar_float('Max_2_Min_1'),
 			ArgStruct.scalar_float('Edge_Frequency')]
@@ -37,22 +37,31 @@
 			self.Range_2: float = None
 			self.Max_1_Min_2: float = None
 			self.Max_2_Min_1: float = None
 			self.Edge_Frequency: float = None
 
 	def set(self, structure: EsFlatnessStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:ESFLatness \n
-		Snippet: driver.configure.multiEval.limit.qam.esFlatness.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.qam.esFlatness.EsFlatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Range_1: float = 1.0 \n
+		structure.Range_2: float = 1.0 \n
+		structure.Max_1_Min_2: float = 1.0 \n
+		structure.Max_2_Min_1: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.multiEval.limit.qam.esFlatness.set(structure, qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines limits for the equalizer spectrum flatness, for QAM modulations. \n
 			:param structure: for set value, see the help for EsFlatnessStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:ESFLatness', structure)
 
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> EsFlatnessStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:ESFLatness \n
 		Snippet: value: EsFlatnessStruct = driver.configure.multiEval.limit.qam.esFlatness.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines limits for the equalizer spectrum flatness, for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for EsFlatnessStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:ESFLatness?', self.__class__.EsFlatnessStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EvMagnitude.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Perror.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,46 +1,54 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvMagnitude:
-	"""EvMagnitude commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
+		Snippet: driver.configure.multiEval.limit.qam.perror.set(rms = 1.0, peak = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
+		the absolute value of the measured phase error exceeds the specified values. \n
+			:param rms: (float or boolean) numeric | ON | OFF Range: 0 deg to 180 deg, Unit: deg ON | OFF enables or disables the limit check.
+			:param peak: (float or boolean) numeric | ON | OFF Range: 0 deg to 180 deg, Unit: deg ON | OFF enables or disables the limit check.
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class EvMagnitudeStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Rms: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Peak: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+	class PerrorStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Rms: float or bool: numeric | ON | OFF Range: 0 deg to 180 deg, Unit: deg ON | OFF enables or disables the limit check.
+			- Peak: float or bool: numeric | ON | OFF Range: 0 deg to 180 deg, Unit: deg ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Rms'),
 			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Rms: float or bool = None
 			self.Peak: float or bool = None
 
-	def set(self, structure: EvMagnitudeStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:EVMagnitude \n
-		Snippet: driver.configure.multiEval.limit.qam.evMagnitude.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) , for QAM modulations. \n
-			:param structure: for set value, see the help for EvMagnitudeStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:EVMagnitude', structure)
-
-	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> EvMagnitudeStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:EVMagnitude \n
-		Snippet: value: EvMagnitudeStruct = driver.configure.multiEval.limit.qam.evMagnitude.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) , for QAM modulations. \n
+	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> PerrorStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
+		Snippet: value: PerrorStruct = driver.configure.multiEval.limit.qam.perror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
+		the absolute value of the measured phase error exceeds the specified values. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: structure: for return value, see the help for EvMagnitudeStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:EVMagnitude?', self.__class__.EvMagnitudeStruct())
+			:return: structure: for return value, see the help for PerrorStruct structure arguments."""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor?', self.__class__.PerrorStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/FreqError.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/FreqError.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FreqError:
-	"""FreqError commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FreqErrorCls:
+	"""FreqError commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("freqError", core, parent)
+		self._cmd_group = CommandsGroup("freqError", core, parent)
 
 	def set(self, frequency_error: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:FERRor \n
 		Snippet: driver.configure.multiEval.limit.qam.freqError.set(frequency_error = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines an upper limit for the carrier frequency error, for QAM modulations. \n
-			:param frequency_error: Range: 0 ppm to 1 ppm, Unit: ppm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
+			:param frequency_error: (float or boolean) numeric | ON | OFF Range: 0 ppm to 1 ppm, Unit: ppm ON | OFF enables or disables the limit check.
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:FERRor {param}')
 
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:FERRor \n
 		Snippet: value: float or bool = driver.configure.multiEval.limit.qam.freqError.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines an upper limit for the carrier frequency error, for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: frequency_error: Range: 0 ppm to 1 ppm, Unit: ppm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+			:return: frequency_error: (float or boolean) numeric | ON | OFF Range: 0 ppm to 1 ppm, Unit: ppm ON | OFF enables or disables the limit check."""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:FERRor?')
 		return Conversions.str_to_float_or_bool(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,38 +1,57 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ibe:
-	"""Ibe commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class IbeCls:
+	"""Ibe commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ibe", core, parent)
+		self._cmd_group = CommandsGroup("ibe", core, parent)
 
 	@property
 	def iqOffset(self):
 		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_iqOffset'):
-			from .Ibe_.IqOffset import IqOffset
-			self._iqOffset = IqOffset(self._core, self._base)
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
 		return self._iqOffset
 
+	def set(self, enable: bool, minimum: float, evm: float, rb_power: float, iq_image: float, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE \n
+		Snippet: driver.configure.multiEval.limit.qam.ibe.set(enable = False, minimum = 1.0, evm = 1.0, rb_power = 1.0, iq_image = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines parameters used for calculation of an upper limit for the inband emission, for QAM modulations, see 'Inband
+		emissions limits'. \n
+			:param enable: OFF | ON OFF: disables the limit check ON: enables the limit check
+			:param minimum: numeric Range: -256 dB to 256 dB, Unit: dB
+			:param evm: numeric Range: 0 % to 100 %, Unit: %
+			:param rb_power: numeric Range: -256 dBm to 256 dBm, Unit: dBm
+			:param iq_image: numeric Range: -256 dB to 256 dB, Unit: dB
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('minimum', minimum, DataType.Float), ArgSingle('evm', evm, DataType.Float), ArgSingle('rb_power', rb_power, DataType.Float), ArgSingle('iq_image', iq_image, DataType.Float))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class IbeStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
-			- Minimum: float: Range: -256 dB to 256 dB, Unit: dB
-			- Evm: float: Range: 0 % to 100 %, Unit: %
-			- Rb_Power: float: Range: -256 dBm to 256 dBm, Unit: dBm
-			- Iq_Image: float: Range: -256 dB to 256 dB, Unit: dB"""
+			- Minimum: float: numeric Range: -256 dB to 256 dB, Unit: dB
+			- Evm: float: numeric Range: 0 % to 100 %, Unit: %
+			- Rb_Power: float: numeric Range: -256 dBm to 256 dBm, Unit: dBm
+			- Iq_Image: float: numeric Range: -256 dB to 256 dB, Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Minimum'),
 			ArgStruct.scalar_float('Evm'),
 			ArgStruct.scalar_float('Rb_Power'),
 			ArgStruct.scalar_float('Iq_Image')]
 
@@ -40,34 +59,24 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Minimum: float = None
 			self.Evm: float = None
 			self.Rb_Power: float = None
 			self.Iq_Image: float = None
 
-	def set(self, structure: IbeStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE \n
-		Snippet: driver.configure.multiEval.limit.qam.ibe.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines parameters used for calculation of an upper limit for the inband emission, for QAM modulations, see 'Inband
-		Emissions Limits'. \n
-			:param structure: for set value, see the help for IbeStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IbeStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE \n
 		Snippet: value: IbeStruct = driver.configure.multiEval.limit.qam.ibe.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines parameters used for calculation of an upper limit for the inband emission, for QAM modulations, see 'Inband
-		Emissions Limits'. \n
+		emissions limits'. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for IbeStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE?', self.__class__.IbeStruct())
 
-	def clone(self) -> 'Ibe':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IbeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ibe(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IbeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/IqOffset.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/IqOffset.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,58 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqOffset:
-	"""IqOffset commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqOffset", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
+
+	def set(self, offset_1: float, offset_2: float, offset_3: float, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
+		Snippet: driver.configure.multiEval.limit.qam.ibe.iqOffset.set(offset_1 = 1.0, offset_2 = 1.0, offset_3 = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission, for QAM modulations.
+		Three different values can be set for three TX power ranges, see 'Inband emissions limits'. \n
+			:param offset_1: numeric Offset for high TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			:param offset_2: numeric Offset for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			:param offset_3: numeric Offset for low TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('offset_1', offset_1, DataType.Float), ArgSingle('offset_2', offset_2, DataType.Float), ArgSingle('offset_3', offset_3, DataType.Float))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class IqOffsetStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Offset_1: float: Offset for high TX power range Range: -256 dBc to 256 dBc, Unit: dBc
-			- Offset_2: float: Offset for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dBc
-			- Offset_3: float: Offset for low TX power range Range: -256 dBc to 256 dBc, Unit: dBc"""
+		"""Response structure. Fields: \n
+			- Offset_1: float: numeric Offset for high TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			- Offset_2: float: numeric Offset for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			- Offset_3: float: numeric Offset for low TX power range Range: -256 dBc to 256 dBc, Unit: dBc"""
 		__meta_args_list = [
 			ArgStruct.scalar_float('Offset_1'),
 			ArgStruct.scalar_float('Offset_2'),
 			ArgStruct.scalar_float('Offset_3')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Offset_1: float = None
 			self.Offset_2: float = None
 			self.Offset_3: float = None
 
-	def set(self, structure: IqOffsetStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qam.ibe.iqOffset.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission, for QAM modulations.
-		Three different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
-			:param structure: for set value, see the help for IqOffsetStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IqOffsetStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
 		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qam.ibe.iqOffset.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission, for QAM modulations.
-		Three different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
+		Three different values can be set for three TX power ranges, see 'Inband emissions limits'. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for IqOffsetStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset?', self.__class__.IqOffsetStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/IqOffset.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/IqOffset.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,54 +1,62 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqOffset:
-	"""IqOffset commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqOffset", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
+
+	def set(self, enable: bool, offset_1: float, offset_2: float, offset_3: float, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
+		Snippet: driver.configure.multiEval.limit.qam.iqOffset.set(enable = False, offset_1 = 1.0, offset_2 = 1.0, offset_3 = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the I/Q origin offset, for QAM modulations. Three different I/Q origin offset limits can be set
+		for three TX power ranges. For details, see 'I/Q origin offset limits'. \n
+			:param enable: OFF | ON OFF: disables the limit check ON: enables the limit check
+			:param offset_1: numeric I/Q origin offset limit for high TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			:param offset_2: numeric I/Q origin offset limit for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			:param offset_3: numeric I/Q origin offset limit for low TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('offset_1', offset_1, DataType.Float), ArgSingle('offset_2', offset_2, DataType.Float), ArgSingle('offset_3', offset_3, DataType.Float))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class IqOffsetStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
-			- Offset_1: float: I/Q origin offset limit for high TX power range Range: -256 dBc to 256 dBc, Unit: dBc
-			- Offset_2: float: I/Q origin offset limit for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dBc
-			- Offset_3: float: I/Q origin offset limit for low TX power range Range: -256 dBc to 256 dBc, Unit: dBc"""
+			- Offset_1: float: numeric I/Q origin offset limit for high TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			- Offset_2: float: numeric I/Q origin offset limit for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dBc
+			- Offset_3: float: numeric I/Q origin offset limit for low TX power range Range: -256 dBc to 256 dBc, Unit: dBc"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Offset_1'),
 			ArgStruct.scalar_float('Offset_2'),
 			ArgStruct.scalar_float('Offset_3')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Offset_1: float = None
 			self.Offset_2: float = None
 			self.Offset_3: float = None
 
-	def set(self, structure: IqOffsetStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qam.iqOffset.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the I/Q origin offset, for QAM modulations. Three different I/Q origin offset limits can be set
-		for three TX power ranges. For details, see 'I/Q Origin Offset Limits'. \n
-			:param structure: for set value, see the help for IqOffsetStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IqOffsetStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
 		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qam.iqOffset.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines upper limits for the I/Q origin offset, for QAM modulations. Three different I/Q origin offset limits can be set
-		for three TX power ranges. For details, see 'I/Q Origin Offset Limits'. \n
+		for three TX power ranges. For details, see 'I/Q origin offset limits'. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for IqOffsetStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset?', self.__class__.IqOffsetStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Merror.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Merror.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,46 +1,52 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Merror:
-	"""Merror commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("merror", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
+		Snippet: driver.configure.multiEval.limit.qam.merror.set(rms = 1.0, peak = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
+			:param rms: (float or boolean) numeric | ON | OFF Range: 0 % to 100 %, Unit: % ON | OFF enables or disables the limit check.
+			:param peak: (float or boolean) numeric | ON | OFF Range: 0 % to 100 %, Unit: % ON | OFF enables or disables the limit check.
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class MerrorStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Rms: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Peak: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+		"""Response structure. Fields: \n
+			- Rms: float or bool: numeric | ON | OFF Range: 0 % to 100 %, Unit: % ON | OFF enables or disables the limit check.
+			- Peak: float or bool: numeric | ON | OFF Range: 0 % to 100 %, Unit: % ON | OFF enables or disables the limit check."""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Rms'),
 			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Rms: float or bool = None
 			self.Peak: float or bool = None
 
-	def set(self, structure: MerrorStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
-		Snippet: driver.configure.multiEval.limit.qam.merror.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
-			:param structure: for set value, see the help for MerrorStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> MerrorStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
 		Snippet: value: MerrorStruct = driver.configure.multiEval.limit.qam.merror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for MerrorStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor?', self.__class__.MerrorStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Perror.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/Maximum.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,48 +1,53 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from typing import List
+
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Types import DataType
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Perror:
-	"""Perror commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("perror", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
-	class PerrorStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Rms: float or bool: Range: 0 deg to 180 deg, Unit: deg Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Peak: float or bool: Range: 0 deg to 180 deg, Unit: deg Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float Magnitude error value for low EVM window position Unit: %
+			- High: List[float]: float Magnitude error value for high EVM window position Unit: %"""
 		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
+			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def set(self, structure: PerrorStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
-		Snippet: driver.configure.multiEval.limit.qam.perror.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
-		the absolute value of the measured phase error exceeds the specified values. \n
-			:param structure: for set value, see the help for PerrorStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor', structure)
-
-	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> PerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
-		Snippet: value: PerrorStruct = driver.configure.multiEval.limit.qam.perror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
-		the absolute value of the measured phase error exceeds the specified values. \n
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: structure: for return value, see the help for PerrorStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor?', self.__class__.PerrorStruct())
+			self.Reliability: int = None
+			self.Low: List[float] = None
+			self.High: List[float] = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.merror.maximum.read() \n
+		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View
+		Magnitude Error, Phase Error'. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.merror.maximum.fetch() \n
+		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View
+		Magnitude Error, Phase Error'. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Sflatness.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Sflatness.py`

 * *Files 23% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sflatness:
-	"""Sflatness commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SflatnessCls:
+	"""Sflatness commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sflatness", core, parent)
+		self._cmd_group = CommandsGroup("sflatness", core, parent)
 
 	# noinspection PyTypeChecker
 	class SflatnessStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
 			- Enable: bool: No parameter help available
 			- Lower: float: No parameter help available
 			- Upper: float: No parameter help available
@@ -37,22 +37,31 @@
 			self.Upper: float = None
 			self.Edge_Lower: float = None
 			self.Edge_Upper: float = None
 			self.Edge_Frequency: float = None
 
 	def set(self, structure: SflatnessStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:SFLatness \n
-		Snippet: driver.configure.multiEval.limit.qam.sflatness.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.qam.sflatness.SflatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Lower: float = 1.0 \n
+		structure.Upper: float = 1.0 \n
+		structure.Edge_Lower: float = 1.0 \n
+		structure.Edge_Upper: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.multiEval.limit.qam.sflatness.set(structure, qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		No command help available \n
 			:param structure: for set value, see the help for SflatnessStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:SFLatness', structure)
 
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> SflatnessStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:SFLatness \n
 		Snippet: value: SflatnessStruct = driver.configure.multiEval.limit.qam.sflatness.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		No command help available \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for SflatnessStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:SFLatness?', self.__class__.SflatnessStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/Ibe.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Minimum.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,89 +1,78 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ibe:
-	"""Ibe commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ibe", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
-	class IqOffsetStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Offset_1: float: Offset for high TX power range Range: -256 dBc to 256 dBc, Unit: dB
-			- Offset_2: float: Offset for intermediate TX power range Range: -256 dBc to 256 dBc, Unit: dB
-			- Offset_3: float: Offset for low TX power range Range: -256 dBc to 256 dBc, Unit: dB"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Tx_Power_Min: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Offset_1'),
-			ArgStruct.scalar_float('Offset_2'),
-			ArgStruct.scalar_float('Offset_3')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Tx_Power_Min')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Offset_1: float = None
-			self.Offset_2: float = None
-			self.Offset_3: float = None
-
-	def get_iq_offset(self) -> IqOffsetStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset \n
-		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qpsk.ibe.get_iq_offset() \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission (QPSK modulation) . Three
-		different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
-			:return: structure: for return value, see the help for IqOffsetStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset?', self.__class__.IqOffsetStruct())
-
-	def set_iq_offset(self, value: IqOffsetStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qpsk.ibe.set_iq_offset(value = IqOffsetStruct()) \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission (QPSK modulation) . Three
-		different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
-			:param value: see the help for IqOffsetStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset', value)
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power_Min: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.minimum.fetch(segment = repcap.Segment.Default) \n
+		Return total TX power results for segment <no> in list mode. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
-			- Minimum: float: Range: -256 dB to 256 dB, Unit: dB
-			- Evm: float: Range: 0 % to 100 %, Unit: %
-			- Rb_Power: float: Range: -256 dBm to 256 dBm, Unit: dBm
-			- Iq_Image: float: Range: -256 dB to 256 dB, Unit: dB"""
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power_Min: float or bool: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Minimum'),
-			ArgStruct.scalar_float('Evm'),
-			ArgStruct.scalar_float('Rb_Power'),
-			ArgStruct.scalar_float('Iq_Image')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float_ext('Tx_Power_Min')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Minimum: float = None
-			self.Evm: float = None
-			self.Rb_Power: float = None
-			self.Iq_Image: float = None
-
-	def get_value(self) -> ValueStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.limit.qpsk.ibe.get_value() \n
-		Defines parameters used for calculation of an upper limit for the inband emission (QPSK modulation) , see 'Inband
-		Emissions Limits'. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE \n
-		Snippet: driver.configure.multiEval.limit.qpsk.ibe.set_value(value = ValueStruct()) \n
-		Defines parameters used for calculation of an upper limit for the inband emission (QPSK modulation) , see 'Inband
-		Emissions Limits'. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE', value)
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power_Min: float or bool = None
+
+	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.minimum.calculate(segment = repcap.Segment.Default) \n
+		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 13 total commands, 3 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 13 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
 	def obwLimit(self):
 		"""obwLimit commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_obwLimit'):
-			from .SeMask_.ObwLimit import ObwLimit
-			self._obwLimit = ObwLimit(self._core, self._base)
+			from .ObwLimit import ObwLimitCls
+			self._obwLimit = ObwLimitCls(self._core, self._cmd_group)
 		return self._obwLimit
 
 	@property
 	def limit(self):
 		"""limit commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .SeMask_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	@property
 	def atTolerance(self):
 		"""atTolerance commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_atTolerance'):
-			from .SeMask_.AtTolerance import AtTolerance
-			self._atTolerance = AtTolerance(self._core, self._base)
+			from .AtTolerance import AtToleranceCls
+			self._atTolerance = AtToleranceCls(self._core, self._cmd_group)
 		return self._atTolerance
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/AtTolerance.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/AtTolerance.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,60 +2,61 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AtTolerance:
-	"""AtTolerance commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class AtToleranceCls:
+	"""AtTolerance commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: EutraBand, default value after init: EutraBand.Nr30"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("atTolerance", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_eutraBand_get', 'repcap_eutraBand_set', repcap.EutraBand.Nr30)
+		self._cmd_group = CommandsGroup("atTolerance", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_eutraBand_get', 'repcap_eutraBand_set', repcap.EutraBand.Nr30)
 
-	def repcap_eutraBand_set(self, enum_value: repcap.EutraBand) -> None:
+	def repcap_eutraBand_set(self, eutraBand: repcap.EutraBand) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to EutraBand.Default
 		Default value after init: EutraBand.Nr30"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(eutraBand)
 
 	def repcap_eutraBand_get(self) -> repcap.EutraBand:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, add_test_tol: float, eutraBand=repcap.EutraBand.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance<EUTRAband> \n
 		Snippet: driver.configure.multiEval.limit.seMask.atTolerance.set(add_test_tol = 1.0, eutraBand = repcap.EutraBand.Default) \n
 		Defines additional test tolerances for the emission masks. The tolerance is added to the power values of all general and
 		additional spectrum emission masks. A positive tolerance value relaxes the limits. For operating bands below 3 GHz, there
 		is no additional test tolerance. You can define different additional test tolerances for bands above 3 GHz and for bands
 		above 5 GHz. \n
-			:param add_test_tol: Additional test tolerance Range: -5 dB to 5 dB, Unit: dB
-			:param eutraBand: optional repeated capability selector. Default value: Nr30 (settable in the interface 'AtTolerance')"""
+			:param add_test_tol: numeric Additional test tolerance Range: -5 dB to 5 dB, Unit: dB
+			:param eutraBand: optional repeated capability selector. Default value: Nr30 (settable in the interface 'AtTolerance')
+		"""
 		param = Conversions.decimal_value_to_str(add_test_tol)
-		eutraBand_cmd_val = self._base.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
+		eutraBand_cmd_val = self._cmd_group.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance{eutraBand_cmd_val} {param}')
 
 	def get(self, eutraBand=repcap.EutraBand.Default) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance<EUTRAband> \n
 		Snippet: value: float = driver.configure.multiEval.limit.seMask.atTolerance.get(eutraBand = repcap.EutraBand.Default) \n
 		Defines additional test tolerances for the emission masks. The tolerance is added to the power values of all general and
 		additional spectrum emission masks. A positive tolerance value relaxes the limits. For operating bands below 3 GHz, there
 		is no additional test tolerance. You can define different additional test tolerances for bands above 3 GHz and for bands
 		above 5 GHz. \n
 			:param eutraBand: optional repeated capability selector. Default value: Nr30 (settable in the interface 'AtTolerance')
-			:return: add_test_tol: Additional test tolerance Range: -5 dB to 5 dB, Unit: dB"""
-		eutraBand_cmd_val = self._base.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
+			:return: add_test_tol: numeric Additional test tolerance Range: -5 dB to 5 dB, Unit: dB"""
+		eutraBand_cmd_val = self._cmd_group.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance{eutraBand_cmd_val}?')
 		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'AtTolerance':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AtToleranceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = AtTolerance(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AtToleranceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,58 +1,50 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 8 total commands, 3 Sub-groups, 0 group commands
-	Repeated Capability: Limit, default value after init: Limit.Nr1"""
+class AdditionalCls:
+	"""Additional commands group definition. 4 total commands, 2 Subgroups, 0 group commands
+	Repeated Capability: Table, default value after init: Table.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_limit_get', 'repcap_limit_set', repcap.Limit.Nr1)
+		self._cmd_group = CommandsGroup("additional", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_table_get', 'repcap_table_set', repcap.Table.Nr1)
 
-	def repcap_limit_set(self, enum_value: repcap.Limit) -> None:
+	def repcap_table_set(self, table: repcap.Table) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Limit.Default
-		Default value after init: Limit.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Table.Default
+		Default value after init: Table.Nr1"""
+		self._cmd_group.set_repcap_enum_value(table)
 
-	def repcap_limit_get(self) -> repcap.Limit:
+	def repcap_table_get(self) -> repcap.Table:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
+		"""channelBw commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Limit_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
-	def additional(self):
-		"""additional commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_additional'):
-			from .Limit_.Additional import Additional
-			self._additional = Additional(self._core, self._base)
-		return self._additional
-
-	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Limit_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AdditionalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AdditionalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,50 +1,58 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.RepeatedCapability import RepeatedCapability
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Additional:
-	"""Additional commands group definition. 4 total commands, 2 Sub-groups, 0 group commands
-	Repeated Capability: Table, default value after init: Table.Nr1"""
+class LimitCls:
+	"""Limit commands group definition. 8 total commands, 3 Subgroups, 0 group commands
+	Repeated Capability: Limit, default value after init: Limit.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("additional", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_table_get', 'repcap_table_set', repcap.Table.Nr1)
+		self._cmd_group = CommandsGroup("limit", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_limit_get', 'repcap_limit_set', repcap.Limit.Nr1)
 
-	def repcap_table_set(self, enum_value: repcap.Table) -> None:
+	def repcap_limit_set(self, limit: repcap.Limit) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Table.Default
-		Default value after init: Table.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Limit.Default
+		Default value after init: Limit.Nr1"""
+		self._cmd_group.set_repcap_enum_value(limit)
 
-	def repcap_table_get(self) -> repcap.Table:
+	def repcap_limit_get(self) -> repcap.Limit:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw(self):
-		"""channelBw commands group. 1 Sub-classes, 1 commands."""
+		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Additional_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
+	def additional(self):
+		"""additional commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_additional'):
+			from .Additional import AdditionalCls
+			self._additional = AdditionalCls(self._core, self._cmd_group)
+		return self._additional
+
+	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Additional_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
-	def clone(self) -> 'Additional':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Additional(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	@property
 	def ocombination(self):
 		"""ocombination commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ocombination'):
-			from .CarrierAggregation_.Ocombination import Ocombination
-			self._ocombination = Ocombination(self._core, self._base)
+			from .Ocombination import OcombinationCls
+			self._ocombination = OcombinationCls(self._core, self._cmd_group)
 		return self._ocombination
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,42 @@
 from .........Internal.Core import Core
 from .........Internal.CommandsGroup import CommandsGroup
 from .........Internal.RepeatedCapability import RepeatedCapability
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
-	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw150"""
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
+	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw150)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
-		Default value after init: FirstChannelBw.Bw150"""
-		self._base.set_repcap_enum_value(enum_value)
+		Default value after init: FirstChannelBw.Bw100"""
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
-		"""channelBw2nd commands group. 0 Sub-classes, 1 commands."""
+		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,45 +1,78 @@
 from ..........Internal.Core import Core
 from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
 from ..........Internal.StructBase import StructBase
 from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
 from ..........Internal.RepeatedCapability import RepeatedCapability
 from .......... import enums
 from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	@property
+	def channelBw3rd(self):
+		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_channelBw3rd'):
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
+		return self._channelBw3rd
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
+		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
+		figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param enable: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param frequency_end: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param level: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			:param rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Level: float: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -47,50 +80,30 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBw2ndStruct, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
-		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
-		in the figure, use ...:CBANdwidth200:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
-	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
-		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
-		in the figure, use ...:CBANdwidth200:CBANdwidth50. \n
+	def get(self, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
+		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
+		figure, use ...:CBANdwidth100:CBANdwidth50. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/Ocombination.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/Ocombination.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,53 @@
 from .........Internal.Core import Core
 from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
+from .........Internal.ArgSingleList import ArgSingleList
+from .........Internal.ArgSingle import ArgSingle
 from ......... import enums
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ocombination:
-	"""Ocombination commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class OcombinationCls:
+	"""Ocombination commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ocombination", core, parent)
+		self._cmd_group = CommandsGroup("ocombination", core, parent)
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, table=repcap.Table.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:OCOMbination \n
+		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.ocombination.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, table = repcap.Table.Default) \n
+		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
+		and the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not
+		covered by other commands in this chapter. \n
+			:param enable: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param frequency_end: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param level: numeric Upper limit for the area. Range: -256 dBm to 256 dBm, Unit: dBm
+			:param rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:OCOMbination {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class OcombinationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Level: float: numeric Upper limit for the area. Range: -256 dBm to 256 dBm, Unit: dBm
+			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -33,32 +55,19 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: OcombinationStruct, limit=repcap.Limit.Default, table=repcap.Table.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.ocombination.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not
-		covered by other commands in this section. \n
-			:param structure: for set value, see the help for OcombinationStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:OCOMbination', structure)
-
 	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default) -> OcombinationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:OCOMbination \n
 		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.ocombination.get(limit = repcap.Limit.Default, table = repcap.Table.Default) \n
 		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
 		and the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not
-		covered by other commands in this section. \n
+		covered by other commands in this chapter. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:return: structure: for return value, see the help for OcombinationStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,53 +1,77 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import enums
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from .........Internal.ArgSingleList import ArgSingleList
+from .........Internal.ArgSingle import ArgSingle
+from .........Internal.RepeatedCapability import RepeatedCapability
+from ......... import enums
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def sidelink(self):
 		"""sidelink commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sidelink'):
-			from .ChannelBw_.Sidelink import Sidelink
-			self._sidelink = Sidelink(self._core, self._base)
+			from .Sidelink import SidelinkCls
+			self._sidelink = SidelinkCls(self._core, self._cmd_group)
 		return self._sidelink
 
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.RbwExtended, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band> \n
+		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.channelBw.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.RbwExtended.K030, limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
+		Defines additional requirements for the emission mask area <no>, for uplink measurements. The activation state, the area
+		borders, an upper limit and the resolution bandwidth must be specified. The emission mask applies to the channel
+		bandwidth <Band>. Several tables of additional requirements are available. \n
+			:param enable: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: numeric Start frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			:param frequency_end: numeric Stop frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			:param level: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			:param rbw: K030 | K050 | K100 | K150 | K200 | M1 Resolution bandwidth to be used for the area. Only a subset of the values is allowed, depending on Table and Band, see table below. K030: 30 kHz K050: 50 kHz K100: 100 kHz K150: 150 kHz K200: 200 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.RbwExtended))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the channel bandwidth Range: see table below , Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the channel bandwidth Range: see table below , Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.RbwExtended: K030 | K050 | K100 | K150 | K200 | M1 Resolution bandwidth to be used for the area Only a subset of the values is allowed, depending on Table and Band, see table below K030: 30 kHz K050: 50 kHz K100: 100 kHz K150: 150 kHz K200: 200 kHz M1: 1 MHz"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			- Level: float: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			- Rbw: enums.RbwExtended: K030 | K050 | K100 | K150 | K200 | M1 Resolution bandwidth to be used for the area. Only a subset of the values is allowed, depending on Table and Band, see table below. K030: 30 kHz K050: 50 kHz K100: 100 kHz K150: 150 kHz K200: 200 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.RbwExtended)]
 
@@ -55,44 +79,29 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.RbwExtended = None
 
-	def set(self, structure: ChannelBwStruct, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.channelBw.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines additional requirements for the emission mask area <no>, for uplink measurements. The activation state, the area
-		borders, an upper limit and the resolution bandwidth must be specified. The emission mask applies to the channel
-		bandwidth <Band>. Several tables of additional requirements are available. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band> \n
 		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.seMask.limit.additional.channelBw.get(limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines additional requirements for the emission mask area <no>, for uplink measurements. The activation state, the area
 		borders, an upper limit and the resolution bandwidth must be specified. The emission mask applies to the channel
 		bandwidth <Band>. Several tables of additional requirements are available. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/Sidelink.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/Sidelink.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,30 +3,30 @@
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
 from ......... import enums
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sidelink:
-	"""Sidelink commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SidelinkCls:
+	"""Sidelink commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sidelink", core, parent)
+		self._cmd_group = CommandsGroup("sidelink", core, parent)
 
 	# noinspection PyTypeChecker
 	class SidelinkStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the channel bandwidth Range: 0 MHz to 25 MHz, Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the channel bandwidth Range: 0 MHz to 25 MHz, Unit: Hz
-			- Level: float: Upper limit at FrequencyStart Range: -256 dBm to 256 dBm, Unit: dBm
-			- Slope: float: Slope for the upper limit within the area Range: -256 dB/MHz to 256 dB/MHz, Unit: dB/MHz
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the channel bandwidth. Range: 0 MHz to 25 MHz, Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the channel bandwidth. Range: 0 MHz to 25 MHz, Unit: Hz
+			- Level: float: numeric Upper limit at FrequencyStart Range: -256 dBm to 256 dBm, Unit: dBm
+			- Slope: float: numeric Slope for the upper limit within the area Range: -256 dB/MHz to 256 dB/MHz, Unit: dB/MHz
+			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_float('Slope'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
@@ -38,34 +38,43 @@
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Slope: float = None
 			self.Rbw: enums.Rbw = None
 
 	def set(self, structure: SidelinkStruct, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band>:SIDelink \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.channelBw.sidelink.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.seMask.limit.additional.channelBw.sidelink.SidelinkStruct() \n
+		structure.Enable: bool = False \n
+		structure.Frequency_Start: float = 1.0 \n
+		structure.Frequency_End: float = 1.0 \n
+		structure.Level: float = 1.0 \n
+		structure.Slope: float = 1.0 \n
+		structure.Rbw: enums.Rbw = enums.Rbw.K030 \n
+		driver.configure.multiEval.limit.seMask.limit.additional.channelBw.sidelink.set(structure, limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines additional requirements for the emission mask area <no>, for sidelink measurements. The activation state, the
 		area borders, the start value and slope of the upper limit and the resolution bandwidth must be specified. The emission
 		mask applies to the channel bandwidth <Band>. \n
 			:param structure: for set value, see the help for SidelinkStruct structure arguments.
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}:SIDelink', structure)
 
 	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> SidelinkStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band>:SIDelink \n
 		Snippet: value: SidelinkStruct = driver.configure.multiEval.limit.seMask.limit.additional.channelBw.sidelink.get(limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines additional requirements for the emission mask area <no>, for sidelink measurements. The activation state, the
 		area borders, the start value and slope of the upper limit and the resolution bandwidth must be specified. The emission
 		mask applies to the channel bandwidth <Band>. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for SidelinkStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}:SIDelink?', self.__class__.SidelinkStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	@property
 	def ocombination(self):
 		"""ocombination commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ocombination'):
-			from .CarrierAggregation_.Ocombination import Ocombination
-			self._ocombination = Ocombination(self._core, self._base)
+			from .Ocombination import OcombinationCls
+			self._ocombination = OcombinationCls(self._core, self._cmd_group)
 		return self._ocombination
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.RepeatedCapability import RepeatedCapability
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
-	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw150"""
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
+	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw150)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
-		Default value after init: FirstChannelBw.Bw150"""
-		self._base.set_repcap_enum_value(enum_value)
+		Default value after init: FirstChannelBw.Bw100"""
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
 		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/ChannelBw.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,53 +1,66 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import enums
-from ......... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
-	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
+	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
-		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
+		Default value after init: ChannelBw.Bw14"""
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
-	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
+	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	@property
-	def channelBw3rd(self):
-		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
-		return self._channelBw3rd
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
+		Snippet: driver.configure.multiEval.limit.seMask.limit.channelBw.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
+			:param enable: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: numeric Start frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			:param frequency_end: numeric Stop frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			:param level: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			:param rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+	class ChannelBwStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the channel bandwidth. Range: see table below , Unit: Hz
+			- Level: float: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -55,46 +68,26 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBw2ndStruct, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
-		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
-		figure, use ...:CBANdwidth200:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
-	def get(self, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+	def get(self, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
+		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.seMask.limit.channelBw.get(limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
-		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
-		figure, use ...:CBANdwidth200:CBANdwidth50. \n
+		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,45 +1,72 @@
 from ..........Internal.Core import Core
 from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
 from ..........Internal.StructBase import StructBase
 from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
 from ..........Internal.RepeatedCapability import RepeatedCapability
 from .......... import enums
 from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
 		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
 	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
+		for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
+		figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+			:param enable: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param frequency_end: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			:param level: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			:param rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw3rdStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: numeric Start frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Frequency_End: float: numeric Stop frequency of the area, relative to the edges of the aggregated channel bandwidth. Range: 0 MHz to 65 MHz, Unit: Hz
+			- Level: float: numeric Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
+			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -47,50 +74,32 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBw3rdStruct, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
-		for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
-		figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param structure: for set value, see the help for ChannelBw3rdStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}', structure)
-
 	def get(self, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
 		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
 		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
 		for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
 		figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
 			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/Ocombination.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,60 +1,74 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import enums
-from ........ import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ocombination:
-	"""Ocombination commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbAllocationCls:
+	"""RbAllocation commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ocombination", core, parent)
+		self._cmd_group = CommandsGroup("rbAllocation", core, parent)
+
+	@property
+	def sidelink(self):
+		"""sidelink commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sidelink'):
+			from .Sidelink import SidelinkCls
+			self._sidelink = SidelinkCls(self._core, self._cmd_group)
+		return self._sidelink
+
+	def set(self, auto: bool, no_rb: int, offset: int, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
+		Snippet: driver.configure.multiEval.listPy.segment.rbAllocation.set(auto = False, no_rb = 1, offset = 1, segment = repcap.Segment.Default) \n
+		Allows you to define the uplink resource block allocation manually for segment <no>. By default, the RB allocation is
+		detected automatically. \n
+			:param auto: OFF | ON OFF: manual definition via NoRB and Offset ON: automatic detection of RB allocation
+			:param no_rb: integer Number of allocated resource blocks in each measured slot Range: see table below
+			:param offset: integer Offset of first allocated resource block from edge of allocated UL transmission bandwidth Range: 0 to max(NoRB) - NoRB
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('auto', auto, DataType.Boolean), ArgSingle('no_rb', no_rb, DataType.Integer), ArgSingle('offset', offset, DataType.Integer))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class OcombinationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth Range: 0 MHz to 65 MHz, Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+	class RbAllocationStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Auto: bool: OFF | ON OFF: manual definition via NoRB and Offset ON: automatic detection of RB allocation
+			- No_Rb: int: integer Number of allocated resource blocks in each measured slot Range: see table below
+			- Offset: int: integer Offset of first allocated resource block from edge of allocated UL transmission bandwidth Range: 0 to max(NoRB) - NoRB"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Frequency_Start'),
-			ArgStruct.scalar_float('Frequency_End'),
-			ArgStruct.scalar_float('Level'),
-			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
+			ArgStruct.scalar_bool('Auto'),
+			ArgStruct.scalar_int('No_Rb'),
+			ArgStruct.scalar_int('Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Frequency_Start: float = None
-			self.Frequency_End: float = None
-			self.Level: float = None
-			self.Rbw: enums.Rbw = None
-
-	def set(self, structure: OcombinationStruct, limit=repcap.Limit.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.ocombination.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not covered
-		by other commands in this section. \n
-			:param structure: for set value, see the help for OcombinationStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:OCOMbination', structure)
-
-	def get(self, limit=repcap.Limit.Default) -> OcombinationStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:OCOMbination \n
-		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.seMask.limit.carrierAggregation.ocombination.get(limit = repcap.Limit.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not covered
-		by other commands in this section. \n
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:return: structure: for return value, see the help for OcombinationStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
+			self.Auto: bool = None
+			self.No_Rb: int = None
+			self.Offset: int = None
+
+	def get(self, segment=repcap.Segment.Default) -> RbAllocationStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
+		Snippet: value: RbAllocationStruct = driver.configure.multiEval.listPy.segment.rbAllocation.get(segment = repcap.Segment.Default) \n
+		Allows you to define the uplink resource block allocation manually for segment <no>. By default, the RB allocation is
+		detected automatically. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for RbAllocationStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation?', self.__class__.RbAllocationStruct())
+
+	def clone(self) -> 'RbAllocationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = RbAllocationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Pdynamics/ChannelBw.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from .......Internal.RepeatedCapability import RepeatedCapability
-from ....... import enums
-from ....... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, enable: bool, on_power_upper: float, on_power_lower: float, off_power_upper: float, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth<Band> \n
+		Snippet: driver.configure.multiEval.limit.pdynamics.channelBw.set(enable = False, on_power_upper = 1.0, on_power_lower = 1.0, off_power_upper = 1.0, channelBw = repcap.ChannelBw.Default) \n
+		Defines limits for the ON power and OFF power determined with the power dynamics measurement. Separate limits can be
+		defined for each channel bandwidth. \n
+			:param enable: OFF | ON OFF: disables the limit check ON: enables the limit check
+			:param on_power_upper: numeric Upper limit for the 'ON power' Range: -256 dBm to 256 dBm, Unit: dBm
+			:param on_power_lower: numeric Lower limit for the 'ON power' Range: -256 dBm to 256 dBm, Unit: dBm
+			:param off_power_upper: numeric Upper limit for the 'OFF power' and the 'SRS OFF' power Range: -256 dBm to 256 dBm, Unit: dBm
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('on_power_upper', on_power_upper, DataType.Float), ArgSingle('on_power_lower', on_power_lower, DataType.Float), ArgSingle('off_power_upper', off_power_upper, DataType.Float))
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the channel bandwidth Range: see table below , Unit: Hz
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the channel bandwidth Range: see table below , Unit: Hz
-			- Level: float: Upper limit for the area Range: -256 dBm to 256 dBm, Unit: dBm
-			- Rbw: enums.Rbw: K030 | K100 | M1 Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
+			- On_Power_Upper: float: numeric Upper limit for the 'ON power' Range: -256 dBm to 256 dBm, Unit: dBm
+			- On_Power_Lower: float: numeric Lower limit for the 'ON power' Range: -256 dBm to 256 dBm, Unit: dBm
+			- Off_Power_Upper: float: numeric Upper limit for the 'OFF power' and the 'SRS OFF' power Range: -256 dBm to 256 dBm, Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Frequency_Start'),
-			ArgStruct.scalar_float('Frequency_End'),
-			ArgStruct.scalar_float('Level'),
-			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
+			ArgStruct.scalar_float('On_Power_Upper'),
+			ArgStruct.scalar_float('On_Power_Lower'),
+			ArgStruct.scalar_float('Off_Power_Upper')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
-			self.Frequency_Start: float = None
-			self.Frequency_End: float = None
-			self.Level: float = None
-			self.Rbw: enums.Rbw = None
-
-	def set(self, structure: ChannelBwStruct, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.channelBw.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val}', structure)
-
-	def get(self, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.seMask.limit.channelBw.get(limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			self.On_Power_Upper: float = None
+			self.On_Power_Lower: float = None
+			self.Off_Power_Upper: float = None
+
+	def get(self, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth<Band> \n
+		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.pdynamics.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
+		Defines limits for the ON power and OFF power determined with the power dynamics measurement. Separate limits can be
+		defined for each channel bandwidth. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ObwLimit:
-	"""ObwLimit commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("obwLimit", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .ObwLimit_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def seMask(self):
+		"""seMask commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_seMask'):
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
+		return self._seMask
 
-	@property
-	def carrierAggregation(self):
-		"""carrierAggregation commands group. 1 Sub-classes, 1 commands."""
-		if not hasattr(self, '_carrierAggregation'):
-			from .ObwLimit_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
-		return self._carrierAggregation
-
-	def clone(self) -> 'ObwLimit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ObwLimit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	def get_ocombination(self) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination \n
 		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.get_ocombination() \n
 		Defines an upper limit for the occupied bandwidth. The setting applies to all 'other' channel bandwidth combinations, not
-		covered by other commands in this section. \n
-			:return: obw_limit: Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
+		covered by other commands in this chapter. \n
+			:return: obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_ocombination(self, obw_limit: float or bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination \n
 		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.set_ocombination(obw_limit = 1.0) \n
 		Defines an upper limit for the occupied bandwidth. The setting applies to all 'other' channel bandwidth combinations, not
-		covered by other commands in this section. \n
-			:param obw_limit: Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
+		covered by other commands in this chapter. \n
+			:param obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination {param}')
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.RepeatedCapability import RepeatedCapability
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
-	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw150"""
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
+	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw150)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
-		Default value after init: FirstChannelBw.Bw150"""
-		self._base.set_repcap_enum_value(enum_value)
+		Default value after init: FirstChannelBw.Bw100"""
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
 		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,71 +1,72 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal import Conversions
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal import Conversions
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw3rd(self):
 		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
 		return self._channelBw3rd
 
 	def set(self, obw_limit: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
 		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.set(obw_limit = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The setting is defined separately for each channel bandwidth
 		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
-		in the figure, use ...:CBANdwidth200:CBANdwidth50. \n
-			:param obw_limit: Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
+		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check.
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}')
 
 	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
 		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The setting is defined separately for each channel bandwidth
 		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
-		in the figure, use ...:CBANdwidth200:CBANdwidth50. \n
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:return: obw_limit: Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+			:return: obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check."""
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,66 +2,67 @@
 from ..........Internal.CommandsGroup import CommandsGroup
 from ..........Internal import Conversions
 from ..........Internal.RepeatedCapability import RepeatedCapability
 from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
 		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
 	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, obw_limit: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
 		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(obw_limit = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The settings are defined separately for each channel bandwidth
 		combination, for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first
 		line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param obw_limit: ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+			:param obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check.
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}')
 
 	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
 		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The settings are defined separately for each channel bandwidth
 		combination, for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first
 		line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw150 (settable in the interface 'ChannelBw1st')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
-			:return: obw_limit: ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+			:return: obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check."""
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/ChannelBw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/ChannelBw.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,54 +2,55 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from .......Internal.RepeatedCapability import RepeatedCapability
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, obw_limit: float or bool, channelBw=repcap.ChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth<Band> \n
 		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.channelBw.set(obw_limit = 1.0, channelBw = repcap.ChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth, depending on the channel bandwidth. \n
-			:param obw_limit: Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
+			:param obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check.
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth{channelBw_cmd_val} {param}')
 
 	def get(self, channelBw=repcap.ChannelBw.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth<Band> \n
 		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth, depending on the channel bandwidth. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
-			:return: obw_limit: Range: 0 MHz to 40 MHz, Unit: Hz Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+			:return: obw_limit: (float or boolean) numeric | ON | OFF Range: 0 MHz to 40 MHz, Unit: Hz ON | OFF enables or disables the limit check."""
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth{channelBw_cmd_val}?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,138 +1,154 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Segment:
-	"""Segment commands group definition. 16 total commands, 13 Sub-groups, 0 group commands
+class SegmentCls:
+	"""Segment commands group definition. 18 total commands, 15 Subgroups, 0 group commands
 	Repeated Capability: Segment, default value after init: Segment.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("segment", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.Nr1)
+		self._cmd_group = CommandsGroup("segment", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.Nr1)
 
-	def repcap_segment_set(self, enum_value: repcap.Segment) -> None:
+	def repcap_segment_set(self, segment: repcap.Segment) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Segment.Default
 		Default value after init: Segment.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(segment)
 
 	def repcap_segment_get(self) -> repcap.Segment:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def scc(self):
 		"""scc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scc'):
-			from .Segment_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def cc(self):
 		"""cc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_cc'):
-			from .Segment_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Segment_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	@property
 	def setup(self):
 		"""setup commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_setup'):
-			from .Segment_.Setup import Setup
-			self._setup = Setup(self._core, self._base)
+			from .Setup import SetupCls
+			self._setup = SetupCls(self._core, self._cmd_group)
 		return self._setup
 
 	@property
 	def tdd(self):
 		"""tdd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_tdd'):
-			from .Segment_.Tdd import Tdd
-			self._tdd = Tdd(self._core, self._base)
+			from .Tdd import TddCls
+			self._tdd = TddCls(self._core, self._cmd_group)
 		return self._tdd
 
 	@property
 	def rbAllocation(self):
 		"""rbAllocation commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbAllocation'):
-			from .Segment_.RbAllocation import RbAllocation
-			self._rbAllocation = RbAllocation(self._core, self._base)
+			from .RbAllocation import RbAllocationCls
+			self._rbAllocation = RbAllocationCls(self._core, self._cmd_group)
 		return self._rbAllocation
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_modulation'):
-			from .Segment_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_seMask'):
-			from .Segment_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_aclr'):
-			from .Segment_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def pmonitor(self):
 		"""pmonitor commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pmonitor'):
-			from .Segment_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
 		return self._pmonitor
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_power'):
-			from .Segment_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def emtc(self):
 		"""emtc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_emtc'):
-			from .Segment_.Emtc import Emtc
-			self._emtc = Emtc(self._core, self._base)
+			from .Emtc import EmtcCls
+			self._emtc = EmtcCls(self._core, self._cmd_group)
 		return self._emtc
 
 	@property
+	def plcId(self):
+		"""plcId commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_plcId'):
+			from .PlcId import PlcIdCls
+			self._plcId = PlcIdCls(self._core, self._cmd_group)
+		return self._plcId
+
+	@property
 	def singleCmw(self):
 		"""singleCmw commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_singleCmw'):
-			from .Segment_.SingleCmw import SingleCmw
-			self._singleCmw = SingleCmw(self._core, self._base)
+			from .SingleCmw import SingleCmwCls
+			self._singleCmw = SingleCmwCls(self._core, self._cmd_group)
 		return self._singleCmw
 
-	def clone(self) -> 'Segment':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def cidx(self):
+		"""cidx commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cidx'):
+			from .Cidx import CidxCls
+			self._cidx = CidxCls(self._core, self._cmd_group)
+		return self._cidx
+
+	def clone(self) -> 'SegmentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Segment(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SegmentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,55 +1,62 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
+
+	@property
+	def rbIndex(self):
+		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rbIndex'):
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
+		return self._rbIndex
 
 	# noinspection PyTypeChecker
-	class AclrStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Aclr_Statistics: int: Statistical length in slots Range: 1 to 1000
-			- Aclr_Enable: bool: OFF | ON Enable or disable the measurement of ACLR results ON: ACLR results are measured according to the other enable flags in this command. ACLR results for which there is no explicit enable flag are also measured (e.g. power in assigned E-UTRA channel) . OFF: No ACLR results at all are measured. The other enable flags in this command are ignored.
-			- Utra_1_Enable: bool: OFF | ON Enable or disable evaluation of first adjacent UTRA channels
-			- Utra_2_Enable: bool: OFF | ON Enable or disable evaluation of second adjacent UTRA channels
-			- Eutra_Enable: bool: OFF | ON Enable or disable evaluation of first adjacent E-UTRA channels"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Margin: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Aclr_Statistics'),
-			ArgStruct.scalar_bool('Aclr_Enable'),
-			ArgStruct.scalar_bool('Utra_1_Enable'),
-			ArgStruct.scalar_bool('Utra_2_Enable'),
-			ArgStruct.scalar_bool('Eutra_Enable')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Aclr_Statistics: int = None
-			self.Aclr_Enable: bool = None
-			self.Utra_1_Enable: bool = None
-			self.Utra_2_Enable: bool = None
-			self.Eutra_Enable: bool = None
-
-	def set(self, structure: AclrStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR \n
-		Snippet: driver.configure.multiEval.listPy.segment.aclr.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines settings for ACLR measurements in list mode for segment <no>. \n
-			:param structure: for set value, see the help for AclrStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> AclrStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR \n
-		Snippet: value: AclrStruct = driver.configure.multiEval.listPy.segment.aclr.get(segment = repcap.Segment.Default) \n
-		Defines settings for ACLR measurements in list mode for segment <no>. \n
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Margin: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.current.fetch(segment = repcap.Segment.Default) \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for AclrStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR?', self.__class__.AclrStruct())
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def acSpacing(self):
 		"""acSpacing commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_acSpacing'):
-			from .CarrierAggregation_.AcSpacing import AcSpacing
-			self._acSpacing = AcSpacing(self._core, self._base)
+			from .AcSpacing import AcSpacingCls
+			self._acSpacing = AcSpacingCls(self._core, self._cmd_group)
 		return self._acSpacing
 
 	@property
 	def mcarrier(self):
 		"""mcarrier commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_mcarrier'):
-			from .CarrierAggregation_.Mcarrier import Mcarrier
-			self._mcarrier = Mcarrier(self._core, self._base)
+			from .Mcarrier import McarrierCls
+			self._mcarrier = McarrierCls(self._core, self._cmd_group)
 		return self._mcarrier
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/AcSpacing.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/AcSpacing.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,29 +1,31 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AcSpacing:
-	"""AcSpacing commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AcSpacingCls:
+	"""AcSpacing commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("acSpacing", core, parent)
+		self._cmd_group = CommandsGroup("acSpacing", core, parent)
 
 	def set(self, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:ACSPacing \n
 		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.acSpacing.set(segment = repcap.Segment.Default) \n
 		Adjusts the component carrier frequencies in segment <no>, so that the carriers are aggregated contiguously. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:ACSPacing')
 
-	def set_with_opc(self, segment=repcap.Segment.Default) -> None:
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+	def set_with_opc(self, segment=repcap.Segment.Default, opc_timeout_ms: int = -1) -> None:
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:ACSPacing \n
 		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.acSpacing.set_with_opc(segment = repcap.Segment.Default) \n
 		Adjusts the component carrier frequencies in segment <no>, so that the carriers are aggregated contiguously. \n
 		Same as set, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:ACSPacing')
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:ACSPacing', opc_timeout_ms)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,52 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from ....... import enums
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........ import enums
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mcarrier:
-	"""Mcarrier commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class McarrierCls:
+	"""Mcarrier commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mcarrier", core, parent)
+		self._cmd_group = CommandsGroup("mcarrier", core, parent)
 
 	@property
 	def enhanced(self):
 		"""enhanced commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_enhanced'):
-			from .Mcarrier_.Enhanced import Enhanced
-			self._enhanced = Enhanced(self._core, self._base)
+			from .Enhanced import EnhancedCls
+			self._enhanced = EnhancedCls(self._core, self._cmd_group)
 		return self._enhanced
 
 	def set(self, meas_carrier: enums.MeasCarrier, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier \n
 		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.set(meas_carrier = enums.MeasCarrier.PCC, segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param meas_carrier: No help available
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrier)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.MeasCarrier:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier \n
 		Snippet: value: enums.MeasCarrier = driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.get(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: meas_carrier: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasCarrier)
 
-	def clone(self) -> 'Mcarrier':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'McarrierCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mcarrier(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = McarrierCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/Enhanced.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/Enhanced.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,34 +2,35 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal import Conversions
 from ........ import enums
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Enhanced:
-	"""Enhanced commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EnhancedCls:
+	"""Enhanced commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("enhanced", core, parent)
+		self._cmd_group = CommandsGroup("enhanced", core, parent)
 
 	def set(self, meas_carrier: enums.MeasCarrierEnhanced, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier:ENHanced \n
 		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.enhanced.set(meas_carrier = enums.MeasCarrierEnhanced.CC1, segment = repcap.Segment.Default) \n
 		Selects a component carrier for single-carrier measurements in segment <no>. \n
 			:param meas_carrier: CC1 | CC2 | CC3 | CC4
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrierEnhanced)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier:ENHanced {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.MeasCarrierEnhanced:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier:ENHanced \n
 		Snippet: value: enums.MeasCarrierEnhanced = driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.enhanced.get(segment = repcap.Segment.Default) \n
 		Selects a component carrier for single-carrier measurements in segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: meas_carrier: CC1 | CC2 | CC3 | CC4"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier:ENHanced?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasCarrierEnhanced)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Cc.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,77 +1,81 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, frequency: float, ch_bandwidth: enums.ChannelBandwidth, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CC<c> \n
+		Snippet: driver.configure.multiEval.listPy.segment.cc.set(frequency = 1.0, ch_bandwidth = enums.ChannelBandwidth.B014, segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Defines carrier-specific analyzer settings for component carrier CC<c>, in segment <no>. This command is only relevant
+		for carrier aggregation. \n
+			:param frequency: numeric Center frequency of the component carrier, used in the segment For the supported range, see 'Frequency ranges'. Unit: Hz
+			:param ch_bandwidth: B014 | B030 | B050 | B100 | B150 | B200 Channel bandwidth of the component carrier, used in the segment B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('frequency', frequency, DataType.Float), ArgSingle('ch_bandwidth', ch_bandwidth, DataType.Enum, enums.ChannelBandwidth))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CC{carrierComponent_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class CcStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Frequency: float: Center frequency of the component carrier, used in the segment Range: 70 MHz to 6 GHz, Unit: Hz
+		"""Response structure. Fields: \n
+			- Frequency: float: numeric Center frequency of the component carrier, used in the segment For the supported range, see 'Frequency ranges'. Unit: Hz
 			- Ch_Bandwidth: enums.ChannelBandwidth: B014 | B030 | B050 | B100 | B150 | B200 Channel bandwidth of the component carrier, used in the segment B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Ch_Bandwidth', enums.ChannelBandwidth)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Frequency: float = None
 			self.Ch_Bandwidth: enums.ChannelBandwidth = None
 
-	def set(self, structure: CcStruct, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CC<c> \n
-		Snippet: driver.configure.multiEval.listPy.segment.cc.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Defines carrier-specific analyzer settings for component carrier CC<c>, in segment <no>. This command is only relevant
-		for carrier aggregation. The supported frequency range depends on the instrument model and the available options.
-		The supported range can be smaller than stated here. Refer to the preface of your model-specific base unit manual. \n
-			:param structure: for set value, see the help for CcStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CC{carrierComponent_cmd_val}', structure)
-
 	def get(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> CcStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CC<c> \n
 		Snippet: value: CcStruct = driver.configure.multiEval.listPy.segment.cc.get(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Defines carrier-specific analyzer settings for component carrier CC<c>, in segment <no>. This command is only relevant
-		for carrier aggregation. The supported frequency range depends on the instrument model and the available options.
-		The supported range can be smaller than stated here. Refer to the preface of your model-specific base unit manual. \n
+		for carrier aggregation. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for CcStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CC{carrierComponent_cmd_val}?', self.__class__.CcStruct())
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Emtc:
-	"""Emtc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class RbaTableCls:
+	"""RbaTable commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("emtc", core, parent)
+		self._cmd_group = CommandsGroup("rbaTable", core, parent)
 
 	@property
-	def nband(self):
-		"""nband commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_nband'):
-			from .Emtc_.Nband import Nband
-			self._nband = Nband(self._core, self._base)
-		return self._nband
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	def clone(self) -> 'Emtc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbaTableCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Emtc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbaTableCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/Nband.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/Nband.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nband:
-	"""Nband commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NbandCls:
+	"""Nband commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nband", core, parent)
+		self._cmd_group = CommandsGroup("nband", core, parent)
 
 	def set(self, number: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:EMTC:NBANd \n
 		Snippet: driver.configure.multiEval.listPy.segment.emtc.nband.set(number = 1, segment = repcap.Segment.Default) \n
 		Selects the eMTC narrowband for segment <no>. \n
-			:param number: The maximum depends on the channel BW, see 'eMTC narrowbands'. Range: 0 to 15
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param number: numeric The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'. Range: 0 to 15
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(number)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:EMTC:NBANd {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:EMTC:NBANd \n
 		Snippet: value: int = driver.configure.multiEval.listPy.segment.emtc.nband.get(segment = repcap.Segment.Default) \n
 		Selects the eMTC narrowband for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: number: The maximum depends on the channel BW, see 'eMTC narrowbands'. Range: 0 to 15"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: number: numeric The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'. Range: 0 to 15"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:EMTC:NBANd?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Modulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Modulation.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,32 +3,32 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class ModulationStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
-			- Mod_Statistics: int: Statistical length in slots Range: 1 to 1000
-			- Modenable: bool: OFF | ON Enable or disable the measurement of modulation results ON: Modulation results are measured according to the other enable flags in this command. Modulation results for which there is no explicit enable flag are also measured (e.g. I/Q offset, frequency error and timing error) . OFF: No modulation results at all are measured. The other enable flags in this command are ignored.
-			- Evm_Enable: bool: OFF | ON Enable or disable measurement of EVM
-			- Mag_Error_Enable: bool: OFF | ON Enable or disable measurement of magnitude error
-			- Phase_Err_Enable: bool: OFF | ON Enable or disable measurement of phase error
-			- Ib_Eenable: bool: OFF | ON Enable or disable measurement of inband emissions
-			- Eq_Sp_Flat_Enable: bool: OFF | ON Enable or disable measurement of equalizer spectrum flatness results
-			- Mod_Scheme: enums.ModScheme: AUTO | QPSK | Q16 | Q64 | Q256 Modulation scheme used by the LTE uplink signal AUTO: automatic detection QPSK: QPSK Q16: 16-QAM Q64: 64-QAM Q256: 256-QAM"""
+			- Mod_Statistics: int: integer Statistical length in slots. Range: 1 to 1000
+			- Modenable: bool: OFF | ON Enable or disable the measurement of modulation results. ON: Modulation results are measured according to the other enable flags in this command. Modulation results for which there is no explicit enable flag are also measured (e.g. I/Q offset, frequency error and timing error) . OFF: No modulation results at all are measured. The other enable flags in this command are ignored.
+			- Evm_Enable: bool: OFF | ON Enable or disable measurement of EVM.
+			- Mag_Error_Enable: bool: OFF | ON Enable or disable measurement of magnitude error.
+			- Phase_Err_Enable: bool: OFF | ON Enable or disable measurement of phase error.
+			- Ib_Eenable: bool: OFF | ON Enable or disable measurement of inband emissions.
+			- Eq_Sp_Flat_Enable: bool: OFF | ON Enable or disable measurement of equalizer spectrum flatness results.
+			- Mod_Scheme: enums.ModScheme: AUTO | QPSK | Q16 | Q64 | Q256 Modulation scheme used by the LTE uplink signal. AUTO: automatic detection QPSK: QPSK Q16: 16-QAM Q64: 64-QAM Q256: 256-QAM"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Mod_Statistics'),
 			ArgStruct.scalar_bool('Modenable'),
 			ArgStruct.scalar_bool('Evm_Enable'),
 			ArgStruct.scalar_bool('Mag_Error_Enable'),
 			ArgStruct.scalar_bool('Phase_Err_Enable'),
 			ArgStruct.scalar_bool('Ib_Eenable'),
@@ -44,22 +44,33 @@
 			self.Phase_Err_Enable: bool = None
 			self.Ib_Eenable: bool = None
 			self.Eq_Sp_Flat_Enable: bool = None
 			self.Mod_Scheme: enums.ModScheme = None
 
 	def set(self, structure: ModulationStruct, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation \n
-		Snippet: driver.configure.multiEval.listPy.segment.modulation.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.listPy.segment.modulation.ModulationStruct() \n
+		structure.Mod_Statistics: int = 1 \n
+		structure.Modenable: bool = False \n
+		structure.Evm_Enable: bool = False \n
+		structure.Mag_Error_Enable: bool = False \n
+		structure.Phase_Err_Enable: bool = False \n
+		structure.Ib_Eenable: bool = False \n
+		structure.Eq_Sp_Flat_Enable: bool = False \n
+		structure.Mod_Scheme: enums.ModScheme = enums.ModScheme.AUTO \n
+		driver.configure.multiEval.listPy.segment.modulation.set(structure, segment = repcap.Segment.Default) \n
 		Defines settings for modulation measurements in list mode for segment <no>. \n
 			:param structure: for set value, see the help for ModulationStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation', structure)
 
 	def get(self, segment=repcap.Segment.Default) -> ModulationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation \n
 		Snippet: value: ModulationStruct = driver.configure.multiEval.listPy.segment.modulation.get(segment = repcap.Segment.Default) \n
 		Defines settings for modulation measurements in list mode for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for ModulationStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation?', self.__class__.ModulationStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Pmonitor.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Pmonitor.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	def set(self, enable: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor \n
 		Snippet: driver.configure.multiEval.listPy.segment.pmonitor.set(enable = False, segment = repcap.Segment.Default) \n
 		Enables or disables the measurement of power monitor results (power of one carrier) for segment <no>. \n
 			:param enable: OFF | ON
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(enable)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor \n
 		Snippet: value: bool = driver.configure.multiEval.listPy.segment.pmonitor.get(segment = repcap.Segment.Default) \n
 		Enables or disables the measurement of power monitor results (power of one carrier) for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: enable: OFF | ON"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Power.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Power.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,46 +1,52 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowerCls:
+	"""Power commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
+
+	def set(self, power_statistics: int, power_enable: bool, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
+		Snippet: driver.configure.multiEval.listPy.segment.power.set(power_statistics = 1, power_enable = False, segment = repcap.Segment.Default) \n
+		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
+			:param power_statistics: integer Statistical length in subframes Range: 1 to 1000
+			:param power_enable: OFF | ON Enables or disables the measurement of the total TX power.
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('power_statistics', power_statistics, DataType.Integer), ArgSingle('power_enable', power_enable, DataType.Boolean))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class PowerStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Power_Statistics: int: Statistical length in subframes Range: 1 to 1000
-			- Power_Enable: bool: OFF | ON Enables or disables the measurement of the total TX power"""
+		"""Response structure. Fields: \n
+			- Power_Statistics: int: integer Statistical length in subframes Range: 1 to 1000
+			- Power_Enable: bool: OFF | ON Enables or disables the measurement of the total TX power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Power_Statistics'),
 			ArgStruct.scalar_bool('Power_Enable')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Power_Statistics: int = None
 			self.Power_Enable: bool = None
 
-	def set(self, structure: PowerStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
-		Snippet: driver.configure.multiEval.listPy.segment.power.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
-			:param structure: for set value, see the help for PowerStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer', structure)
-
 	def get(self, segment=repcap.Segment.Default) -> PowerStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
 		Snippet: value: PowerStruct = driver.configure.multiEval.listPy.segment.power.get(segment = repcap.Segment.Default) \n
 		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for PowerStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer?', self.__class__.PowerStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/Sidelink.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,67 +1,62 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbAllocation:
-	"""RbAllocation commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class SidelinkCls:
+	"""Sidelink commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbAllocation", core, parent)
+		self._cmd_group = CommandsGroup("sidelink", core, parent)
 
-	@property
-	def sidelink(self):
-		"""sidelink commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_sidelink'):
-			from .RbAllocation_.Sidelink import Sidelink
-			self._sidelink = Sidelink(self._core, self._base)
-		return self._sidelink
+	def set(self, auto: bool, no_rb_pssch: int, offset_pssch: int, offset_pscch: int, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation:SIDelink \n
+		Snippet: driver.configure.multiEval.listPy.segment.rbAllocation.sidelink.set(auto = False, no_rb_pssch = 1, offset_pssch = 1, offset_pscch = 1, segment = repcap.Segment.Default) \n
+		Allows you to define the sidelink resource block allocation manually for segment <no>. By default, the RB allocation is
+		detected automatically. Most allowed input ranges depend on other settings, see 'Sidelink resource block allocation'. \n
+			:param auto: OFF | ON OFF: manual definition via the other settings ON: automatic detection of RB allocation
+			:param no_rb_pssch: integer Number of allocated RBs for the PSSCH in each measured slot
+			:param offset_pssch: integer Offset of the first allocated PSSCH resource block
+			:param offset_pscch: integer Offset of the first allocated PSCCH resource block
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('auto', auto, DataType.Boolean), ArgSingle('no_rb_pssch', no_rb_pssch, DataType.Integer), ArgSingle('offset_pssch', offset_pssch, DataType.Integer), ArgSingle('offset_pscch', offset_pscch, DataType.Integer))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation:SIDelink {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class RbAllocationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Auto: bool: OFF | ON OFF: manual definition via NoRB and Offset ON: automatic detection of RB allocation
-			- No_Rb: int: Number of allocated resource blocks in each measured slot Range: see table below
-			- Offset: int: Offset of first allocated resource block from edge of allocated UL transmission bandwidth Range: 0 to max(NoRB) - NoRB"""
+	class SidelinkStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Auto: bool: OFF | ON OFF: manual definition via the other settings ON: automatic detection of RB allocation
+			- No_Rb_Pssch: int: integer Number of allocated RBs for the PSSCH in each measured slot
+			- Offset_Pssch: int: integer Offset of the first allocated PSSCH resource block
+			- Offset_Pscch: int: integer Offset of the first allocated PSCCH resource block"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Auto'),
-			ArgStruct.scalar_int('No_Rb'),
-			ArgStruct.scalar_int('Offset')]
+			ArgStruct.scalar_int('No_Rb_Pssch'),
+			ArgStruct.scalar_int('Offset_Pssch'),
+			ArgStruct.scalar_int('Offset_Pscch')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Auto: bool = None
-			self.No_Rb: int = None
-			self.Offset: int = None
-
-	def set(self, structure: RbAllocationStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
-		Snippet: driver.configure.multiEval.listPy.segment.rbAllocation.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Allows you to define the uplink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. \n
-			:param structure: for set value, see the help for RbAllocationStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> RbAllocationStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
-		Snippet: value: RbAllocationStruct = driver.configure.multiEval.listPy.segment.rbAllocation.get(segment = repcap.Segment.Default) \n
-		Allows you to define the uplink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. \n
+			self.No_Rb_Pssch: int = None
+			self.Offset_Pssch: int = None
+			self.Offset_Pscch: int = None
+
+	def get(self, segment=repcap.Segment.Default) -> SidelinkStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation:SIDelink \n
+		Snippet: value: SidelinkStruct = driver.configure.multiEval.listPy.segment.rbAllocation.sidelink.get(segment = repcap.Segment.Default) \n
+		Allows you to define the sidelink resource block allocation manually for segment <no>. By default, the RB allocation is
+		detected automatically. Most allowed input ranges depend on other settings, see 'Sidelink resource block allocation'. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for RbAllocationStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation?', self.__class__.RbAllocationStruct())
-
-	def clone(self) -> 'RbAllocation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = RbAllocation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+			:return: structure: for return value, see the help for SidelinkStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation:SIDelink?', self.__class__.SidelinkStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/Sidelink.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/RbIndex.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,54 +1,48 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sidelink:
-	"""Sidelink commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sidelink", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
-	class SidelinkStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Auto: bool: OFF | ON OFF: manual definition via the other settings ON: automatic detection of RB allocation
-			- No_Rb_Pssch: int: Number of allocated RBs for the PSSCH in each measured slot
-			- Offset_Pssch: int: Offset of the first allocated PSSCH resource block
-			- Offset_Pscch: int: Offset of the first allocated PSCCH resource block"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Rb_Index: int: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Auto'),
-			ArgStruct.scalar_int('No_Rb_Pssch'),
-			ArgStruct.scalar_int('Offset_Pssch'),
-			ArgStruct.scalar_int('Offset_Pscch')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Auto: bool = None
-			self.No_Rb_Pssch: int = None
-			self.Offset_Pssch: int = None
-			self.Offset_Pscch: int = None
-
-	def set(self, structure: SidelinkStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation:SIDelink \n
-		Snippet: driver.configure.multiEval.listPy.segment.rbAllocation.sidelink.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Allows you to define the sidelink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. Most allowed input ranges depend on other settings, see 'Sidelink Resource Block Allocation'. \n
-			:param structure: for set value, see the help for SidelinkStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation:SIDelink', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> SidelinkStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation:SIDelink \n
-		Snippet: value: SidelinkStruct = driver.configure.multiEval.listPy.segment.rbAllocation.sidelink.get(segment = repcap.Segment.Default) \n
-		Allows you to define the sidelink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. Most allowed input ranges depend on other settings, see 'Sidelink Resource Block Allocation'. \n
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Rb_Index: int = None
+
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for SidelinkStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation:SIDelink?', self.__class__.SidelinkStruct())
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scc.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,73 +1,79 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, frequency: float, ch_bandwidth: enums.ChannelBandwidth, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
+		Snippet: driver.configure.multiEval.listPy.segment.scc.set(frequency = 1.0, ch_bandwidth = enums.ChannelBandwidth.B014, segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
+			:param frequency: No help available
+			:param ch_bandwidth: No help available
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('frequency', frequency, DataType.Float), ArgSingle('ch_bandwidth', ch_bandwidth, DataType.Enum, enums.ChannelBandwidth))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class SccStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Frequency: float: No parameter help available
 			- Ch_Bandwidth: enums.ChannelBandwidth: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Ch_Bandwidth', enums.ChannelBandwidth)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Frequency: float = None
 			self.Ch_Bandwidth: enums.ChannelBandwidth = None
 
-	def set(self, structure: SccStruct, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
-		Snippet: driver.configure.multiEval.listPy.segment.scc.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-			:param structure: for set value, see the help for SccStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val}', structure)
-
 	def get(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> SccStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
 		Snippet: value: SccStruct = driver.configure.multiEval.listPy.segment.scc.get(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for SccStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val}?', self.__class__.SccStruct())
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SeMask.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,52 +1,60 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
+
+	def set(self, sem_statistics: int, se_enable: bool, obw_enable: bool, sem_enable: bool, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask \n
+		Snippet: driver.configure.multiEval.listPy.segment.seMask.set(sem_statistics = 1, se_enable = False, obw_enable = False, sem_enable = False, segment = repcap.Segment.Default) \n
+		Defines settings for spectrum emission measurements in list mode for segment <no>. \n
+			:param sem_statistics: integer Statistical length in slots. Range: 1 to 1000
+			:param se_enable: OFF | ON Enable or disable the measurement of spectrum emission results. ON: Spectrum emission results are measured according to the other enable flags in this command. Results for which there is no explicit enable flag are also measured. OFF: No spectrum emission results at all are measured. The other enable flags in this command are ignored.
+			:param obw_enable: OFF | ON Enable or disable measurement of occupied bandwidth.
+			:param sem_enable: OFF | ON Enable or disable measurement of spectrum emission trace and margin results.
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('sem_statistics', sem_statistics, DataType.Integer), ArgSingle('se_enable', se_enable, DataType.Boolean), ArgSingle('obw_enable', obw_enable, DataType.Boolean), ArgSingle('sem_enable', sem_enable, DataType.Boolean))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class SeMaskStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Sem_Statistics: int: Statistical length in slots Range: 1 to 1000
-			- Se_Enable: bool: OFF | ON Enable or disable the measurement of spectrum emission results ON: Spectrum emission results are measured according to the other enable flags in this command. Results for which there is no explicit enable flag are also measured. OFF: No spectrum emission results at all are measured. The other enable flags in this command are ignored.
-			- Obw_Enable: bool: OFF | ON Enable or disable measurement of occupied bandwidth
-			- Sem_Enable: bool: OFF | ON Enable or disable measurement of spectrum emission trace and margin results"""
+		"""Response structure. Fields: \n
+			- Sem_Statistics: int: integer Statistical length in slots. Range: 1 to 1000
+			- Se_Enable: bool: OFF | ON Enable or disable the measurement of spectrum emission results. ON: Spectrum emission results are measured according to the other enable flags in this command. Results for which there is no explicit enable flag are also measured. OFF: No spectrum emission results at all are measured. The other enable flags in this command are ignored.
+			- Obw_Enable: bool: OFF | ON Enable or disable measurement of occupied bandwidth.
+			- Sem_Enable: bool: OFF | ON Enable or disable measurement of spectrum emission trace and margin results."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Sem_Statistics'),
 			ArgStruct.scalar_bool('Se_Enable'),
 			ArgStruct.scalar_bool('Obw_Enable'),
 			ArgStruct.scalar_bool('Sem_Enable')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Sem_Statistics: int = None
 			self.Se_Enable: bool = None
 			self.Obw_Enable: bool = None
 			self.Sem_Enable: bool = None
 
-	def set(self, structure: SeMaskStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask \n
-		Snippet: driver.configure.multiEval.listPy.segment.seMask.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines settings for spectrum emission measurements in list mode for segment <no>. \n
-			:param structure: for set value, see the help for SeMaskStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask', structure)
-
 	def get(self, segment=repcap.Segment.Default) -> SeMaskStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask \n
 		Snippet: value: SeMaskStruct = driver.configure.multiEval.listPy.segment.seMask.get(segment = repcap.Segment.Default) \n
 		Defines settings for spectrum emission measurements in list mode for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for SeMaskStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask?', self.__class__.SeMaskStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,47 +3,47 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Setup:
-	"""Setup commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SetupCls:
+	"""Setup commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("setup", core, parent)
+		self._cmd_group = CommandsGroup("setup", core, parent)
 
 	# noinspection PyTypeChecker
 	class SetupStruct(StructBase):
 		"""Structure for setting input parameters. Contains optional setting parameters. Fields: \n
-			- Segment_Length: int: Number of subframes in the segment Range: 1 to 2000
-			- Level: float: Expected nominal power in the segment. The range can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+			- Segment_Length: int: integer Number of subframes in the segment Range: 1 to 2000
+			- Level: float: numeric Expected nominal power in the segment. The range can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 			- Duplex_Mode: enums.DuplexMode: FDD | TDD Duplex mode used in the segment
-			- Band: enums.Band: FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85 TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB52 | OB250 Sidelink: OB47 Operating band used in the segment
-			- Frequency: float: Center frequency of CC1 used in the segment Range: 70 MHz to 6 GHz, Unit: Hz
+			- Band: enums.Band: FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85 | OB87 | OB88 TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB53 | OB250 Sidelink: OB47 Operating band used in the segment
+			- Frequency: float: numeric Center frequency of CC1 used in the segment For the supported range, see 'Frequency ranges'. Unit: Hz
 			- Ch_Bandwidth: enums.ChannelBandwidth: B014 | B030 | B050 | B100 | B150 | B200 Channel bandwidth of CC1 used in the segment B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz
 			- Cyclic_Prefix: enums.CyclicPrefix: NORMal | EXTended Type of cyclic prefix used in the segment
 			- Channel_Type: enums.SegmentChannelTypeExtended: AUTO | PUSCh | PUCCh | PSSCh | PSCCh Channel type to be measured in the segment (AUTO for automatic detection) Uplink: AUTO, PUSCh, PUCCh Sidelink: PSSCh, PSCCh
-			- Retrigger_Flag: enums.RetriggerFlag: OFF | ON | IFPower Specifies whether the measurement waits for a trigger event before measuring the segment, or not. For the first segment, the value OFF is always interpreted as ON. For subsequent segments, the retrigger flag is ignored for trigger mode ONCE and evaluated for trigger mode SEGMent, see [CMDLINK: TRIGger:LTE:MEASi:MEValuation:LIST:MODE CMDLINK]. OFF: measure the segment without retrigger ON: wait for a trigger event from the trigger source configured via [CMDLINK: TRIGger:LTE:MEASi:MEValuation:SOURce CMDLINK] IFPower: wait for a trigger event from the trigger source 'IF Power'
-			- Evaluat_Offset: int: Number of subframes at the beginning of the segment that are not evaluated Range: 0 to 1000
+			- Retrigger_Flag: enums.RetriggerFlag: OFF | ON | IFPower | IFPNarrow Specifies whether the measurement waits for a trigger event before measuring the segment, or not. The retrigger flag is ignored for trigger mode ONCE and evaluated for trigger mode SEGMent, see [CMDLINKRESOLVED Trigger.MultiEval.ListPy#Mode CMDLINKRESOLVED]. OFF Measure the segment without retrigger. For the first segment, the value OFF is interpreted as ON. ON Wait for a trigger event from the trigger source configured via [CMDLINKRESOLVED Trigger.MultiEval#Source CMDLINKRESOLVED]. IFPower Wait for a trigger event from the trigger source 'IF Power'. The trigger evaluation bandwidth is 160 MHz. IFPNarrowband Wait for a trigger event from the trigger source 'IF Power'. The trigger evaluation bandwidth is configured via [CMDLINKRESOLVED Trigger.MultiEval.ListPy#Nbandwidth CMDLINKRESOLVED].
+			- Evaluat_Offset: int: integer Number of subframes at the beginning of the segment that are not evaluated Range: 0 to 1000
 			- Network_Sig_Value: enums.NetworkSigValueNoCarrAggr: Optional setting parameter. NS01 | ... | NS288 Network signaled value to be used for the segment"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Segment_Length'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Duplex_Mode', enums.DuplexMode),
 			ArgStruct.scalar_enum('Band', enums.Band),
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Ch_Bandwidth', enums.ChannelBandwidth),
 			ArgStruct.scalar_enum('Cyclic_Prefix', enums.CyclicPrefix),
 			ArgStruct.scalar_enum('Channel_Type', enums.SegmentChannelTypeExtended),
 			ArgStruct.scalar_enum('Retrigger_Flag', enums.RetriggerFlag),
 			ArgStruct.scalar_int('Evaluat_Offset'),
-			ArgStruct.scalar_enum('Network_Sig_Value', enums.NetworkSigValueNoCarrAggr)]
+			ArgStruct.scalar_enum_optional('Network_Sig_Value', enums.NetworkSigValueNoCarrAggr)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Segment_Length: int = None
 			self.Level: float = None
 			self.Duplex_Mode: enums.DuplexMode = None
 			self.Band: enums.Band = None
@@ -53,32 +53,42 @@
 			self.Channel_Type: enums.SegmentChannelTypeExtended = None
 			self.Retrigger_Flag: enums.RetriggerFlag = None
 			self.Evaluat_Offset: int = None
 			self.Network_Sig_Value: enums.NetworkSigValueNoCarrAggr = None
 
 	def set(self, structure: SetupStruct, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SETup \n
-		Snippet: driver.configure.multiEval.listPy.segment.setup.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.listPy.segment.setup.SetupStruct() \n
+		structure.Segment_Length: int = 1 \n
+		structure.Level: float = 1.0 \n
+		structure.Duplex_Mode: enums.DuplexMode = enums.DuplexMode.FDD \n
+		structure.Band: enums.Band = enums.Band.OB1 \n
+		structure.Frequency: float = 1.0 \n
+		structure.Ch_Bandwidth: enums.ChannelBandwidth = enums.ChannelBandwidth.B014 \n
+		structure.Cyclic_Prefix: enums.CyclicPrefix = enums.CyclicPrefix.EXTended \n
+		structure.Channel_Type: enums.SegmentChannelTypeExtended = enums.SegmentChannelTypeExtended.AUTO \n
+		structure.Retrigger_Flag: enums.RetriggerFlag = enums.RetriggerFlag.IFPNarrow \n
+		structure.Evaluat_Offset: int = 1 \n
+		structure.Network_Sig_Value: enums.NetworkSigValueNoCarrAggr = enums.NetworkSigValueNoCarrAggr.NS01 \n
+		driver.configure.multiEval.listPy.segment.setup.set(structure, segment = repcap.Segment.Default) \n
 		Defines the length and analyzer settings of segment <no>. This command must be sent for all segments to be measured
-		(method RsCmwLteMeas.Configure.MultiEval.ListPy.lrange) . For uplink signals with TDD mode, see also method RsCmwLteMeas.
-		Configure.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation,
-		see CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. The supported frequency range depends on the instrument
-		model and the available options. The supported range can be smaller than stated here. Refer to the preface of your
-		model-specific base unit manual. \n
+		(method RsCmwLteMeas.Configure.MultiEval.ListPy.Lrange.set) . For uplink signals with TDD mode, see also method
+		RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation, see
+		CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. \n
 			:param structure: for set value, see the help for SetupStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup', structure)
 
 	def get(self, segment=repcap.Segment.Default) -> SetupStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SETup \n
 		Snippet: value: SetupStruct = driver.configure.multiEval.listPy.segment.setup.get(segment = repcap.Segment.Default) \n
 		Defines the length and analyzer settings of segment <no>. This command must be sent for all segments to be measured
-		(method RsCmwLteMeas.Configure.MultiEval.ListPy.lrange) . For uplink signals with TDD mode, see also method RsCmwLteMeas.
-		Configure.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation,
-		see CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. The supported frequency range depends on the instrument
-		model and the available options. The supported range can be smaller than stated here. Refer to the preface of your
-		model-specific base unit manual. \n
+		(method RsCmwLteMeas.Configure.MultiEval.ListPy.Lrange.set) . For uplink signals with TDD mode, see also method
+		RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation, see
+		CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for SetupStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup?', self.__class__.SetupStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SingleCmw:
-	"""SingleCmw commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SingleCmwCls:
+	"""SingleCmw commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("singleCmw", core, parent)
+		self._cmd_group = CommandsGroup("singleCmw", core, parent)
 
 	@property
 	def connector(self):
 		"""connector commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_connector'):
-			from .SingleCmw_.Connector import Connector
-			self._connector = Connector(self._core, self._base)
+			from .Connector import ConnectorCls
+			self._connector = ConnectorCls(self._core, self._cmd_group)
 		return self._connector
 
-	def clone(self) -> 'SingleCmw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SingleCmwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SingleCmw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SingleCmwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/Connector.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/Connector.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,38 +2,35 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal import Conversions
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Connector:
-	"""Connector commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ConnectorCls:
+	"""Connector commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("connector", core, parent)
+		self._cmd_group = CommandsGroup("connector", core, parent)
 
 	def set(self, cmws_connector: enums.CmwsConnector, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CMWS:CONNector \n
 		Snippet: driver.configure.multiEval.listPy.segment.singleCmw.connector.set(cmws_connector = enums.CmwsConnector.R11, segment = repcap.Segment.Default) \n
-		Selects the RF input connector for segment <no> for the connector mode LIST, see method RsCmwLteMeas.Configure.MultiEval.
-		ListPy.SingleCmw.cmode. All segments of a list mode measurement must use connectors of the same bench. For possible
-		connector values, see 'Values for RF Path Selection'. \n
-			:param cmws_connector: Selects the input connector
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+		No command help available \n
+			:param cmws_connector: No help available
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.enum_scalar_to_str(cmws_connector, enums.CmwsConnector)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CMWS:CONNector {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, segment=repcap.Segment.Default) -> enums.CmwsConnector:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CMWS:CONNector \n
 		Snippet: value: enums.CmwsConnector = driver.configure.multiEval.listPy.segment.singleCmw.connector.get(segment = repcap.Segment.Default) \n
-		Selects the RF input connector for segment <no> for the connector mode LIST, see method RsCmwLteMeas.Configure.MultiEval.
-		ListPy.SingleCmw.cmode. All segments of a list mode measurement must use connectors of the same bench. For possible
-		connector values, see 'Values for RF Path Selection'. \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: cmws_connector: Selects the input connector"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: cmws_connector: No help available"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CMWS:CONNector?')
 		return Conversions.str_to_scalar_enum(response, enums.CmwsConnector)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Tdd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Tdd.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,48 +1,54 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Tdd:
-	"""Tdd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TddCls:
+	"""Tdd commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("tdd", core, parent)
+		self._cmd_group = CommandsGroup("tdd", core, parent)
+
+	def set(self, uplink_downlink: int, special_subframe: int, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:TDD \n
+		Snippet: driver.configure.multiEval.listPy.segment.tdd.set(uplink_downlink = 1, special_subframe = 1, segment = repcap.Segment.Default) \n
+		Defines segment settings only relevant for uplink measurements with the duplex mode TDD.
+		For general segment configuration, see method RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.Setup.set. \n
+			:param uplink_downlink: integer UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame Range: 0 to 6
+			:param special_subframe: integer Special subframe configuration, defining the inner structure of special subframes Range: 0 to 8
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('uplink_downlink', uplink_downlink, DataType.Integer), ArgSingle('special_subframe', special_subframe, DataType.Integer))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:TDD {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class TddStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Uplink_Downlink: int: UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame Range: 0 to 6
-			- Special_Subframe: int: Special subframe configuration, defining the inner structure of special subframes Range: 0 to 8"""
+		"""Response structure. Fields: \n
+			- Uplink_Downlink: int: integer UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame Range: 0 to 6
+			- Special_Subframe: int: integer Special subframe configuration, defining the inner structure of special subframes Range: 0 to 8"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Uplink_Downlink'),
 			ArgStruct.scalar_int('Special_Subframe')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Uplink_Downlink: int = None
 			self.Special_Subframe: int = None
 
-	def set(self, structure: TddStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:TDD \n
-		Snippet: driver.configure.multiEval.listPy.segment.tdd.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines segment settings only relevant for uplink measurements with the duplex mode TDD.
-		For general segment configuration, see method RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.Setup.set. \n
-			:param structure: for set value, see the help for TddStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:TDD', structure)
-
 	def get(self, segment=repcap.Segment.Default) -> TddStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:TDD \n
 		Snippet: value: TddStruct = driver.configure.multiEval.listPy.segment.tdd.get(segment = repcap.Segment.Default) \n
 		Defines segment settings only relevant for uplink measurements with the duplex mode TDD.
 		For general segment configuration, see method RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.Setup.set. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for TddStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:TDD?', self.__class__.TddStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/SingleCmw.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SingleCmw:
-	"""SingleCmw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SingleCmwCls:
+	"""SingleCmw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("singleCmw", core, parent)
+		self._cmd_group = CommandsGroup("singleCmw", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_cmode(self) -> enums.ParameterSetMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe \n
 		Snippet: value: enums.ParameterSetMode = driver.configure.multiEval.listPy.singleCmw.get_cmode() \n
-		Specifies how the input connector is selected for LTE list mode measurements with an R&S CMW100 or R&S CMWS. \n
-			:return: connector_mode: GLOBal | LIST GLOBal: The same input connector is used for all segments. It is selected in the same way as without list mode, for example via ROUTe:LTE:MEASi:SCENario:SALone. LIST: The input connector is configured individually for each segment. See method RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.SingleCmw.Connector.set.
+		No command help available \n
+			:return: connector_mode: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.ParameterSetMode)
 
 	def set_cmode(self, connector_mode: enums.ParameterSetMode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe \n
 		Snippet: driver.configure.multiEval.listPy.singleCmw.set_cmode(connector_mode = enums.ParameterSetMode.GLOBal) \n
-		Specifies how the input connector is selected for LTE list mode measurements with an R&S CMW100 or R&S CMWS. \n
-			:param connector_mode: GLOBal | LIST GLOBal: The same input connector is used for all segments. It is selected in the same way as without list mode, for example via ROUTe:LTE:MEASi:SCENario:SALone. LIST: The input connector is configured individually for each segment. See method RsCmwLteMeas.Configure.MultiEval.ListPy.Segment.SingleCmw.Connector.set.
+		No command help available \n
+			:param connector_mode: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(connector_mode, enums.ParameterSetMode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 9 total commands, 3 Sub-groups, 3 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 9 total commands, 3 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def ewLength(self):
 		"""ewLength commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ewLength'):
-			from .Modulation_.EwLength import EwLength
-			self._ewLength = EwLength(self._core, self._base)
+			from .EwLength import EwLengthCls
+			self._ewLength = EwLengthCls(self._core, self._cmd_group)
 		return self._ewLength
 
 	@property
 	def eePeriods(self):
 		"""eePeriods commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_eePeriods'):
-			from .Modulation_.EePeriods import EePeriods
-			self._eePeriods = EePeriods(self._core, self._base)
+			from .EePeriods import EePeriodsCls
+			self._eePeriods = EePeriodsCls(self._core, self._cmd_group)
 		return self._eePeriods
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Modulation_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	def get_equalizer(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EQUalizer \n
 		Snippet: value: bool = driver.configure.multiEval.modulation.get_equalizer() \n
 		Enables or disables the post-FFT equalization step for the measurement of modulation results. \n
 			:return: enable: OFF | ON
@@ -74,28 +74,28 @@
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:MSCHeme {param}')
 
 	# noinspection PyTypeChecker
 	def get_llocation(self) -> enums.LocalOscLocation:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation \n
 		Snippet: value: enums.LocalOscLocation = driver.configure.multiEval.modulation.get_llocation() \n
 		Specifies the UE transmitter architecture (local oscillator location) used for eMTC. \n
-			:return: value: CN | CCB CN: Center of narrowband CCB: Center of cell bandwidth
+			:return: value: CN | CCB CN: Center of narrowband/wideband CCB: Center of channel bandwidth
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation?')
 		return Conversions.str_to_scalar_enum(response, enums.LocalOscLocation)
 
 	def set_llocation(self, value: enums.LocalOscLocation) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation \n
 		Snippet: driver.configure.multiEval.modulation.set_llocation(value = enums.LocalOscLocation.CCB) \n
 		Specifies the UE transmitter architecture (local oscillator location) used for eMTC. \n
-			:param value: CN | CCB CN: Center of narrowband CCB: Center of cell bandwidth
+			:param value: CN | CCB CN: Center of narrowband/wideband CCB: Center of channel bandwidth
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.LocalOscLocation)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation {param}')
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/CarrierAggregation.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_llocation(self) -> enums.CarrAggrLocalOscLocation:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:CAGGregation:LLOCation \n
 		Snippet: value: enums.CarrAggrLocalOscLocation = driver.configure.multiEval.modulation.carrierAggregation.get_llocation() \n
 		Specifies the UE transmitter architecture (local oscillator location) used for contiguous carrier aggregation. \n
 			:return: value: CACB | CECC CACB: Center of aggregated channel bandwidth CECC: Center of each component carrier
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EePeriods:
-	"""EePeriods commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class EePeriodsCls:
+	"""EePeriods commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eePeriods", core, parent)
+		self._cmd_group = CommandsGroup("eePeriods", core, parent)
 
 	@property
 	def pusch(self):
 		"""pusch commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_pusch'):
-			from .EePeriods_.Pusch import Pusch
-			self._pusch = Pusch(self._core, self._base)
+			from .Pusch import PuschCls
+			self._pusch = PuschCls(self._core, self._cmd_group)
 		return self._pusch
 
 	def get_pucch(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUCCh \n
 		Snippet: value: bool = driver.configure.multiEval.modulation.eePeriods.get_pucch() \n
 		Enables or disables EVM exclusion periods for slots with detected channel type 'PUCCH'. If enabled, the first and the
 		last SC-FDMA symbol of each slot is excluded from the calculation of EVM, magnitude error and phase error single value
@@ -39,14 +39,14 @@
 		results. If the last symbol of a slot is already excluded because SRS signals are allowed, the second but last symbol is
 		also excluded. \n
 			:param pucch: OFF | ON
 		"""
 		param = Conversions.bool_to_str(pucch)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUCCh {param}')
 
-	def clone(self) -> 'EePeriods':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EePeriodsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EePeriods(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EePeriodsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/Pusch.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/Pusch.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pusch:
-	"""Pusch commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PuschCls:
+	"""Pusch commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pusch", core, parent)
+		self._cmd_group = CommandsGroup("pusch", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_leading(self) -> enums.LeadingExclPeriod:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LEADing \n
 		Snippet: value: enums.LeadingExclPeriod = driver.configure.multiEval.modulation.eePeriods.pusch.get_leading() \n
 		Specifies an EVM exclusion period at the beginning of a subframe (detected channel type 'PUSCH') . The specified period
 		is excluded from the calculation of EVM, magnitude error and phase error results. \n
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,62 +1,65 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EwLength:
-	"""EwLength commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class EwLengthCls:
+	"""EwLength commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ewLength", core, parent)
+		self._cmd_group = CommandsGroup("ewLength", core, parent)
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .EwLength_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
+	def set(self, length_cp_normal: List[int], length_cp_extended: List[int]) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength \n
+		Snippet: driver.configure.multiEval.modulation.ewLength.set(length_cp_normal = [1, 2, 3], length_cp_extended = [1, 2, 3]) \n
+		Specifies the EVM window length in samples for all channel bandwidths, depending on the cyclic prefix (CP) type. \n
+			:param length_cp_normal: No help available
+			:param length_cp_extended: No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('length_cp_normal', length_cp_normal, DataType.IntegerList, None, False, False, 6), ArgSingle('length_cp_extended', length_cp_extended, DataType.IntegerList, None, False, False, 6))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength {param}'.rstrip())
+
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class EwLengthStruct(StructBase):
+		"""Response structure. Fields: \n
 			- Length_Cp_Normal: List[int]: No parameter help available
 			- Length_Cp_Extended: List[int]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct('Length_Cp_Normal', DataType.IntegerList, None, False, False, 6),
 			ArgStruct('Length_Cp_Extended', DataType.IntegerList, None, False, False, 6)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Length_Cp_Normal: List[int] = None
 			self.Length_Cp_Extended: List[int] = None
 
-	def get_value(self) -> ValueStruct:
+	def get(self) -> EwLengthStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.modulation.ewLength.get_value() \n
+		Snippet: value: EwLengthStruct = driver.configure.multiEval.modulation.ewLength.get() \n
 		Specifies the EVM window length in samples for all channel bandwidths, depending on the cyclic prefix (CP) type. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength \n
-		Snippet: driver.configure.multiEval.modulation.ewLength.set_value(value = ValueStruct()) \n
-		Specifies the EVM window length in samples for all channel bandwidths, depending on the cyclic prefix (CP) type. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength', value)
+			:return: structure: for return value, see the help for EwLengthStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength?', self.__class__.EwLengthStruct())
 
-	def clone(self) -> 'EwLength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EwLengthCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EwLength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EwLengthCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/NsValue.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/NsValue.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,55 +1,55 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class NsValue:
-	"""NsValue commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NsValueCls:
+	"""NsValue commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nsValue", core, parent)
+		self._cmd_group = CommandsGroup("nsValue", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_carrier_aggregation(self) -> enums.NetworkSigValue:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation \n
 		Snippet: value: enums.NetworkSigValue = driver.configure.multiEval.nsValue.get_carrier_aggregation() \n
 		Selects the 'network signaled value' for measurements with carrier aggregation. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CONNection:SCC<c>:ASEMission:CAGGregation. \n
+		use CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:ASEMission:CAGGregation. \n
 			:return: value: NS01 | NS02 | NS03 | NS04 | NS05 | NS06 | NS07 | NS08 | NS09 | NS10 | NS11 | NS12 | NS13 | NS14 | NS15 | NS16 | NS17 | NS18 | NS19 | NS20 | NS21 | NS22 | NS23 | NS24 | NS25 | NS26 | NS27 | NS28 | NS29 | NS30 | NS31 | NS32 Value CA_NS_01 to CA_NS_32
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation?')
 		return Conversions.str_to_scalar_enum(response, enums.NetworkSigValue)
 
 	def set_carrier_aggregation(self, value: enums.NetworkSigValue) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation \n
 		Snippet: driver.configure.multiEval.nsValue.set_carrier_aggregation(value = enums.NetworkSigValue.NS01) \n
 		Selects the 'network signaled value' for measurements with carrier aggregation. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CONNection:SCC<c>:ASEMission:CAGGregation. \n
+		use CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:ASEMission:CAGGregation. \n
 			:param value: NS01 | NS02 | NS03 | NS04 | NS05 | NS06 | NS07 | NS08 | NS09 | NS10 | NS11 | NS12 | NS13 | NS14 | NS15 | NS16 | NS17 | NS18 | NS19 | NS20 | NS21 | NS22 | NS23 | NS24 | NS25 | NS26 | NS27 | NS28 | NS29 | NS30 | NS31 | NS32 Value CA_NS_01 to CA_NS_32
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.NetworkSigValue)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation {param}')
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.NetworkSigValueNoCarrAggr:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue \n
 		Snippet: value: enums.NetworkSigValueNoCarrAggr = driver.configure.multiEval.nsValue.get_value() \n
 		Selects the 'network signaled value' for measurements without carrier aggregation. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CONNection:ASEMission. \n
+		use CONFigure:LTE:SIGN<i>:CONNection:ASEMission. \n
 			:return: value: NS01 | ... | NS288 Value NS_01 to NS_288
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue?')
 		return Conversions.str_to_scalar_enum(response, enums.NetworkSigValueNoCarrAggr)
 
 	def set_value(self, value: enums.NetworkSigValueNoCarrAggr) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue \n
 		Snippet: driver.configure.multiEval.nsValue.set_value(value = enums.NetworkSigValueNoCarrAggr.NS01) \n
 		Selects the 'network signaled value' for measurements without carrier aggregation. For the combined signal path scenario,
-		useCONFigure:LTE:SIGN<i>:CONNection:ASEMission. \n
+		use CONFigure:LTE:SIGN<i>:CONNection:ASEMission. \n
 			:param value: NS01 | ... | NS288 Value NS_01 to NS_288
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.NetworkSigValueNoCarrAggr)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pcc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pcc.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	def get_plc_id(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation[:PCC]:PLCid \n
 		Snippet: value: int = driver.configure.multiEval.pcc.get_plc_id() \n
 		No command help available \n
 			:return: phs_layer_cell_id: No help available
 		"""
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def aeoPower(self):
 		"""aeoPower commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_aeoPower'):
-			from .Pdynamics_.AeoPower import AeoPower
-			self._aeoPower = AeoPower(self._core, self._base)
+			from .AeoPower import AeoPowerCls
+			self._aeoPower = AeoPowerCls(self._core, self._cmd_group)
 		return self._aeoPower
 
 	# noinspection PyTypeChecker
 	def get_tmask(self) -> enums.TimeMask:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:TMASk \n
 		Snippet: value: enums.TimeMask = driver.configure.multiEval.pdynamics.get_tmask() \n
 		Selects the time mask for power dynamics measurements. \n
@@ -35,14 +35,14 @@
 		Snippet: driver.configure.multiEval.pdynamics.set_tmask(time_mask = enums.TimeMask.GOO) \n
 		Selects the time mask for power dynamics measurements. \n
 			:param time_mask: GOO | PPSRs | SBLanking GOO: General ON/OFF time mask PPSRs: PUCCH/PUSCH transmission before and after an SRS SBLanking: SRS blanking time mask
 		"""
 		param = Conversions.enum_scalar_to_str(time_mask, enums.TimeMask)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:TMASk {param}')
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/AeoPower.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/AeoPower.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AeoPower:
-	"""AeoPower commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AeoPowerCls:
+	"""AeoPower commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aeoPower", core, parent)
+		self._cmd_group = CommandsGroup("aeoPower", core, parent)
 
 	def get_leading(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing \n
 		Snippet: value: int = driver.configure.multiEval.pdynamics.aeoPower.get_leading() \n
 		Shifts the beginning of the evaluation period for OFF power measurements. \n
-			:return: leading: Positive values reduce the evaluation period (starts later) . Negative values increase the evaluation period (starts earlier) . Range: -1000 Ts to 1000 Ts, Unit: Ts
+			:return: leading: integer Positive values reduce the evaluation period (starts later) . Negative values increase the evaluation period (starts earlier) . Range: -1000 Ts to 1000 Ts, Unit: Ts
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing?')
 		return Conversions.str_to_int(response)
 
 	def set_leading(self, leading: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing \n
 		Snippet: driver.configure.multiEval.pdynamics.aeoPower.set_leading(leading = 1) \n
 		Shifts the beginning of the evaluation period for OFF power measurements. \n
-			:param leading: Positive values reduce the evaluation period (starts later) . Negative values increase the evaluation period (starts earlier) . Range: -1000 Ts to 1000 Ts, Unit: Ts
+			:param leading: integer Positive values reduce the evaluation period (starts later) . Negative values increase the evaluation period (starts earlier) . Range: -1000 Ts to 1000 Ts, Unit: Ts
 		"""
 		param = Conversions.decimal_value_to_str(leading)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing {param}')
 
 	def get_lagging(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing \n
 		Snippet: value: int = driver.configure.multiEval.pdynamics.aeoPower.get_lagging() \n
 		Shifts the end of the evaluation period for OFF power measurements. \n
-			:return: lagging: Positive values reduce the evaluation period (ends earlier) . Negative values increase the evaluation period (ends later) . Range: -1000 Ts to 1000 Ts, Unit: Ts
+			:return: lagging: integer Positive values reduce the evaluation period (ends earlier) . Negative values increase the evaluation period (ends later) . Range: -1000 Ts to 1000 Ts, Unit: Ts
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing?')
 		return Conversions.str_to_int(response)
 
 	def set_lagging(self, lagging: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing \n
 		Snippet: driver.configure.multiEval.pdynamics.aeoPower.set_lagging(lagging = 1) \n
 		Shifts the end of the evaluation period for OFF power measurements. \n
-			:param lagging: Positive values reduce the evaluation period (ends earlier) . Negative values increase the evaluation period (ends later) . Range: -1000 Ts to 1000 Ts, Unit: Ts
+			:param lagging: integer Positive values reduce the evaluation period (ends earlier) . Negative values increase the evaluation period (ends later) . Range: -1000 Ts to 1000 Ts, Unit: Ts
 		"""
 		param = Conversions.decimal_value_to_str(lagging)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Power.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Power.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowerCls:
+	"""Power commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	def get_hdmode(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:POWer:HDMode \n
 		Snippet: value: bool = driver.configure.multiEval.power.get_hdmode() \n
 		Enables or disables the high dynamic mode for power dynamics measurements. \n
 			:return: high_dynamic_mode: OFF | ON
 		"""
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbAllocation:
-	"""RbAllocation commands group definition. 10 total commands, 3 Sub-groups, 1 group commands"""
+class RbAllocationCls:
+	"""RbAllocation commands group definition. 10 total commands, 3 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbAllocation", core, parent)
+		self._cmd_group = CommandsGroup("rbAllocation", core, parent)
 
 	@property
 	def nrb(self):
 		"""nrb commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_nrb'):
-			from .RbAllocation_.Nrb import Nrb
-			self._nrb = Nrb(self._core, self._base)
+			from .Nrb import NrbCls
+			self._nrb = NrbCls(self._core, self._cmd_group)
 		return self._nrb
 
 	@property
 	def mcluster(self):
 		"""mcluster commands group. 2 Sub-classes, 1 commands."""
 		if not hasattr(self, '_mcluster'):
-			from .RbAllocation_.Mcluster import Mcluster
-			self._mcluster = Mcluster(self._core, self._base)
+			from .Mcluster import MclusterCls
+			self._mcluster = MclusterCls(self._core, self._cmd_group)
 		return self._mcluster
 
 	@property
 	def orb(self):
 		"""orb commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_orb'):
-			from .RbAllocation_.Orb import Orb
-			self._orb = Orb(self._core, self._base)
+			from .Orb import OrbCls
+			self._orb = OrbCls(self._core, self._cmd_group)
 		return self._orb
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:AUTO \n
 		Snippet: value: bool = driver.configure.multiEval.rbAllocation.get_auto() \n
 		Enables or disables the automatic detection of the RB configuration. \n
 			:return: auto: OFF | ON OFF: manual definition ON: automatic detection
@@ -49,14 +49,14 @@
 		Snippet: driver.configure.multiEval.rbAllocation.set_auto(auto = False) \n
 		Enables or disables the automatic detection of the RB configuration. \n
 			:param auto: OFF | ON OFF: manual definition ON: automatic detection
 		"""
 		param = Conversions.bool_to_str(auto)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:AUTO {param}')
 
-	def clone(self) -> 'RbAllocation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbAllocationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RbAllocation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbAllocationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mcluster:
-	"""Mcluster commands group definition. 3 total commands, 2 Sub-groups, 1 group commands"""
+class MclusterCls:
+	"""Mcluster commands group definition. 3 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mcluster", core, parent)
+		self._cmd_group = CommandsGroup("mcluster", core, parent)
 
 	@property
 	def nrb(self):
 		"""nrb commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_nrb'):
-			from .Mcluster_.Nrb import Nrb
-			self._nrb = Nrb(self._core, self._base)
+			from .Nrb import NrbCls
+			self._nrb = NrbCls(self._core, self._cmd_group)
 		return self._nrb
 
 	@property
 	def orb(self):
 		"""orb commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_orb'):
-			from .Mcluster_.Orb import Orb
-			self._orb = Orb(self._core, self._base)
+			from .Orb import OrbCls
+			self._orb = OrbCls(self._core, self._cmd_group)
 		return self._orb
 
 	def get_value(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster \n
 		Snippet: value: bool = driver.configure.multiEval.rbAllocation.mcluster.get_value() \n
 		Specifies whether the UL signal uses multi-cluster allocation or not.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:MCLuster:UL \n
 			:return: enable: OFF | ON OFF: contiguous allocation, resource allocation type 0 ON: multi-cluster allocation, resource allocation type 1
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster?')
 		return Conversions.str_to_bool(response)
 
 	def set_value(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster \n
 		Snippet: driver.configure.multiEval.rbAllocation.mcluster.set_value(enable = False) \n
 		Specifies whether the UL signal uses multi-cluster allocation or not.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:MCLuster:UL \n
 			:param enable: OFF | ON OFF: contiguous allocation, resource allocation type 0 ON: multi-cluster allocation, resource allocation type 1
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster {param}')
 
-	def clone(self) -> 'Mcluster':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MclusterCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mcluster(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MclusterCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Nrb.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/Nrb.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,64 +2,65 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nrb:
-	"""Nrb commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class NrbCls:
+	"""Nrb commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: RBcount, default value after init: RBcount.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nrb", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_rBcount_get', 'repcap_rBcount_set', repcap.RBcount.Nr1)
+		self._cmd_group = CommandsGroup("nrb", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_rBcount_get', 'repcap_rBcount_set', repcap.RBcount.Nr1)
 
-	def repcap_rBcount_set(self, enum_value: repcap.RBcount) -> None:
+	def repcap_rBcount_set(self, rBcount: repcap.RBcount) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBcount.Default
 		Default value after init: RBcount.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(rBcount)
 
 	def repcap_rBcount_get(self) -> repcap.RBcount:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, no_rb: int, rBcount=repcap.RBcount.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB<Number> \n
 		Snippet: driver.configure.multiEval.rbAllocation.mcluster.nrb.set(no_rb = 1, rBcount = repcap.RBcount.Default) \n
 		Specifies the number of allocated RBs in the measured slot, for multi-cluster allocation.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:RMC:MCLuster:UL
-			- CONFigure:LTE:SIGN<i>:UDCHannels:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:RMC:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:UDCHannels:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:RMC:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:UDCHannels:MCLuster:UL \n
-			:param no_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'.
-			:param rBcount: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Nrb')"""
+			:param no_rb: numeric For the allowed input ranges, see 'Uplink resource block allocation'.
+			:param rBcount: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Nrb')
+		"""
 		param = Conversions.decimal_value_to_str(no_rb)
-		rBcount_cmd_val = self._base.get_repcap_cmd_value(rBcount, repcap.RBcount)
+		rBcount_cmd_val = self._cmd_group.get_repcap_cmd_value(rBcount, repcap.RBcount)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB{rBcount_cmd_val} {param}')
 
 	def get(self, rBcount=repcap.RBcount.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB<Number> \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.mcluster.nrb.get(rBcount = repcap.RBcount.Default) \n
 		Specifies the number of allocated RBs in the measured slot, for multi-cluster allocation.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:RMC:MCLuster:UL
-			- CONFigure:LTE:SIGN<i>:UDCHannels:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:RMC:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:UDCHannels:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:RMC:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:UDCHannels:MCLuster:UL \n
 			:param rBcount: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Nrb')
-			:return: no_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'."""
-		rBcount_cmd_val = self._base.get_repcap_cmd_value(rBcount, repcap.RBcount)
+			:return: no_rb: numeric For the allowed input ranges, see 'Uplink resource block allocation'."""
+		rBcount_cmd_val = self._cmd_group.get_repcap_cmd_value(rBcount, repcap.RBcount)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB{rBcount_cmd_val}?')
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Nrb':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NrbCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Nrb(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NrbCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Orb.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/Orb.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,64 +2,65 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Orb:
-	"""Orb commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class OrbCls:
+	"""Orb commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: RBoffset, default value after init: RBoffset.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("orb", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_rBoffset_get', 'repcap_rBoffset_set', repcap.RBoffset.Nr1)
+		self._cmd_group = CommandsGroup("orb", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_rBoffset_get', 'repcap_rBoffset_set', repcap.RBoffset.Nr1)
 
-	def repcap_rBoffset_set(self, enum_value: repcap.RBoffset) -> None:
+	def repcap_rBoffset_set(self, rBoffset: repcap.RBoffset) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBoffset.Default
 		Default value after init: RBoffset.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(rBoffset)
 
 	def repcap_rBoffset_get(self) -> repcap.RBoffset:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, offset_rb: int, rBoffset=repcap.RBoffset.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB<Number> \n
 		Snippet: driver.configure.multiEval.rbAllocation.mcluster.orb.set(offset_rb = 1, rBoffset = repcap.RBoffset.Default) \n
 		Specifies the offset of the first allocated resource block, for multi-cluster allocation.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:RMC:MCLuster:UL
-			- CONFigure:LTE:SIGN<i>:UDCHannels:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:RMC:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:UDCHannels:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:RMC:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:UDCHannels:MCLuster:UL \n
-			:param offset_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'.
-			:param rBoffset: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Orb')"""
+			:param offset_rb: numeric For the allowed input ranges, see 'Uplink resource block allocation'.
+			:param rBoffset: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Orb')
+		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
-		rBoffset_cmd_val = self._base.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
+		rBoffset_cmd_val = self._cmd_group.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB{rBoffset_cmd_val} {param}')
 
 	def get(self, rBoffset=repcap.RBoffset.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB<Number> \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.mcluster.orb.get(rBoffset = repcap.RBoffset.Default) \n
 		Specifies the offset of the first allocated resource block, for multi-cluster allocation.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:RMC:MCLuster:UL
-			- CONFigure:LTE:SIGN<i>:UDCHannels:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:RMC:MCLuster:UL
+			- CONFigure:LTE:SIGN<i>:CONNection[:PCC]:UDCHannels:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:RMC:MCLuster:UL
 			- CONFigure:LTE:SIGN<i>:CONNection:SCC<c>:UDCHannels:MCLuster:UL \n
 			:param rBoffset: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Orb')
-			:return: offset_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'."""
-		rBoffset_cmd_val = self._base.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
+			:return: offset_rb: numeric For the allowed input ranges, see 'Uplink resource block allocation'."""
+		rBoffset_cmd_val = self._cmd_group.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB{rBoffset_cmd_val}?')
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Orb':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'OrbCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Orb(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = OrbCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Nrb.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Nrb.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,72 +1,72 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nrb:
-	"""Nrb commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class NrbCls:
+	"""Nrb commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nrb", core, parent)
+		self._cmd_group = CommandsGroup("nrb", core, parent)
 
 	def get_pscch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.nrb.get_pscch() \n
 		Specifies the number of allocated RBs for the PSCCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
-			:return: no_rb: The value is fixed. Range: 2 to 2
+			:return: no_rb: numeric The value is fixed. Range: 2 to 2
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pscch(self, no_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh \n
 		Snippet: driver.configure.multiEval.rbAllocation.nrb.set_pscch(no_rb = 1) \n
 		Specifies the number of allocated RBs for the PSCCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
-			:param no_rb: The value is fixed. Range: 2 to 2
+			:param no_rb: numeric The value is fixed. Range: 2 to 2
 		"""
 		param = Conversions.decimal_value_to_str(no_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh {param}')
 
 	def get_pssch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.nrb.get_pssch() \n
 		Specifies the number of allocated RBs for the PSSCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
-			:return: no_rb: For the allowed input range, see 'Sidelink Resource Block Allocation'.
+			:return: no_rb: numeric For the allowed input range, see 'Sidelink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pssch(self, no_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh \n
 		Snippet: driver.configure.multiEval.rbAllocation.nrb.set_pssch(no_rb = 1) \n
 		Specifies the number of allocated RBs for the PSSCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
-			:param no_rb: For the allowed input range, see 'Sidelink Resource Block Allocation'.
+			:param no_rb: numeric For the allowed input range, see 'Sidelink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(no_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.nrb.get_value() \n
 		Specifies the number of allocated RBs in the measured slot. For manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:return: no_rb: For the allowed input range, see 'Uplink Resource Block Allocation'.
+			:return: no_rb: numeric For the allowed input range, see 'Uplink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, no_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB \n
 		Snippet: driver.configure.multiEval.rbAllocation.nrb.set_value(no_rb = 1) \n
 		Specifies the number of allocated RBs in the measured slot. For manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:param no_rb: For the allowed input range, see 'Uplink Resource Block Allocation'.
+			:param no_rb: numeric For the allowed input range, see 'Uplink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(no_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Orb.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Orb.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,72 +1,72 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Orb:
-	"""Orb commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class OrbCls:
+	"""Orb commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("orb", core, parent)
+		self._cmd_group = CommandsGroup("orb", core, parent)
 
 	def get_pscch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.orb.get_pscch() \n
 		Specifies the offset of the first allocated PSCCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:return: offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'. Range: 0 to max no of RBs minus total allocated RBs
+			:return: offset_rb: numeric For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'. Range: 0 to max no of RBs minus total allocated RBs
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pscch(self, offset_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh \n
 		Snippet: driver.configure.multiEval.rbAllocation.orb.set_pscch(offset_rb = 1) \n
 		Specifies the offset of the first allocated PSCCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:param offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'. Range: 0 to max no of RBs minus total allocated RBs
+			:param offset_rb: numeric For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'. Range: 0 to max no of RBs minus total allocated RBs
 		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh {param}')
 
 	def get_pssch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.orb.get_pssch() \n
 		Specifies the offset of the first allocated PSSCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:return: offset_rb: The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink Resource Block Allocation'.
+			:return: offset_rb: numeric The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pssch(self, offset_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh \n
 		Snippet: driver.configure.multiEval.rbAllocation.orb.set_pssch(offset_rb = 1) \n
 		Specifies the offset of the first allocated PSSCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:param offset_rb: The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink Resource Block Allocation'.
+			:param offset_rb: numeric The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB \n
 		Snippet: value: int = driver.configure.multiEval.rbAllocation.orb.get_value() \n
 		Specifies the offset of the first allocated resource block for manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:return: offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'. Range: 0 to maximum number of RBs minus 1
+			:return: offset_rb: numeric For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'. Range: 0 to maximum number of RBs minus 1
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, offset_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB \n
 		Snippet: driver.configure.multiEval.rbAllocation.orb.set_value(offset_rb = 1) \n
 		Specifies the offset of the first allocated resource block for manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:param offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'. Range: 0 to maximum number of RBs minus 1
+			:param offset_rb: numeric For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'. Range: 0 to maximum number of RBs minus 1
 		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Result/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Result:
-	"""Result commands group definition. 16 total commands, 1 Sub-groups, 14 group commands"""
+class ResultCls:
+	"""Result commands group definition. 16 total commands, 1 Subgroups, 14 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("result", core, parent)
+		self._cmd_group = CommandsGroup("result", core, parent)
 
 	@property
 	def evMagnitude(self):
-		"""evMagnitude commands group. 0 Sub-classes, 2 commands."""
+		"""evMagnitude commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_evMagnitude'):
-			from .Result_.EvMagnitude import EvMagnitude
-			self._evMagnitude = EvMagnitude(self._core, self._base)
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
 		return self._evMagnitude
 
 	# noinspection PyTypeChecker
-	class AllStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Evm: bool: OFF | ON Error vector magnitude OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+	class AllStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Contains optional set arguments. Fields: \n
+			- Evm: bool: OFF | ON Error vector magnitude OFF: Do not evaluate results. ON: Evaluate results.
 			- Magnitude_Error: bool: OFF | ON
 			- Phase_Error: bool: OFF | ON
 			- Inband_Emissions: bool: OFF | ON
-			- Evm_Versus_C: bool: OFF | ON EVM vs. subcarrier
+			- Evm_Versus_C: bool: OFF | ON EVM vs subcarrier
 			- Iq: bool: OFF | ON I/Q constellation diagram
 			- Equ_Spec_Flatness: bool: OFF | ON Equalizer spectrum flatness
 			- Tx_Measurement: bool: OFF | ON TX measurement statistical overview
 			- Spec_Em_Mask: bool: OFF | ON Spectrum emission mask
 			- Aclr: bool: OFF | ON Adjacent channel leakage power ratio
-			- Rb_Alloc_Table: bool: OFF | ON Resource block allocation table
-			- Power_Monitor: bool: OFF | ON
-			- Bler: bool: OFF | ON Block error ratio
-			- Power_Dynamics: bool: OFF | ON"""
+			- Rb_Alloc_Table: bool: Optional setting parameter. OFF | ON Resource block allocation table
+			- Power_Monitor: bool: Optional setting parameter. OFF | ON
+			- Bler: bool: Optional setting parameter. OFF | ON Block error ratio
+			- Power_Dynamics: bool: Optional setting parameter. OFF | ON"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Evm'),
 			ArgStruct.scalar_bool('Magnitude_Error'),
 			ArgStruct.scalar_bool('Phase_Error'),
 			ArgStruct.scalar_bool('Inband_Emissions'),
 			ArgStruct.scalar_bool('Evm_Versus_C'),
 			ArgStruct.scalar_bool('Iq'),
 			ArgStruct.scalar_bool('Equ_Spec_Flatness'),
 			ArgStruct.scalar_bool('Tx_Measurement'),
 			ArgStruct.scalar_bool('Spec_Em_Mask'),
 			ArgStruct.scalar_bool('Aclr'),
-			ArgStruct.scalar_bool('Rb_Alloc_Table'),
-			ArgStruct.scalar_bool('Power_Monitor'),
-			ArgStruct.scalar_bool('Bler'),
-			ArgStruct.scalar_bool('Power_Dynamics')]
+			ArgStruct.scalar_bool_optional('Rb_Alloc_Table'),
+			ArgStruct.scalar_bool_optional('Power_Monitor'),
+			ArgStruct.scalar_bool_optional('Bler'),
+			ArgStruct.scalar_bool_optional('Power_Dynamics')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Evm: bool = None
 			self.Magnitude_Error: bool = None
 			self.Phase_Error: bool = None
 			self.Inband_Emissions: bool = None
@@ -70,679 +70,695 @@
 			self.Power_Monitor: bool = None
 			self.Bler: bool = None
 			self.Power_Dynamics: bool = None
 
 	def get_all(self) -> AllStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult[:ALL] \n
 		Snippet: value: AllStruct = driver.configure.multiEval.result.get_all() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-		This command combines most other CONFigure:LTE:MEAS<i>:MEValuation:RESult... commands. \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement. This command combines most other
+		CONFigure:LTE:MEAS<i>:MEValuation:RESult... commands. \n
 			:return: structure: for return value, see the help for AllStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ALL?', self.__class__.AllStruct())
 
 	def set_all(self, value: AllStruct) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult[:ALL] \n
-		Snippet: driver.configure.multiEval.result.set_all(value = AllStruct()) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-		This command combines most other CONFigure:LTE:MEAS<i>:MEValuation:RESult... commands. \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.result.AllStruct() \n
+		structure.Evm: bool = False \n
+		structure.Magnitude_Error: bool = False \n
+		structure.Phase_Error: bool = False \n
+		structure.Inband_Emissions: bool = False \n
+		structure.Evm_Versus_C: bool = False \n
+		structure.Iq: bool = False \n
+		structure.Equ_Spec_Flatness: bool = False \n
+		structure.Tx_Measurement: bool = False \n
+		structure.Spec_Em_Mask: bool = False \n
+		structure.Aclr: bool = False \n
+		structure.Rb_Alloc_Table: bool = False \n
+		structure.Power_Monitor: bool = False \n
+		structure.Bler: bool = False \n
+		structure.Power_Dynamics: bool = False \n
+		driver.configure.multiEval.result.set_all(value = structure) \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement. This command combines most other
+		CONFigure:LTE:MEAS<i>:MEValuation:RESult... commands. \n
 			:param value: see the help for AllStruct structure arguments.
 		"""
 		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ALL', value)
 
 	def get_merror(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_merror() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor?')
 		return Conversions.str_to_bool(response)
 
 	def set_merror(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor \n
 		Snippet: driver.configure.multiEval.result.set_merror(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor {param}')
 
 	def get_perror(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_perror() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor?')
 		return Conversions.str_to_bool(response)
 
 	def set_perror(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor \n
 		Snippet: driver.configure.multiEval.result.set_perror(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor {param}')
 
 	def get_iemissions(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_iemissions() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions?')
 		return Conversions.str_to_bool(response)
 
 	def set_iemissions(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions \n
 		Snippet: driver.configure.multiEval.result.set_iemissions(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions {param}')
 
 	def get_evmc(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_evmc() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC?')
 		return Conversions.str_to_bool(response)
 
 	def set_evmc(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC \n
 		Snippet: driver.configure.multiEval.result.set_evmc(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC {param}')
 
 	def get_es_flatness(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_es_flatness() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness?')
 		return Conversions.str_to_bool(response)
 
 	def set_es_flatness(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness \n
 		Snippet: driver.configure.multiEval.result.set_es_flatness(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness {param}')
 
 	def get_txm(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_txm() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM?')
 		return Conversions.str_to_bool(response)
 
 	def set_txm(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM \n
 		Snippet: driver.configure.multiEval.result.set_txm(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM {param}')
 
 	def get_iq(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_iq() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ?')
 		return Conversions.str_to_bool(response)
 
 	def set_iq(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ \n
 		Snippet: driver.configure.multiEval.result.set_iq(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ {param}')
 
 	def get_se_mask(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_se_mask() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask?')
 		return Conversions.str_to_bool(response)
 
 	def set_se_mask(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask \n
 		Snippet: driver.configure.multiEval.result.set_se_mask(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask {param}')
 
 	def get_aclr(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_aclr() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR?')
 		return Conversions.str_to_bool(response)
 
 	def set_aclr(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR \n
 		Snippet: driver.configure.multiEval.result.set_aclr(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR {param}')
 
 	def get_rba_table(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_rba_table() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable?')
 		return Conversions.str_to_bool(response)
 
 	def set_rba_table(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable \n
 		Snippet: driver.configure.multiEval.result.set_rba_table(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable {param}')
 
 	def get_pmonitor(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_pmonitor() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor?')
 		return Conversions.str_to_bool(response)
 
 	def set_pmonitor(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor \n
 		Snippet: driver.configure.multiEval.result.set_pmonitor(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor {param}')
 
 	def get_pdynamics(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_pdynamics() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics?')
 		return Conversions.str_to_bool(response)
 
 	def set_pdynamics(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics \n
 		Snippet: driver.configure.multiEval.result.set_pdynamics(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics {param}')
 
 	def get_bler(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER \n
 		Snippet: value: bool = driver.configure.multiEval.result.get_bler() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:return: enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER?')
 		return Conversions.str_to_bool(response)
 
 	def set_bler(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER \n
 		Snippet: driver.configure.multiEval.result.set_bler(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
+		Enables or disables the evaluation of results in the multi-evaluation measurement.
+			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- IEMissions / Inband emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
 			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
+			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
+		For reset values, see method RsCmwLteMeas.Configure.MultiEval.Result.all. \n
+			:param enable: OFF | ON OFF: Do not evaluate results. ON: Evaluate results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER {param}')
 
-	def clone(self) -> 'Result':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ResultCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Result(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ResultCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result_/EvMagnitude.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Extreme.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,98 +1,83 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvMagnitude:
-	"""EvMagnitude commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
-	class EvmSymbolStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: OFF | ON OFF: Do not measure the results and hide the result diagram ON: Measure the results and show the diagram
-			- Symbol: int: SC-FDMA symbol to be evaluated Range: 0 to 6
-			- Low_High: enums.LowHigh: LOW | HIGH Low or high EVM window position"""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power_Min: float: float Minimum total TX power in the slot Unit: dBm
+			- Tx_Power_Max: float: float Maximum total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_int('Symbol'),
-			ArgStruct.scalar_enum('Low_High', enums.LowHigh)]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Obw'),
+			ArgStruct.scalar_float('Tx_Power_Min'),
+			ArgStruct.scalar_float('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Symbol: int = None
-			self.Low_High: enums.LowHigh = None
-
-	def get_evm_symbol(self) -> EvmSymbolStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol \n
-		Snippet: value: EvmSymbolStruct = driver.configure.multiEval.result.evMagnitude.get_evm_symbol() \n
-		Enables or disables the measurement of EVM vs. modulation symbol results and configures the scope of the measurement. \n
-			:return: structure: for return value, see the help for EvmSymbolStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol?', self.__class__.EvmSymbolStruct())
-
-	def set_evm_symbol(self, value: EvmSymbolStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol \n
-		Snippet: driver.configure.multiEval.result.evMagnitude.set_evm_symbol(value = EvmSymbolStruct()) \n
-		Enables or disables the measurement of EVM vs. modulation symbol results and configures the scope of the measurement. \n
-			:param value: see the help for EvmSymbolStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol', value)
-
-	def get_value(self) -> bool:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude \n
-		Snippet: value: bool = driver.configure.multiEval.result.evMagnitude.get_value() \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
-			- EVMagnitude / Error vector magnitude
-			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
-			- ESFLatness / Equalizer spectrum flatness
-			- SEMask / Spectrum emission mask
-			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
-			- PERRor / Phase error
-			- IQ / I/Q constellation diagram
-			- TXM / TX meas. statistical overview
-			- ACLR / Adj. channel leakage power ratio
-			- PMONitor / Power monitor
-			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:return: enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
-		"""
-		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude?')
-		return Conversions.str_to_bool(response)
-
-	def set_value(self, enable: bool) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude \n
-		Snippet: driver.configure.multiEval.result.evMagnitude.set_value(enable = False) \n
-		Enables or disables the evaluation of results and shows or hides the views in the multi-evaluation measurement.
-			Table Header: Mnemonic / View type \n
-			- EVMagnitude / Error vector magnitude
-			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
-			- ESFLatness / Equalizer spectrum flatness
-			- SEMask / Spectrum emission mask
-			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
-			- EVMC / EVM vs. subcarrier
-			- PERRor / Phase error
-			- IQ / I/Q constellation diagram
-			- TXM / TX meas. statistical overview
-			- ACLR / Adj. channel leakage power ratio
-			- PMONitor / Power monitor
-			- PDYNamics / Power dynamics
-		For reset values, see CONFigure:LTE:MEAS<i>:MEValuation. \n
-			:param enable: OFF | ON OFF: Do not evaluate results, hide the view ON: Evaluate results and show the view
-		"""
-		param = Conversions.bool_to_str(enable)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude {param}')
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Obw: float = None
+			self.Tx_Power_Min: float = None
+			self.Tx_Power_Max: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
+		Snippet: value: ResultData = driver.multiEval.seMask.extreme.read() \n
+		Return the extreme single-value results of the spectrum emission measurement. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
+		Snippet: value: ResultData = driver.multiEval.seMask.extreme.fetch() \n
+		Return the extreme single-value results of the spectrum emission measurement. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.ResultData())
+
+	# noinspection PyTypeChecker
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float or bool: float Occupied bandwidth Unit: Hz
+			- Tx_Power_Min: float or bool: float Minimum total TX power in the slot Unit: dBm
+			- Tx_Power_Max: float or bool: float Maximum total TX power in the slot Unit: dBm"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power_Min'),
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Obw: float or bool = None
+			self.Tx_Power_Min: float or bool = None
+			self.Tx_Power_Max: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
+		Snippet: value: CalculateStruct = driver.multiEval.seMask.extreme.calculate() \n
+		Return the extreme single-value results of the spectrum emission measurement. The values described below are returned by
+		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 4 total commands, 1 Sub-groups, 2 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 4 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	@property
 	def spectrum(self):
 		"""spectrum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_spectrum'):
-			from .Scount_.Spectrum import Spectrum
-			self._spectrum = Spectrum(self._core, self._base)
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
 		return self._spectrum
 
 	def get_modulation(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation \n
 		Snippet: value: int = driver.configure.multiEval.scount.get_modulation() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals (slots) Range: 1 slot to 1000 slots
+			:return: statistic_count: numeric Range: 1 slot to 1000 slots
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation?')
 		return Conversions.str_to_int(response)
 
 	def set_modulation(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation \n
 		Snippet: driver.configure.multiEval.scount.set_modulation(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals (slots) Range: 1 slot to 1000 slots
+			:param statistic_count: numeric Range: 1 slot to 1000 slots
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation {param}')
 
 	def get_power(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer \n
 		Snippet: value: int = driver.configure.multiEval.scount.get_power() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals Range: 1 subframe to 1000 subframes
+			:return: statistic_count: numeric Range: 1 subframe to 1000 subframes
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer?')
 		return Conversions.str_to_int(response)
 
 	def set_power(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer \n
 		Snippet: driver.configure.multiEval.scount.set_power(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals Range: 1 subframe to 1000 subframes
+			:param statistic_count: numeric Range: 1 subframe to 1000 subframes
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer {param}')
 
-	def clone(self) -> 'Scount':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScountCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scount(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScountCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount_/Spectrum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/Spectrum.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,52 +1,52 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	def get_se_mask(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask \n
 		Snippet: value: int = driver.configure.multiEval.scount.spectrum.get_se_mask() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
-			:return: statistic_count: Number of measurement intervals (slots) Range: 1 slot to 1000 slots
+			:return: statistic_count: numeric Range: 1 slot to 1000 slots
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask?')
 		return Conversions.str_to_int(response)
 
 	def set_se_mask(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask \n
 		Snippet: driver.configure.multiEval.scount.spectrum.set_se_mask(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
-			:param statistic_count: Number of measurement intervals (slots) Range: 1 slot to 1000 slots
+			:param statistic_count: numeric Range: 1 slot to 1000 slots
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask {param}')
 
 	def get_aclr(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR \n
 		Snippet: value: int = driver.configure.multiEval.scount.spectrum.get_aclr() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
-			:return: statistic_count: Number of measurement intervals (slots) Range: 1 slot to 1000 slots
+			:return: statistic_count: numeric Range: 1 slot to 1000 slots
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR?')
 		return Conversions.str_to_int(response)
 
 	def set_aclr(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR \n
 		Snippet: driver.configure.multiEval.scount.spectrum.set_aclr(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
-			:param statistic_count: Number of measurement intervals (slots) Range: 1 slot to 1000 slots
+			:param statistic_count: numeric Range: 1 slot to 1000 slots
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class EvmcCls:
+	"""Evmc commands group definition. 8 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("evmc", core, parent)
 
 	@property
-	def seMask(self):
-		"""seMask commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_seMask'):
-			from .Spectrum_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
+	def peak(self):
+		"""peak commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	@property
-	def aclr(self):
-		"""aclr commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_aclr'):
-			from .Spectrum_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
-		return self._aclr
-
-	def clone(self) -> 'Spectrum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvmcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Spectrum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/Enable.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,48 +1,53 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EnableCls:
+	"""Enable commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("enable", core, parent)
+
+	def set(self, utra_1: bool, utra_2: bool, eutra: bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle \n
+		Snippet: driver.configure.multiEval.spectrum.aclr.enable.set(utra_1 = False, utra_2 = False, eutra = False) \n
+		Enables or disables the evaluation of the first adjacent UTRA channels, second adjacent UTRA channels and first adjacent
+		E-UTRA channels. \n
+			:param utra_1: OFF | ON
+			:param utra_2: OFF | ON
+			:param eutra: OFF | ON
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('utra_1', utra_1, DataType.Boolean), ArgSingle('utra_2', utra_2, DataType.Boolean), ArgSingle('eutra', eutra, DataType.Boolean))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class EnableStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Utra_1: bool: OFF | ON
 			- Utra_2: bool: OFF | ON
 			- Eutra: bool: OFF | ON"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Utra_1'),
 			ArgStruct.scalar_bool('Utra_2'),
 			ArgStruct.scalar_bool('Eutra')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Utra_1: bool = None
 			self.Utra_2: bool = None
 			self.Eutra: bool = None
 
-	def get_enable(self) -> EnableStruct:
+	def get(self) -> EnableStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle \n
-		Snippet: value: EnableStruct = driver.configure.multiEval.spectrum.aclr.get_enable() \n
+		Snippet: value: EnableStruct = driver.configure.multiEval.spectrum.aclr.enable.get() \n
 		Enables or disables the evaluation of the first adjacent UTRA channels, second adjacent UTRA channels and first adjacent
 		E-UTRA channels. \n
-			:return: structure: for return value, see the help for EnableStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle?', self.__class__.EnableStruct())
-
-	def set_enable(self, value: EnableStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle \n
-		Snippet: driver.configure.multiEval.spectrum.aclr.set_enable(value = EnableStruct()) \n
-		Enables or disables the evaluation of the first adjacent UTRA channels, second adjacent UTRA channels and first adjacent
-		E-UTRA channels. \n
-			:param value: see the help for EnableStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle', value)
+			:return: structure: for return value, see the help for EnableStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle?', self.__class__.EnableStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/SeMask.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_mfilter(self) -> enums.MeasFilter:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:MFILter \n
 		Snippet: value: enums.MeasFilter = driver.configure.multiEval.spectrum.seMask.get_mfilter() \n
 		Selects the resolution filter type for filter bandwidths of 50 kHz and greater. \n
 			:return: meas_filter: BANDpass | GAUSs
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Srs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Srs.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	def get_enable(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle \n
 		Snippet: value: bool = driver.configure.multiEval.srs.get_enable() \n
 		Specifies whether a sounding reference signal is allowed (ON) or not (OFF) . For the combined signal path scenario, use
-		CONFigure:LTE:SIGN<i>:SRS:ENABle. \n
+		CONFigure:LTE:SIGN<i>:CELL[:PCC]:SRS:ENABle. \n
 			:return: enable: OFF | ON OFF: no SRS signal ON: SRS signal allowed in the last SC-FDMA symbol of each subframe
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle?')
 		return Conversions.str_to_bool(response)
 
 	def set_enable(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle \n
 		Snippet: driver.configure.multiEval.srs.set_enable(enable = False) \n
 		Specifies whether a sounding reference signal is allowed (ON) or not (OFF) . For the combined signal path scenario, use
-		CONFigure:LTE:SIGN<i>:SRS:ENABle. \n
+		CONFigure:LTE:SIGN<i>:CELL[:PCC]:SRS:ENABle. \n
 			:param enable: OFF | ON OFF: no SRS signal ON: SRS signal allowed in the last SC-FDMA symbol of each subframe
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/MultiEval_/Tmode.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Tmode.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,63 +2,63 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Tmode:
-	"""Tmode commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class TmodeCls:
+	"""Tmode commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("tmode", core, parent)
+		self._cmd_group = CommandsGroup("tmode", core, parent)
 
 	def get_scount(self) -> List[int]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt \n
 		Snippet: value: List[int] = driver.configure.multiEval.tmode.get_scount() \n
 		Defines the subframe counts for all entries of the 'TPC Mode' list. For definition of the corresponding expected nominal
 		power values, see method RsCmwLteMeas.Configure.MultiEval.Tmode.envelopePower. \n
-			:return: sub_frame_count: Comma-separated list of 16 values, for list entry number 0 to 15 Range: 1 to 320
+			:return: sub_frame_count: decimal Comma-separated list of 16 values, for list entry number 0 to 15 Range: 1 to 320
 		"""
 		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt?')
 		return response
 
 	def set_scount(self, sub_frame_count: List[int]) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt \n
 		Snippet: driver.configure.multiEval.tmode.set_scount(sub_frame_count = [1, 2, 3]) \n
 		Defines the subframe counts for all entries of the 'TPC Mode' list. For definition of the corresponding expected nominal
 		power values, see method RsCmwLteMeas.Configure.MultiEval.Tmode.envelopePower. \n
-			:param sub_frame_count: Comma-separated list of 16 values, for list entry number 0 to 15 Range: 1 to 320
+			:param sub_frame_count: decimal Comma-separated list of 16 values, for list entry number 0 to 15 Range: 1 to 320
 		"""
 		param = Conversions.list_to_csv_str(sub_frame_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt {param}')
 
 	def get_envelope_power(self) -> List[float]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower \n
 		Snippet: value: List[float] = driver.configure.multiEval.tmode.get_envelope_power() \n
 		Defines the expected nominal power values for all entries of the 'TPC Mode' list. For definition of the corresponding
 		subframe count values, see method RsCmwLteMeas.Configure.MultiEval.Tmode.scount. \n
-			:return: exp_nom_pow: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+			:return: exp_nom_pow: numeric Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower?')
 		return response
 
 	def set_envelope_power(self, exp_nom_pow: List[float]) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower \n
 		Snippet: driver.configure.multiEval.tmode.set_envelope_power(exp_nom_pow = [1.1, 2.2, 3.3]) \n
 		Defines the expected nominal power values for all entries of the 'TPC Mode' list. For definition of the corresponding
 		subframe count values, see method RsCmwLteMeas.Configure.MultiEval.Tmode.scount. \n
-			:param exp_nom_pow: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+			:param exp_nom_pow: numeric Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		param = Conversions.list_to_csv_str(exp_nom_pow)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower {param}')
 
 	def get_rlevel(self) -> List[float]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:RLEVel \n
 		Snippet: value: List[float] = driver.configure.multiEval.tmode.get_rlevel() \n
 		Queries the reference level for all entries of the 'TPC Mode' list. The reference level is calculated from the expected
 		nominal power of each entry and the user margin. \n
-			:return: reference_level: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the reference levels can be calculated as follows: Range (Reference Level) = Range (Input Power) + External Attenuation The input power range is stated in the data sheet. Unit: dBm
+			:return: reference_level: float Comma-separated list of 16 values, for list entry number 0 to 15 The range of the reference levels can be calculated as follows: Range (Reference Level) = Range (Input Power) + External Attenuation The input power range is stated in the data sheet. Unit: dBm
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:RLEVel?')
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Pcc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Pcc.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_channel_bw(self) -> enums.ChannelBandwidth:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>[:PCC]:CBANdwidth \n
 		Snippet: value: enums.ChannelBandwidth = driver.configure.pcc.get_channel_bw() \n
 		No command help available \n
 			:return: channel_bw: No help available
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,97 +1,95 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Prach:
-	"""Prach commands group definition. 33 total commands, 6 Sub-groups, 7 group commands"""
+class PrachCls:
+	"""Prach commands group definition. 34 total commands, 6 Subgroups, 8 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("prach", core, parent)
+		self._cmd_group = CommandsGroup("prach", core, parent)
 
 	@property
 	def pfOffset(self):
 		"""pfOffset commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_pfOffset'):
-			from .Prach_.PfOffset import PfOffset
-			self._pfOffset = PfOffset(self._core, self._base)
+			from .PfOffset import PfOffsetCls
+			self._pfOffset = PfOffsetCls(self._core, self._cmd_group)
 		return self._pfOffset
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 2 Sub-classes, 3 commands."""
 		if not hasattr(self, '_modulation'):
-			from .Prach_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_power'):
-			from .Prach_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def scount(self):
 		"""scount commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_scount'):
-			from .Prach_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
 		return self._scount
 
 	@property
 	def result(self):
 		"""result commands group. 0 Sub-classes, 9 commands."""
 		if not hasattr(self, '_result'):
-			from .Prach_.Result import Result
-			self._result = Result(self._core, self._base)
+			from .Result import ResultCls
+			self._result = ResultCls(self._core, self._cmd_group)
 		return self._result
 
 	@property
 	def limit(self):
-		"""limit commands group. 0 Sub-classes, 5 commands."""
+		"""limit commands group. 4 Sub-classes, 1 commands."""
 		if not hasattr(self, '_limit'):
-			from .Prach_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT \n
 		Snippet: value: float = driver.configure.prach.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, timeout: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT \n
 		Snippet: driver.configure.prach.set_timeout(timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(timeout)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:REPetition \n
@@ -117,87 +115,107 @@
 
 	# noinspection PyTypeChecker
 	def get_scondition(self) -> enums.StopCondition:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition \n
 		Snippet: value: enums.StopCondition = driver.configure.prach.get_scondition() \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition?')
 		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
 
 	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition \n
 		Snippet: driver.configure.prach.set_scondition(stop_condition = enums.StopCondition.NONE) \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception \n
 		Snippet: value: bool = driver.configure.prach.get_mo_exception() \n
 		Specifies whether measurement results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
-			:return: meas_on_exception: OFF | ON OFF: Faulty results are rejected ON: Results are never rejected
+			:return: meas_on_exception: OFF | ON OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception?')
 		return Conversions.str_to_bool(response)
 
 	def set_mo_exception(self, meas_on_exception: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception \n
 		Snippet: driver.configure.prach.set_mo_exception(meas_on_exception = False) \n
 		Specifies whether measurement results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
-			:param meas_on_exception: OFF | ON OFF: Faulty results are rejected ON: Results are never rejected
+			:param meas_on_exception: OFF | ON OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		param = Conversions.bool_to_str(meas_on_exception)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception {param}')
 
 	def get_pc_index(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex \n
 		Snippet: value: int = driver.configure.prach.get_pc_index() \n
 		The PRACH configuration index identifies the PRACH configuration used by the UE (preamble format, which resources in the
 		time domain are allowed for transmission of preambles etc.) .
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
 			- CONFigure:LTE:SIGN<i>:CELL:PRACh:PCINdex:FDD
 			- CONFigure:LTE:SIGN<i>:CELL:PRACh:PCINdex:TDD \n
-			:return: prach_conf_index: Range: 0 to 63 for FDD / 57 for TDD
+			:return: prach_conf_index: numeric Range: 0 to 63 for FDD / 57 for TDD
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex?')
 		return Conversions.str_to_int(response)
 
 	def set_pc_index(self, prach_conf_index: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex \n
 		Snippet: driver.configure.prach.set_pc_index(prach_conf_index = 1) \n
 		The PRACH configuration index identifies the PRACH configuration used by the UE (preamble format, which resources in the
 		time domain are allowed for transmission of preambles etc.) .
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
 			- CONFigure:LTE:SIGN<i>:CELL:PRACh:PCINdex:FDD
 			- CONFigure:LTE:SIGN<i>:CELL:PRACh:PCINdex:TDD \n
-			:param prach_conf_index: Range: 0 to 63 for FDD / 57 for TDD
+			:param prach_conf_index: numeric Range: 0 to 63 for FDD / 57 for TDD
 		"""
 		param = Conversions.decimal_value_to_str(prach_conf_index)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex {param}')
 
+	def get_ssymbol(self) -> int:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol \n
+		Snippet: value: int = driver.configure.prach.get_ssymbol() \n
+		Selects the OFDM symbol to be evaluated for single-symbol modulation result diagrams. The number of OFDM symbols in the
+		preamble (<no of symbols>) depends on the preamble format, see Table 'Preambles in the time domain'. \n
+			:return: selected_symbol: numeric Range: 0 to no of symbols -1
+		"""
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol?')
+		return Conversions.str_to_int(response)
+
+	def set_ssymbol(self, selected_symbol: int) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol \n
+		Snippet: driver.configure.prach.set_ssymbol(selected_symbol = 1) \n
+		Selects the OFDM symbol to be evaluated for single-symbol modulation result diagrams. The number of OFDM symbols in the
+		preamble (<no of symbols>) depends on the preamble format, see Table 'Preambles in the time domain'. \n
+			:param selected_symbol: numeric Range: 0 to no of symbols -1
+		"""
+		param = Conversions.decimal_value_to_str(selected_symbol)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol {param}')
+
 	def get_no_preambles(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles \n
 		Snippet: value: int = driver.configure.prach.get_no_preambles() \n
 		Specifies the number of preambles to be captured per measurement interval. \n
-			:return: number_preamble: Range: 1 to 400
+			:return: number_preamble: numeric Range: 1 to 400
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles?')
 		return Conversions.str_to_int(response)
 
 	def set_no_preambles(self, number_preamble: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles \n
 		Snippet: driver.configure.prach.set_no_preambles(number_preamble = 1) \n
 		Specifies the number of preambles to be captured per measurement interval. \n
-			:param number_preamble: Range: 1 to 400
+			:param number_preamble: numeric Range: 1 to 400
 		"""
 		param = Conversions.decimal_value_to_str(number_preamble)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles {param}')
 
 	# noinspection PyTypeChecker
 	def get_po_preambles(self) -> enums.PeriodPreamble:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:POPReambles \n
@@ -213,14 +231,14 @@
 		Snippet: driver.configure.prach.set_po_preambles(period_preamble = enums.PeriodPreamble.MS05) \n
 		Specifies the periodicity of preambles to be captured for multi-preamble result views. \n
 			:param period_preamble: MS05 | MS10 | MS20 MS05: 5 ms MS10: 10 ms MS20: 20 ms
 		"""
 		param = Conversions.enum_scalar_to_str(period_preamble, enums.PeriodPreamble)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:POPReambles {param}')
 
-	def clone(self) -> 'Prach':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PrachCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Prach(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PrachCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Limit.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,160 +1,180 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 5 total commands, 0 Sub-groups, 5 group commands"""
+class QpskCls:
+	"""Qpsk commands group definition. 9 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("qpsk", core, parent)
 
-	# noinspection PyTypeChecker
-	class EvMagnitudeStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Peak: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
+	@property
+	def evMagnitude(self):
+		"""evMagnitude commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_evMagnitude'):
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
+		return self._evMagnitude
+
+	@property
+	def merror(self):
+		"""merror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_merror'):
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
+		return self._merror
+
+	@property
+	def perror(self):
+		"""perror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_perror'):
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
+		return self._perror
+
+	@property
+	def iqOffset(self):
+		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_iqOffset'):
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
+		return self._iqOffset
+
+	@property
+	def ibe(self):
+		"""ibe commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_ibe'):
+			from .Ibe import IbeCls
+			self._ibe = IbeCls(self._core, self._cmd_group)
+		return self._ibe
 
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_ev_magnitude(self) -> EvMagnitudeStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude \n
-		Snippet: value: EvMagnitudeStruct = driver.configure.prach.limit.get_ev_magnitude() \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) . \n
-			:return: structure: for return value, see the help for EvMagnitudeStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude?', self.__class__.EvMagnitudeStruct())
-
-	def set_ev_magnitude(self, value: EvMagnitudeStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude \n
-		Snippet: driver.configure.prach.limit.set_ev_magnitude(value = EvMagnitudeStruct()) \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) . \n
-			:param value: see the help for EvMagnitudeStruct structure arguments.
+	def get_freq_error(self) -> float or bool:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor \n
+		Snippet: value: float or bool = driver.configure.multiEval.limit.qpsk.get_freq_error() \n
+		Defines an upper limit for the carrier frequency error (QPSK modulation) . \n
+			:return: frequency_error: (float or boolean) numeric | ON | OFF Range: 0 ppm to 1 ppm, Unit: ppm ON | OFF enables or disables the limit check.
 		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude', value)
-
-	# noinspection PyTypeChecker
-	class MerrorStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Peak: float or bool: Range: 0 % to 100 %, Unit: % Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor?')
+		return Conversions.str_to_float_or_bool(response)
 
-	def get_merror(self) -> MerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor \n
-		Snippet: value: MerrorStruct = driver.configure.prach.limit.get_merror() \n
-		Defines upper limits for the RMS and peak values of the magnitude error. \n
-			:return: structure: for return value, see the help for MerrorStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor?', self.__class__.MerrorStruct())
-
-	def set_merror(self, value: MerrorStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor \n
-		Snippet: driver.configure.prach.limit.set_merror(value = MerrorStruct()) \n
-		Defines upper limits for the RMS and peak values of the magnitude error. \n
-			:param value: see the help for MerrorStruct structure arguments.
+	def set_freq_error(self, frequency_error: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor \n
+		Snippet: driver.configure.multiEval.limit.qpsk.set_freq_error(frequency_error = 1.0) \n
+		Defines an upper limit for the carrier frequency error (QPSK modulation) . \n
+			:param frequency_error: (float or boolean) numeric | ON | OFF Range: 0 ppm to 1 ppm, Unit: ppm ON | OFF enables or disables the limit check.
 		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor', value)
+		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor {param}')
 
 	# noinspection PyTypeChecker
-	class PerrorStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: Range: 0 deg to 180 deg, Unit: deg Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-			- Peak: float or bool: Range: 0 deg to 180 deg, Unit: deg Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)"""
+	class SflatnessStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Enable: bool: No parameter help available
+			- Lower: float: No parameter help available
+			- Upper: float: No parameter help available
+			- Edge_Lower: float: No parameter help available
+			- Edge_Upper: float: No parameter help available
+			- Edge_Frequency: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
+			ArgStruct.scalar_bool('Enable'),
+			ArgStruct.scalar_float('Lower'),
+			ArgStruct.scalar_float('Upper'),
+			ArgStruct.scalar_float('Edge_Lower'),
+			ArgStruct.scalar_float('Edge_Upper'),
+			ArgStruct.scalar_float('Edge_Frequency')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_perror(self) -> PerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor \n
-		Snippet: value: PerrorStruct = driver.configure.prach.limit.get_perror() \n
-		Defines symmetric limits for the RMS and peak values of the phase error. The limit check fails if the absolute value of
-		the measured phase error exceeds the specified values. \n
-			:return: structure: for return value, see the help for PerrorStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor?', self.__class__.PerrorStruct())
-
-	def set_perror(self, value: PerrorStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor \n
-		Snippet: driver.configure.prach.limit.set_perror(value = PerrorStruct()) \n
-		Defines symmetric limits for the RMS and peak values of the phase error. The limit check fails if the absolute value of
-		the measured phase error exceeds the specified values. \n
-			:param value: see the help for PerrorStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor', value)
-
-	def get_freq_error(self) -> float or bool:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor \n
-		Snippet: value: float or bool = driver.configure.prach.limit.get_freq_error() \n
-		Defines an upper limit for the carrier frequency error. \n
-			:return: frequency_error: Range: 0 ppm to 1000 ppm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
-		"""
-		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor?')
-		return Conversions.str_to_float_or_bool(response)
-
-	def set_freq_error(self, frequency_error: float or bool) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor \n
-		Snippet: driver.configure.prach.limit.set_freq_error(frequency_error = 1.0) \n
-		Defines an upper limit for the carrier frequency error. \n
-			:param frequency_error: Range: 0 ppm to 1000 ppm Additional parameters: OFF | ON (disables the limit check | enables the limit check using the previous/default limit values)
+			self.Enable: bool = None
+			self.Lower: float = None
+			self.Upper: float = None
+			self.Edge_Lower: float = None
+			self.Edge_Upper: float = None
+			self.Edge_Frequency: float = None
+
+	def get_sflatness(self) -> SflatnessStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness \n
+		Snippet: value: SflatnessStruct = driver.configure.multiEval.limit.qpsk.get_sflatness() \n
+		No command help available \n
+			:return: structure: for return value, see the help for SflatnessStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness?', self.__class__.SflatnessStruct())
+
+	def set_sflatness(self, value: SflatnessStruct) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.qpsk.SflatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Lower: float = 1.0 \n
+		structure.Upper: float = 1.0 \n
+		structure.Edge_Lower: float = 1.0 \n
+		structure.Edge_Upper: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.multiEval.limit.qpsk.set_sflatness(value = structure) \n
+		No command help available \n
+			:param value: see the help for SflatnessStruct structure arguments.
 		"""
-		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor {param}')
+		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness', value)
 
 	# noinspection PyTypeChecker
-	class PdynamicsStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class EsFlatnessStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
 			- Enable: bool: OFF | ON OFF: disables the limit check ON: enables the limit check
-			- On_Power_Upper: float: Upper limit for the ON power Range: -256 dBm to 256 dBm, Unit: dBm
-			- On_Power_Lower: float: Lower limit for the ON power Range: -256 dBm to 256 dBm, Unit: dBm
-			- Off_Power_Upper: float: Upper limit for the OFF power Range: -256 dBm to 256 dBm, Unit: dBm"""
+			- Range_1: float: numeric Upper limit for max(range 1) - min(range 1) Range: -256 dBpp to 256 dBpp, Unit: dBpp
+			- Range_2: float: numeric Upper limit for max(range 2) - min(range 2) Range: -256 dBpp to 256 dBpp, Unit: dBpp
+			- Max_1_Min_2: float: numeric Upper limit for max(range 1) - min(range 2) Range: -256 dB to 256 dB, Unit: dB
+			- Max_2_Min_1: float: numeric Upper limit for max(range 2) - min(range 1) Range: -256 dB to 256 dB, Unit: dB
+			- Edge_Frequency: float: numeric Frequency band edge distance of border between range 1 and range 2 Range: 0 MHz to 20 MHz, Unit: Hz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('On_Power_Upper'),
-			ArgStruct.scalar_float('On_Power_Lower'),
-			ArgStruct.scalar_float('Off_Power_Upper')]
+			ArgStruct.scalar_float('Range_1'),
+			ArgStruct.scalar_float('Range_2'),
+			ArgStruct.scalar_float('Max_1_Min_2'),
+			ArgStruct.scalar_float('Max_2_Min_1'),
+			ArgStruct.scalar_float('Edge_Frequency')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
-			self.On_Power_Upper: float = None
-			self.On_Power_Lower: float = None
-			self.Off_Power_Upper: float = None
-
-	def get_pdynamics(self) -> PdynamicsStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics \n
-		Snippet: value: PdynamicsStruct = driver.configure.prach.limit.get_pdynamics() \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
-			:return: structure: for return value, see the help for PdynamicsStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics?', self.__class__.PdynamicsStruct())
-
-	def set_pdynamics(self, value: PdynamicsStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics \n
-		Snippet: driver.configure.prach.limit.set_pdynamics(value = PdynamicsStruct()) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
-			:param value: see the help for PdynamicsStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics', value)
+			self.Range_1: float = None
+			self.Range_2: float = None
+			self.Max_1_Min_2: float = None
+			self.Max_2_Min_1: float = None
+			self.Edge_Frequency: float = None
+
+	def get_es_flatness(self) -> EsFlatnessStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness \n
+		Snippet: value: EsFlatnessStruct = driver.configure.multiEval.limit.qpsk.get_es_flatness() \n
+		Defines limits for the equalizer spectrum flatness (QPSK modulation) . \n
+			:return: structure: for return value, see the help for EsFlatnessStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness?', self.__class__.EsFlatnessStruct())
+
+	def set_es_flatness(self, value: EsFlatnessStruct) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness \n
+		Snippet with structure: \n
+		structure = driver.configure.multiEval.limit.qpsk.EsFlatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Range_1: float = 1.0 \n
+		structure.Range_2: float = 1.0 \n
+		structure.Max_1_Min_2: float = 1.0 \n
+		structure.Max_2_Min_1: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.multiEval.limit.qpsk.set_es_flatness(value = structure) \n
+		Defines limits for the equalizer spectrum flatness (QPSK modulation) . \n
+			:param value: see the help for EsFlatnessStruct structure arguments.
+		"""
+		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness', value)
+
+	def clone(self) -> 'QpskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = QpskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 7 total commands, 2 Sub-groups, 3 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 7 total commands, 2 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def sindex(self):
 		"""sindex commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_sindex'):
-			from .Modulation_.Sindex import Sindex
-			self._sindex = Sindex(self._core, self._base)
+			from .Sindex import SindexCls
+			self._sindex = SindexCls(self._core, self._cmd_group)
 		return self._sindex
 
 	@property
 	def ewLength(self):
 		"""ewLength commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ewLength'):
-			from .Modulation_.EwLength import EwLength
-			self._ewLength = EwLength(self._core, self._base)
+			from .EwLength import EwLengthCls
+			self._ewLength = EwLengthCls(self._core, self._cmd_group)
 		return self._ewLength
 
 	def get_lrs_index(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex \n
 		Snippet: value: int = driver.configure.prach.modulation.get_lrs_index() \n
 		Specifies the logical root sequence index to be used for generation of the preamble sequence. For the combined signal
-		path scenario, useCONFigure:LTE:SIGN<i>:CELL:PRACh:LRSindex. \n
-			:return: log_root_seq_index: Range: 0 to 837 (for preamble format 4: 0 to 137)
+		path scenario, use CONFigure:LTE:SIGN<i>:CELL:PRACh:LRSindex. \n
+			:return: log_root_seq_index: numeric Range: 0 to 837 (for preamble format 4: 0 to 137)
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex?')
 		return Conversions.str_to_int(response)
 
 	def set_lrs_index(self, log_root_seq_index: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex \n
 		Snippet: driver.configure.prach.modulation.set_lrs_index(log_root_seq_index = 1) \n
 		Specifies the logical root sequence index to be used for generation of the preamble sequence. For the combined signal
-		path scenario, useCONFigure:LTE:SIGN<i>:CELL:PRACh:LRSindex. \n
-			:param log_root_seq_index: Range: 0 to 837 (for preamble format 4: 0 to 137)
+		path scenario, use CONFigure:LTE:SIGN<i>:CELL:PRACh:LRSindex. \n
+			:param log_root_seq_index: numeric Range: 0 to 837 (for preamble format 4: 0 to 137)
 		"""
 		param = Conversions.decimal_value_to_str(log_root_seq_index)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex {param}')
 
 	def get_zcz_config(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig \n
 		Snippet: value: int = driver.configure.prach.modulation.get_zcz_config() \n
 		Specifies the zero correlation zone config, i.e. which NCS value of an NCS set is used for generation of the preamble
-		sequence. For the combined signal path scenario, useCONFigure:LTE:SIGN<i>:CELL:PRACh:ZCZConfig. \n
-			:return: zero_corr_zone_con: Range: 0 to 15 (for preamble format 4: 0 to 6)
+		sequence. For the combined signal path scenario, use CONFigure:LTE:SIGN<i>:CELL:PRACh:ZCZConfig. \n
+			:return: zero_corr_zone_con: numeric Range: 0 to 15 (for preamble format 4: 0 to 6)
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig?')
 		return Conversions.str_to_int(response)
 
 	def set_zcz_config(self, zero_corr_zone_con: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig \n
 		Snippet: driver.configure.prach.modulation.set_zcz_config(zero_corr_zone_con = 1) \n
 		Specifies the zero correlation zone config, i.e. which NCS value of an NCS set is used for generation of the preamble
-		sequence. For the combined signal path scenario, useCONFigure:LTE:SIGN<i>:CELL:PRACh:ZCZConfig. \n
-			:param zero_corr_zone_con: Range: 0 to 15 (for preamble format 4: 0 to 6)
+		sequence. For the combined signal path scenario, use CONFigure:LTE:SIGN<i>:CELL:PRACh:ZCZConfig. \n
+			:param zero_corr_zone_con: numeric Range: 0 to 15 (for preamble format 4: 0 to 6)
 		"""
 		param = Conversions.decimal_value_to_str(zero_corr_zone_con)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig {param}')
 
 	# noinspection PyTypeChecker
 	def get_ew_position(self) -> enums.LowHigh:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWPosition \n
@@ -83,14 +83,14 @@
 		Snippet: driver.configure.prach.modulation.set_ew_position(evm_window_pos = enums.LowHigh.HIGH) \n
 		Specifies the position of the EVM window used for calculation of the trace results. \n
 			:param evm_window_pos: LOW | HIGH
 		"""
 		param = Conversions.enum_scalar_to_str(evm_window_pos, enums.LowHigh)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWPosition {param}')
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EwLength:
-	"""EwLength commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class EwLengthCls:
+	"""EwLength commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ewLength", core, parent)
+		self._cmd_group = CommandsGroup("ewLength", core, parent)
 
 	@property
 	def pformat(self):
 		"""pformat commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pformat'):
-			from .EwLength_.Pformat import Pformat
-			self._pformat = Pformat(self._core, self._base)
+			from .Pformat import PformatCls
+			self._pformat = PformatCls(self._core, self._cmd_group)
 		return self._pformat
 
 	def get_value(self) -> List[int]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength \n
 		Snippet: value: List[int] = driver.configure.prach.modulation.ewLength.get_value() \n
 		Specifies the EVM window length in samples for all preamble formats. \n
 			:return: evm_window_length: No help available
@@ -35,14 +35,14 @@
 		Snippet: driver.configure.prach.modulation.ewLength.set_value(evm_window_length = [1, 2, 3]) \n
 		Specifies the EVM window length in samples for all preamble formats. \n
 			:param evm_window_length: No help available
 		"""
 		param = Conversions.list_to_csv_str(evm_window_length)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength {param}')
 
-	def clone(self) -> 'EwLength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EwLengthCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EwLength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EwLengthCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/Pformat.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/Pformat.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,54 +2,55 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal import Conversions
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pformat:
-	"""Pformat commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class PformatCls:
+	"""Pformat commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: PreambleFormat, default value after init: PreambleFormat.Fmt1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pformat", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preambleFormat_get', 'repcap_preambleFormat_set', repcap.PreambleFormat.Fmt1)
+		self._cmd_group = CommandsGroup("pformat", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preambleFormat_get', 'repcap_preambleFormat_set', repcap.PreambleFormat.Fmt1)
 
-	def repcap_preambleFormat_set(self, enum_value: repcap.PreambleFormat) -> None:
+	def repcap_preambleFormat_set(self, preambleFormat: repcap.PreambleFormat) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to PreambleFormat.Default
 		Default value after init: PreambleFormat.Fmt1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preambleFormat)
 
 	def repcap_preambleFormat_get(self) -> repcap.PreambleFormat:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, evm_window_length: int, preambleFormat=repcap.PreambleFormat.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat<PreambleFormat> \n
 		Snippet: driver.configure.prach.modulation.ewLength.pformat.set(evm_window_length = 1, preambleFormat = repcap.PreambleFormat.Default) \n
 		No command help available \n
 			:param evm_window_length: No help available
-			:param preambleFormat: optional repeated capability selector. Default value: Fmt1 (settable in the interface 'Pformat')"""
+			:param preambleFormat: optional repeated capability selector. Default value: Fmt1 (settable in the interface 'Pformat')
+		"""
 		param = Conversions.decimal_value_to_str(evm_window_length)
-		preambleFormat_cmd_val = self._base.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
+		preambleFormat_cmd_val = self._cmd_group.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat{preambleFormat_cmd_val} {param}')
 
 	def get(self, preambleFormat=repcap.PreambleFormat.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat<PreambleFormat> \n
 		Snippet: value: int = driver.configure.prach.modulation.ewLength.pformat.get(preambleFormat = repcap.PreambleFormat.Default) \n
 		No command help available \n
 			:param preambleFormat: optional repeated capability selector. Default value: Fmt1 (settable in the interface 'Pformat')
 			:return: evm_window_length: No help available"""
-		preambleFormat_cmd_val = self._base.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
+		preambleFormat_cmd_val = self._cmd_group.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat{preambleFormat_cmd_val}?')
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Pformat':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PformatCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pformat(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PformatCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/Sindex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Modulation/Sindex.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sindex:
-	"""Sindex commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SindexCls:
+	"""Sindex commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sindex", core, parent)
+		self._cmd_group = CommandsGroup("sindex", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex:AUTO \n
 		Snippet: value: bool = driver.configure.prach.modulation.sindex.get_auto() \n
 		Enables or disables automatic detection of the sequence index. To configure the index manually for disabled automatic
 		detection, see method RsCmwLteMeas.Configure.Prach.Modulation.Sindex.value. \n
 			:return: seq_index_auto: OFF | ON
@@ -32,21 +32,21 @@
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex:AUTO {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex \n
 		Snippet: value: int = driver.configure.prach.modulation.sindex.get_value() \n
 		Specifies the sequence index, i.e. which of the 64 preamble sequences of the cell is used by the UE. This setting is only
 		relevant if automatic detection is disabled, see method RsCmwLteMeas.Configure.Prach.Modulation.Sindex.auto. \n
-			:return: sequence_index: Range: 0 to 63
+			:return: sequence_index: numeric Range: 0 to 63
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, sequence_index: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex \n
 		Snippet: driver.configure.prach.modulation.sindex.set_value(sequence_index = 1) \n
 		Specifies the sequence index, i.e. which of the 64 preamble sequences of the cell is used by the UE. This setting is only
 		relevant if automatic detection is disabled, see method RsCmwLteMeas.Configure.Prach.Modulation.Sindex.auto. \n
-			:param sequence_index: Range: 0 to 63
+			:param sequence_index: numeric Range: 0 to 63
 		"""
 		param = Conversions.decimal_value_to_str(sequence_index)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/PfOffset.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/PfOffset.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PfOffset:
-	"""PfOffset commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PfOffsetCls:
+	"""PfOffset commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pfOffset", core, parent)
+		self._cmd_group = CommandsGroup("pfOffset", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset:AUTO \n
 		Snippet: value: bool = driver.configure.prach.pfOffset.get_auto() \n
 		Enables or disables automatic detection of the PRACH frequency offset. To configure the offset manually for disabled
 		automatic detection, see method RsCmwLteMeas.Configure.Prach.PfOffset.value. \n
 			:return: prach_freq_auto: OFF | ON
@@ -32,23 +32,23 @@
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset:AUTO {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset \n
 		Snippet: value: int = driver.configure.prach.pfOffset.get_value() \n
 		Specifies the PRACH frequency offset. This setting is only relevant if automatic detection is disabled, see method
 		RsCmwLteMeas.Configure.Prach.PfOffset.auto.
-		For the combined signal path scenario, useCONFigure:LTE:SIGN<i>:CELL:PRACh:PFOFfset. \n
-			:return: prach_freq_offset: Range: 0 to Total RB - 6 depending on channel bandwidth, see table below
+		For the combined signal path scenario, use CONFigure:LTE:SIGN<i>:CELL:PRACh:PFOFfset. \n
+			:return: prach_freq_offset: numeric Range: 0 to Total RB - 6 depending on channel bandwidth, see table below
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, prach_freq_offset: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset \n
 		Snippet: driver.configure.prach.pfOffset.set_value(prach_freq_offset = 1) \n
 		Specifies the PRACH frequency offset. This setting is only relevant if automatic detection is disabled, see method
 		RsCmwLteMeas.Configure.Prach.PfOffset.auto.
-		For the combined signal path scenario, useCONFigure:LTE:SIGN<i>:CELL:PRACh:PFOFfset. \n
-			:param prach_freq_offset: Range: 0 to Total RB - 6 depending on channel bandwidth, see table below
+		For the combined signal path scenario, use CONFigure:LTE:SIGN<i>:CELL:PRACh:PFOFfset. \n
+			:param prach_freq_offset: numeric Range: 0 to Total RB - 6 depending on channel bandwidth, see table below
 		"""
 		param = Conversions.decimal_value_to_str(prach_freq_offset)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Power.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Power.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowerCls:
+	"""Power commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	def get_hdmode(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:POWer:HDMode \n
 		Snippet: value: bool = driver.configure.prach.power.get_hdmode() \n
 		Enables or disables the high dynamic mode for power dynamics measurements. \n
 			:return: high_dynamic_mode: OFF | ON
 		"""
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Prach_/Scount.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Prach/Scount.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,52 +1,52 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	def get_modulation(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation \n
 		Snippet: value: int = driver.configure.prach.scount.get_modulation() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals Range: 1 to 1000
+			:return: statistic_count: numeric Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation?')
 		return Conversions.str_to_int(response)
 
 	def set_modulation(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation \n
 		Snippet: driver.configure.prach.scount.set_modulation(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals Range: 1 to 1000
+			:param statistic_count: numeric Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation {param}')
 
 	def get_pdynamics(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics \n
 		Snippet: value: int = driver.configure.prach.scount.get_pdynamics() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals Range: 1 to 1000
+			:return: statistic_count: numeric Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics?')
 		return Conversions.str_to_int(response)
 
 	def set_pdynamics(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics \n
 		Snippet: driver.configure.prach.scount.set_pdynamics(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals Range: 1 to 1000
+			:param statistic_count: numeric Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,168 +1,168 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RfSettings:
-	"""RfSettings commands group definition. 7 total commands, 2 Sub-groups, 5 group commands"""
+class RfSettingsCls:
+	"""RfSettings commands group definition. 7 total commands, 2 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rfSettings", core, parent)
+		self._cmd_group = CommandsGroup("rfSettings", core, parent)
 
 	@property
 	def pcc(self):
 		"""pcc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pcc'):
-			from .RfSettings_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
 	@property
 	def cc(self):
 		"""cc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cc'):
-			from .RfSettings_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	def get_eattenuation(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation \n
 		Snippet: value: float = driver.configure.rfSettings.get_eattenuation() \n
-		Defines an external attenuation (or gain, if the value is negative) , to be applied to the RF input connector.
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:EATTenuation:INPut
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:EATTenuation:INPut
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:EATTenuation:INPut \n
-			:return: rf_input_ext_att: Range: -50 dB to 90 dB, Unit: dB
+			:return: rf_input_ext_att: numeric Range: -50 dB to 90 dB, Unit: dB
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation?')
 		return Conversions.str_to_float(response)
 
 	def set_eattenuation(self, rf_input_ext_att: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation \n
 		Snippet: driver.configure.rfSettings.set_eattenuation(rf_input_ext_att = 1.0) \n
-		Defines an external attenuation (or gain, if the value is negative) , to be applied to the RF input connector.
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:EATTenuation:INPut
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:EATTenuation:INPut
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:EATTenuation:INPut \n
-			:param rf_input_ext_att: Range: -50 dB to 90 dB, Unit: dB
+			:param rf_input_ext_att: numeric Range: -50 dB to 90 dB, Unit: dB
 		"""
 		param = Conversions.decimal_value_to_str(rf_input_ext_att)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation {param}')
 
 	def get_umargin(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin \n
 		Snippet: value: float = driver.configure.rfSettings.get_umargin() \n
-		Sets the margin that the R&S CMW adds to the expected nominal power to determine its reference power. The reference power
-		minus the external input attenuation must be within the power range of the selected input connector; refer to the data
-		sheet.
+		Sets the margin that the measurement adds to the expected nominal power to determine the reference power. The reference
+		power minus the external input attenuation must be within the power range of the selected input connector. Refer to the
+		data sheet.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:UMARgin
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:UMARgin
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:UMARgin \n
-			:return: user_margin: Range: 0 dB to (55 dB + external attenuation - expected nominal power) , Unit: dB
+			:return: user_margin: numeric Range: 0 dB to (55 dB + external attenuation - expected nominal power) , Unit: dB
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin?')
 		return Conversions.str_to_float(response)
 
 	def set_umargin(self, user_margin: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin \n
 		Snippet: driver.configure.rfSettings.set_umargin(user_margin = 1.0) \n
-		Sets the margin that the R&S CMW adds to the expected nominal power to determine its reference power. The reference power
-		minus the external input attenuation must be within the power range of the selected input connector; refer to the data
-		sheet.
+		Sets the margin that the measurement adds to the expected nominal power to determine the reference power. The reference
+		power minus the external input attenuation must be within the power range of the selected input connector. Refer to the
+		data sheet.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:UMARgin
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:UMARgin
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:UMARgin \n
-			:param user_margin: Range: 0 dB to (55 dB + external attenuation - expected nominal power) , Unit: dB
+			:param user_margin: numeric Range: 0 dB to (55 dB + external attenuation - expected nominal power) , Unit: dB
 		"""
 		param = Conversions.decimal_value_to_str(user_margin)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin {param}')
 
 	def get_envelope_power(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower \n
 		Snippet: value: float = driver.configure.rfSettings.get_envelope_power() \n
 		Sets the expected nominal power of the measured RF signal.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:ENPMode
-			- CONFigure:LTE:SIGN<i>:ENPower
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:ENPMode
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:ENPower
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:ENPMode
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:ENPower \n
-			:return: exp_nom_pow: The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+			:return: exp_nom_pow: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower?')
 		return Conversions.str_to_float(response)
 
 	def set_envelope_power(self, exp_nom_pow: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower \n
 		Snippet: driver.configure.rfSettings.set_envelope_power(exp_nom_pow = 1.0) \n
 		Sets the expected nominal power of the measured RF signal.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:ENPMode
-			- CONFigure:LTE:SIGN<i>:ENPower
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:ENPMode
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:ENPower
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:ENPMode
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:ENPower \n
-			:param exp_nom_pow: The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+			:param exp_nom_pow: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		param = Conversions.decimal_value_to_str(exp_nom_pow)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower {param}')
 
 	def get_foffset(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset \n
 		Snippet: value: int = driver.configure.rfSettings.get_foffset() \n
 		Specifies a positive or negative frequency offset to be added to the carrier center frequency (method RsCmwLteMeas.
 		Configure.RfSettings.Cc.Frequency.set) .
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:FOFFset:UL
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:FOFFset:UL
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:FOFFset:UL
-			- CONFigure:LTE:SIGN<i>:FOFFset:UL:UCSPecific \n
-			:return: offset: Range: -100 kHz to 100 kHz, Unit: Hz
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:FOFFset:UL:UCSPecific \n
+			:return: offset: numeric Range: -100 kHz to 100 kHz, Unit: Hz
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset?')
 		return Conversions.str_to_int(response)
 
 	def set_foffset(self, offset: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset \n
 		Snippet: driver.configure.rfSettings.set_foffset(offset = 1) \n
 		Specifies a positive or negative frequency offset to be added to the carrier center frequency (method RsCmwLteMeas.
 		Configure.RfSettings.Cc.Frequency.set) .
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:FOFFset:UL
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:FOFFset:UL
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:FOFFset:UL
-			- CONFigure:LTE:SIGN<i>:FOFFset:UL:UCSPecific \n
-			:param offset: Range: -100 kHz to 100 kHz, Unit: Hz
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:FOFFset:UL:UCSPecific \n
+			:param offset: numeric Range: -100 kHz to 100 kHz, Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(offset)
 		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset {param}')
 
 	def get_ml_offset(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset \n
 		Snippet: value: float = driver.configure.rfSettings.get_ml_offset() \n
 		Varies the input level of the mixer in the analyzer path.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:MLOFfset
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:MLOFfset
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:MLOFfset \n
-			:return: mix_lev_offset: Range: -10 dB to 10 dB, Unit: dB
+			:return: mix_lev_offset: numeric Range: -10 dB to 10 dB, Unit: dB
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset?')
 		return Conversions.str_to_float(response)
 
 	def set_ml_offset(self, mix_lev_offset: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset \n
 		Snippet: driver.configure.rfSettings.set_ml_offset(mix_lev_offset = 1.0) \n
 		Varies the input level of the mixer in the analyzer path.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:MLOFfset
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:MLOFfset
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:MLOFfset \n
-			:param mix_lev_offset: Range: -10 dB to 10 dB, Unit: dB
+			:param mix_lev_offset: numeric Range: -10 dB to 10 dB, Unit: dB
 		"""
 		param = Conversions.decimal_value_to_str(mix_lev_offset)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset {param}')
 
-	def clone(self) -> 'RfSettings':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RfSettingsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RfSettings(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RfSettingsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/Cc.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	@property
-	def frequency(self):
-		"""frequency commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_frequency'):
-			from .Cc_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
-		return self._frequency
+	def fetch(self, xvalue: int or bool, carrierComponent=repcap.CarrierComponent.Default) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:REFMarker:PMONitor:CC<Nr> \n
+		Snippet: value: float = driver.multiEval.referenceMarker.pmonitor.cc.fetch(xvalue = 1, carrierComponent = repcap.CarrierComponent.Default) \n
+		Uses the reference marker on the power monitor trace. \n
+		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
+			:param xvalue: (integer or boolean) integer Absolute X value of the marker position (subframe number) Range: 0 to 319
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+			:return: yvalue: float Absolute Y value of the marker position Unit: dBm"""
+		param = Conversions.decimal_or_bool_value_to_str(xvalue)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:REFMarker:PMONitor:CC{carrierComponent_cmd_val}? {param}', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc_/Frequency.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/Frequency.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,47 +1,46 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	def set(self, analyzer_freq: float, carrierComponent=repcap.CarrierComponent.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:CC<Nr>:FREQuency \n
 		Snippet: driver.configure.rfSettings.cc.frequency.set(analyzer_freq = 1.0, carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the center frequency of component carrier CC<no>. Without carrier aggregation, you can omit <no>. Using the unit
 		CH, the frequency can be set via the channel number. The allowed channel number range depends on the operating band, see
-		'Frequency Bands'.
+		'Frequency bands'.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:CHANnel:UL
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:CHANnel:UL
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:CHANnel:UL
-		The supported frequency range depends on the instrument model and the available options. The supported range can be
-		smaller than stated here. Refer to the preface of your model-specific base unit manual. \n
-			:param analyzer_freq: Range: 70 MHz to 6 GHz, Unit: Hz
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
+		For the supported frequency range, see 'Frequency ranges'. \n
+			:param analyzer_freq: numeric Unit: Hz
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
 		param = Conversions.decimal_value_to_str(analyzer_freq)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:CC{carrierComponent_cmd_val}:FREQuency {param}')
 
 	def get(self, carrierComponent=repcap.CarrierComponent.Default) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:CC<Nr>:FREQuency \n
 		Snippet: value: float = driver.configure.rfSettings.cc.frequency.get(carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the center frequency of component carrier CC<no>. Without carrier aggregation, you can omit <no>. Using the unit
 		CH, the frequency can be set via the channel number. The allowed channel number range depends on the operating band, see
-		'Frequency Bands'.
+		'Frequency bands'.
 			INTRO_CMD_HELP: For the combined signal path scenario, use: \n
-			- CONFigure:LTE:SIGN<i>:CHANnel:UL
+			- CONFigure:LTE:SIGN<i>:RFSettings[:PCC]:CHANnel:UL
 			- CONFigure:LTE:SIGN<i>:RFSettings:SCC<c>:CHANnel:UL
-		The supported frequency range depends on the instrument model and the available options. The supported range can be
-		smaller than stated here. Refer to the preface of your model-specific base unit manual. \n
+		For the supported frequency range, see 'Frequency ranges'. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: analyzer_freq: Range: 70 MHz to 6 GHz, Unit: Hz"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+			:return: analyzer_freq: numeric Unit: Hz"""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:CC{carrierComponent_cmd_val}:FREQuency?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/RfSettings_/Pcc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Pcc.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	def get_frequency(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings[:PCC]:FREQuency \n
 		Snippet: value: float = driver.configure.rfSettings.pcc.get_frequency() \n
 		No command help available \n
 			:return: analyzer_freq: No help available
 		"""
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,65 +1,63 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 7 total commands, 2 Sub-groups, 5 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 7 total commands, 2 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	@property
 	def scount(self):
 		"""scount commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scount'):
-			from .Srs_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
 		return self._scount
 
 	@property
 	def limit(self):
-		"""limit commands group. 0 Sub-classes, 1 commands."""
+		"""limit commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .Srs_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:TOUT \n
 		Snippet: value: float = driver.configure.srs.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, timeout: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:TOUT \n
 		Snippet: driver.configure.srs.set_timeout(timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(timeout)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:REPetition \n
@@ -85,43 +83,43 @@
 
 	# noinspection PyTypeChecker
 	def get_scondition(self) -> enums.StopCondition:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition \n
 		Snippet: value: enums.StopCondition = driver.configure.srs.get_scondition() \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:return: stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition?')
 		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
 
 	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition \n
 		Snippet: driver.configure.srs.set_scondition(stop_condition = enums.StopCondition.NONE) \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:param stop_condition: NONE | SLFail NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception \n
 		Snippet: value: bool = driver.configure.srs.get_mo_exception() \n
 		Specifies whether measurement results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
-			:return: meas_on_exception: OFF | ON OFF: Faulty results are rejected ON: Results are never rejected
+			:return: meas_on_exception: OFF | ON OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception?')
 		return Conversions.str_to_bool(response)
 
 	def set_mo_exception(self, meas_on_exception: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception \n
 		Snippet: driver.configure.srs.set_mo_exception(meas_on_exception = False) \n
 		Specifies whether measurement results that the R&S CMW identifies as faulty or inaccurate are rejected. \n
-			:param meas_on_exception: OFF | ON OFF: Faulty results are rejected ON: Results are never rejected
+			:param meas_on_exception: OFF | ON OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		param = Conversions.bool_to_str(meas_on_exception)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception {param}')
 
 	def get_hdmode(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:HDMode \n
 		Snippet: value: bool = driver.configure.srs.get_hdmode() \n
@@ -136,14 +134,14 @@
 		Snippet: driver.configure.srs.set_hdmode(high_dynamic_mode = False) \n
 		Enables or disables the high dynamic mode for power dynamics measurements. \n
 			:param high_dynamic_mode: OFF | ON
 		"""
 		param = Conversions.bool_to_str(high_dynamic_mode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:HDMode {param}')
 
-	def clone(self) -> 'Srs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Srs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Configure_/Srs_/Scount.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/Scount.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	def get_pdynamics(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics \n
 		Snippet: value: int = driver.configure.srs.scount.get_pdynamics() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals Range: 1 to 1000
+			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics?')
 		return Conversions.str_to_int(response)
 
 	def set_pdynamics(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics \n
 		Snippet: driver.configure.srs.scount.set_pdynamics(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals Range: 1 to 1000
+			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics {param}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,216 +1,216 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 519 total commands, 16 Sub-groups, 3 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 546 total commands, 19 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .MultiEval_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
+	def referenceMarker(self):
+		"""referenceMarker commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_referenceMarker'):
+			from .ReferenceMarker import ReferenceMarkerCls
+			self._referenceMarker = ReferenceMarkerCls(self._core, self._cmd_group)
+		return self._referenceMarker
+
+	@property
+	def amarker(self):
+		"""amarker commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_amarker'):
+			from .Amarker import AmarkerCls
+			self._amarker = AmarkerCls(self._core, self._cmd_group)
+		return self._amarker
+
+	@property
+	def dmarker(self):
+		"""dmarker commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dmarker'):
+			from .Dmarker import DmarkerCls
+			self._dmarker = DmarkerCls(self._core, self._cmd_group)
+		return self._dmarker
+
+	@property
 	def trace(self):
 		"""trace commands group. 10 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .MultiEval_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
 	def vfThroughput(self):
 		"""vfThroughput commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_vfThroughput'):
-			from .MultiEval_.VfThroughput import VfThroughput
-			self._vfThroughput = VfThroughput(self._core, self._base)
+			from .VfThroughput import VfThroughputCls
+			self._vfThroughput = VfThroughputCls(self._core, self._cmd_group)
 		return self._vfThroughput
 
 	@property
 	def evMagnitude(self):
 		"""evMagnitude commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_evMagnitude'):
-			from .MultiEval_.EvMagnitude import EvMagnitude
-			self._evMagnitude = EvMagnitude(self._core, self._base)
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
 		return self._evMagnitude
 
 	@property
 	def merror(self):
 		"""merror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_merror'):
-			from .MultiEval_.Merror import Merror
-			self._merror = Merror(self._core, self._base)
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
 		return self._merror
 
 	@property
 	def perror(self):
 		"""perror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_perror'):
-			from .MultiEval_.Perror import Perror
-			self._perror = Perror(self._core, self._base)
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
 		return self._perror
 
 	@property
 	def inbandEmission(self):
 		"""inbandEmission commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_inbandEmission'):
-			from .MultiEval_.InbandEmission import InbandEmission
-			self._inbandEmission = InbandEmission(self._core, self._base)
+			from .InbandEmission import InbandEmissionCls
+			self._inbandEmission = InbandEmissionCls(self._core, self._cmd_group)
 		return self._inbandEmission
 
 	@property
 	def esFlatness(self):
 		"""esFlatness commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_esFlatness'):
-			from .MultiEval_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
+			from .EsFlatness import EsFlatnessCls
+			self._esFlatness = EsFlatnessCls(self._core, self._cmd_group)
 		return self._esFlatness
 
 	@property
 	def evmc(self):
 		"""evmc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_evmc'):
-			from .MultiEval_.Evmc import Evmc
-			self._evmc = Evmc(self._core, self._base)
+			from .Evmc import EvmcCls
+			self._evmc = EvmcCls(self._core, self._cmd_group)
 		return self._evmc
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_modulation'):
-			from .MultiEval_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 7 Sub-classes, 0 commands."""
 		if not hasattr(self, '_seMask'):
-			from .MultiEval_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aclr'):
-			from .MultiEval_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .MultiEval_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
 	@property
 	def pmonitor(self):
 		"""pmonitor commands group. 6 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pmonitor'):
-			from .MultiEval_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
 		return self._pmonitor
 
 	@property
 	def bler(self):
 		"""bler commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_bler'):
-			from .MultiEval_.Bler import Bler
-			self._bler = Bler(self._core, self._base)
+			from .Bler import BlerCls
+			self._bler = BlerCls(self._core, self._cmd_group)
 		return self._bler
 
 	@property
 	def listPy(self):
 		"""listPy commands group. 9 Sub-classes, 0 commands."""
 		if not hasattr(self, '_listPy'):
-			from .MultiEval_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
-	def initiate(self) -> None:
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: INITiate:LTE:MEASurement<Instance>:MEValuation \n
 		Snippet: driver.multiEval.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:LTE:MEASurement<Instance>:MEValuation')
-
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:MEValuation')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
 	def stop(self) -> None:
 		"""SCPI: STOP:LTE:MEASurement<Instance>:MEValuation \n
 		Snippet: driver.multiEval.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
 		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:MEValuation')
 
-	def stop_with_opc(self) -> None:
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: STOP:LTE:MEASurement<Instance>:MEValuation \n
 		Snippet: driver.multiEval.stop_with_opc() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:MEValuation')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def abort(self) -> None:
+	def abort(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: ABORt:LTE:MEASurement<Instance>:MEValuation \n
 		Snippet: driver.multiEval.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:LTE:MEASurement<Instance>:MEValuation')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:MEValuation')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Aclr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Aclr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def dchType(self):
-		"""dchType commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dchType'):
-			from .Aclr_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
-		return self._dchType
-
-	@property
-	def dallocation(self):
-		"""dallocation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dallocation'):
-			from .Aclr_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
-		return self._dallocation
-
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NegativCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NegativCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,32 +2,32 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: float: ACLR for the first E-UTRA channel with lower frequency Unit: dB
-			- Eutra: float: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: float: ACLR for the first E-UTRA channel with higher frequency Unit: dB
-			- Utra_1_Pos: float: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: float: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Utra_2_Neg: float: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: float: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: float: float ACLR for the first E-UTRA channel with lower frequency Unit: dB
+			- Eutra: float: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: float: float ACLR for the first E-UTRA channel with higher frequency Unit: dB
+			- Utra_1_Pos: float: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: float: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Utra_2_Neg'),
 			ArgStruct.scalar_float('Utra_1_Neg'),
 			ArgStruct.scalar_float('Eutra_Negativ'),
 			ArgStruct.scalar_float('Eutra'),
 			ArgStruct.scalar_float('Eutra_Positiv'),
@@ -62,22 +62,22 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel with lower frequency Unit: dB
-			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: enums.ResultStatus2: ACLR for the first E-UTRA channel with higher frequency Unit: dB
-			- Utra_1_Pos: enums.ResultStatus2: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: enums.ResultStatus2: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Utra_2_Neg: enums.ResultStatus2: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: enums.ResultStatus2: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: enums.ResultStatus2: float ACLR for the first E-UTRA channel with lower frequency Unit: dB
+			- Eutra: enums.ResultStatus2: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: enums.ResultStatus2: float ACLR for the first E-UTRA channel with higher frequency Unit: dB
+			- Utra_1_Pos: enums.ResultStatus2: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: enums.ResultStatus2: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_enum('Utra_2_Neg', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Utra_1_Neg', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Eutra_Negativ', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Eutra', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Eutra_Positiv', enums.ResultStatus2),
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,32 +2,32 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: float: ACLR for the first E-UTRA channel with lower frequency Unit: dB
-			- Eutra: float: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: float: ACLR for the first E-UTRA channel with higher frequency Unit: dB
-			- Utra_1_Pos: float: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: float: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Utra_2_Neg: float: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: float: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: float: float ACLR for the first E-UTRA channel with lower frequency Unit: dB
+			- Eutra: float: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: float: float ACLR for the first E-UTRA channel with higher frequency Unit: dB
+			- Utra_1_Pos: float: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: float: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Utra_2_Neg'),
 			ArgStruct.scalar_float('Utra_1_Neg'),
 			ArgStruct.scalar_float('Eutra_Negativ'),
 			ArgStruct.scalar_float('Eutra'),
 			ArgStruct.scalar_float('Eutra_Positiv'),
@@ -62,22 +62,22 @@
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel with lower frequency Unit: dB
-			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: enums.ResultStatus2: ACLR for the first E-UTRA channel with higher frequency Unit: dB
-			- Utra_1_Pos: enums.ResultStatus2: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: enums.ResultStatus2: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Utra_2_Neg: enums.ResultStatus2: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: enums.ResultStatus2: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: enums.ResultStatus2: float ACLR for the first E-UTRA channel with lower frequency Unit: dB
+			- Eutra: enums.ResultStatus2: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: enums.ResultStatus2: float ACLR for the first E-UTRA channel with higher frequency Unit: dB
+			- Utra_1_Pos: enums.ResultStatus2: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: enums.ResultStatus2: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_enum('Utra_2_Neg', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Utra_1_Neg', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Eutra_Negativ', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Eutra', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Eutra_Positiv', enums.ResultStatus2),
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/Dallocation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nr_Res_Blocks: int: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: int: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Aclr_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/DchType.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.UplinkChannelType:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DCHType \n
 		Snippet: value: enums.UplinkChannelType = driver.multiEval.aclr.dchType.fetch() \n
 		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Bler.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Bler.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,42 +1,42 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.StructBase import StructBase
 from ...Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bler:
-	"""Bler commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class BlerCls:
+	"""Bler commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bler", core, parent)
+		self._cmd_group = CommandsGroup("bler", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Ack: float: Received acknowledgments (percentage of sent scheduled subframes) Unit: %
-			- Nack: float: Received negative acknowledgments (percentage of sent scheduled subframes) Unit: %
-			- Bler: int: Block error ratio (percentage of sent scheduled subframes for which no ACK has been received) Unit: %
-			- Dtx: float: Percentage of sent scheduled subframes for which no ACK and no NACK has been received Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Ack: float: float Received acknowledgments (percentage of sent scheduled subframes) . Unit: %
+			- Nack: float: float Received negative acknowledgments (percentage of sent scheduled subframes) . Unit: %
+			- Bler: float: float Block error ratio (percentage of sent scheduled subframes for which no ACK has been received) . Unit: %
+			- Dtx: float: float Percentage of sent scheduled subframes for which no ACK and no NACK has been received. Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Ack'),
 			ArgStruct.scalar_float('Nack'),
-			ArgStruct.scalar_int('Bler'),
+			ArgStruct.scalar_float('Bler'),
 			ArgStruct.scalar_float('Dtx')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Ack: float = None
 			self.Nack: float = None
-			self.Bler: int = None
+			self.Bler: float = None
 			self.Dtx: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:BLER \n
 		Snippet: value: ResultData = driver.multiEval.bler.fetch() \n
 		Returns the block error ratio results determined from all captured subframes. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .EsFlatness_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .EsFlatness_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .EsFlatness_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .EsFlatness_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Extreme.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
 			ArgStruct.scalar_float('Max_R_2_Min_R_1'),
@@ -47,55 +47,55 @@
 			self.Max_R_2_Min_R_1: float = None
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.average.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
+		Snippet: value: ResultData = driver.multiEval.esFlatness.extreme.read() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.average.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
+		Snippet: value: ResultData = driver.multiEval.esFlatness.extreme.fetch() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.average.calculate() \n
-		Return current, average and extreme single value results of the equalizer spectrum flatness measurement.
-		See also 'Equalizer Spectrum Flatness Limits'. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
+		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.extreme.calculate() \n
+		Return current, average and extreme single-value results of the equalizer spectrum flatness measurement.
+		See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 4 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 4 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def scIndex(self):
 		"""scIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scIndex'):
-			from .Current_.ScIndex import ScIndex
-			self._scIndex = ScIndex(self._core, self._base)
+			from .ScIndex import ScIndexCls
+			self._scIndex = ScIndexCls(self._core, self._cmd_group)
 		return self._scIndex
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
 			ArgStruct.scalar_float('Max_R_2_Min_R_1'),
@@ -57,61 +57,61 @@
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.esFlatness.current.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.esFlatness.current.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.current.calculate() \n
-		Return current, average and extreme single value results of the equalizer spectrum flatness measurement.
-		See also 'Equalizer Spectrum Flatness Limits'. \n
+		Return current, average and extreme single-value results of the equalizer spectrum flatness measurement.
+		See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current_/ScIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/ScIndex.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,47 +1,57 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ScIndex:
-	"""ScIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ScIndexCls:
+	"""ScIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scIndex", core, parent)
+		self._cmd_group = CommandsGroup("scIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Maximum_1: int: SC index of 'Max (Range 1) '
-			- Minimum_1: int: SC index of 'Min (Range 1) '
-			- Maximum_2: int: SC index of 'Max (Range 2) '
-			- Minimum_2: int: SC index of 'Min (Range 2) '"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Maximum_1: int: decimal SC index of max (range 1)
+			- Minimum_1: int: decimal SC index of min (range 1)
+			- Maximum_2: int: decimal SC index of max (range 2)
+			- Minimum_2: int: decimal SC index of min (range 2)"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_int('Maximum_1'),
 			ArgStruct.scalar_int('Minimum_1'),
 			ArgStruct.scalar_int('Maximum_2'),
 			ArgStruct.scalar_int('Minimum_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Maximum_1: int = None
 			self.Minimum_1: int = None
 			self.Maximum_2: int = None
 			self.Minimum_2: int = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent:SCINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.esFlatness.current.scIndex.fetch() \n
-		Returns subcarrier indices of the equalizer spectrum flatness measurement. At these SC indices, the current minimum and
-		maximum power of the equalizer coefficients have been detected within range 1 and range 2. \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent:SCINdex \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.current.scIndex.fetch(segment = repcap.Segment.Default) \n
+		Return subcarrier indices of the equalizer spectrum flatness measurement for segment <no> in list mode. At these SC
+		indices, the current minimum and maximum power of the equalizer coefficients have been detected within range 1 and range
+		2. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent:SCINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent:SCINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Extreme.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,101 +1,106 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
 			ArgStruct.scalar_float('Max_R_2_Min_R_1'),
 			ArgStruct.scalar_float('Min_R_1'),
 			ArgStruct.scalar_float('Max_R_1'),
 			ArgStruct.scalar_float('Min_R_2'),
 			ArgStruct.scalar_float('Max_R_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Ripple_1: float = None
 			self.Ripple_2: float = None
 			self.Max_R_1_Min_R_2: float = None
 			self.Max_R_2_Min_R_1: float = None
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
-	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.extreme.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.extreme.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.ResultData())
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:EXTReme \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.extreme.fetch(segment = repcap.Segment.Default) \n
+		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
+		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:EXTReme?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) . Unit: dB
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) . Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.extreme.calculate() \n
-		Return current, average and extreme single value results of the equalizer spectrum flatness measurement.
-		See also 'Equalizer Spectrum Flatness Limits'. \n
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
+
+	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:EXTReme \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.extreme.calculate(segment = repcap.Segment.Default) \n
+		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified equalizer spectrum flatness limits. Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
 			ArgStruct.scalar_float('Max_R_2_Min_R_1'),
@@ -49,19 +49,19 @@
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.esFlatness.standardDev.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.esFlatness.standardDev.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvMagnitude:
-	"""EvMagnitude commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class EvMagnitudeCls:
+	"""EvMagnitude commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("evMagnitude", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .EvMagnitude_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .EvMagnitude_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .EvMagnitude_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def peak(self):
 		"""peak commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_peak'):
-			from .EvMagnitude_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
 		return self._peak
 
-	def clone(self) -> 'EvMagnitude':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvMagnitudeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EvMagnitude(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvMagnitudeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,53 +1,51 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position Unit: %
-			- High: List[float]: EVM value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position Unit: %
+			- High: List[float]: float EVM value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.read() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.average.read() \n
+		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.fetch() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.average.fetch() \n
+		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,53 +1,51 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position Unit: %
-			- High: List[float]: EVM value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position Unit: %
+			- High: List[float]: float EVM value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.read() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.current.read() \n
+		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.fetch() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.current.fetch() \n
+		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Maximum.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position Unit: %
-			- High: List[float]: EVM value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position Unit: %
+			- High: List[float]: float EVM value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -33,21 +33,19 @@
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.evMagnitude.maximum.read() \n
 		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.evMagnitude.maximum.fetch() \n
 		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Peak_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Peak_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Peak_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -4,50 +4,48 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position Unit: %
-			- High: List[float]: EVM value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position Unit: %
+			- High: List[float]: float EVM value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.maximum.read() \n
 		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.maximum.fetch() \n
 		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,53 +1,53 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Types import DataType
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position Unit: %
-			- High: List[float]: EVM value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float Phase error value for low EVM window position Unit: deg
+			- High: List[float]: float Phase error value for high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.current.read() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.perror.current.read() \n
+		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Magnitude Error,
+		Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.current.fetch() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.perror.current.fetch() \n
+		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Magnitude Error,
+		Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,53 +1,51 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Types import DataType
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position Unit: %
-			- High: List[float]: EVM value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position Unit: %
+			- High: List[float]: float EVM value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.maximum.read() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.read() \n
+		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.maximum.fetch() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.fetch() \n
+		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Error Vector
-		Magnitude'. \n
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evmc:
-	"""Evmc commands group definition. 8 total commands, 1 Sub-groups, 0 group commands"""
+class BlerCls:
+	"""Bler commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evmc", core, parent)
+		self._cmd_group = CommandsGroup("bler", core, parent)
 
 	@property
-	def peak(self):
-		"""peak commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .Evmc_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def sframes(self):
+		"""sframes commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sframes'):
+			from .Sframes import SframesCls
+			self._sframes = SframesCls(self._core, self._cmd_group)
+		return self._sframes
 
-	def clone(self) -> 'Evmc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BlerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Evmc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BlerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,59 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 14 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Peak_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Peak_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Peak_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Peak_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Average.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> float:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage \n
 		Snippet: value: float = driver.multiEval.evmc.peak.average.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_average: Unit: %"""
+			:return: evm_cpeak_average: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage \n
 		Snippet: value: float = driver.multiEval.evmc.peak.average.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_average: Unit: %"""
+			:return: evm_cpeak_average: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> float:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent \n
 		Snippet: value: float = driver.multiEval.evmc.peak.current.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_current: Unit: %"""
+			:return: evm_cpeak_current: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent \n
 		Snippet: value: float = driver.multiEval.evmc.peak.current.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_current: Unit: %"""
+			:return: evm_cpeak_current: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Maximum.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> float:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum \n
 		Snippet: value: float = driver.multiEval.evmc.peak.maximum.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_maximum: Unit: %"""
+			:return: evm_cpeak_maximum: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum \n
 		Snippet: value: float = driver.multiEval.evmc.peak.maximum.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_maximum: Unit: %"""
+			:return: evm_cpeak_maximum: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/StandardDev.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def read(self) -> float:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation \n
 		Snippet: value: float = driver.multiEval.evmc.peak.standardDev.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_std_dev: Unit: %"""
+			:return: evm_cpeak_std_dev: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation \n
 		Snippet: value: float = driver.multiEval.evmc.peak.standardDev.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_cpeak_std_dev: Unit: %"""
+			:return: evm_cpeak_std_dev: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InbandEmission:
-	"""InbandEmission commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class ArrayCls:
+	"""Array commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inbandEmission", core, parent)
+		self._cmd_group = CommandsGroup("array", core, parent)
 
 	@property
-	def cc(self):
-		"""cc commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cc'):
-			from .InbandEmission_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
+	def start(self):
+		"""start commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_start'):
+			from .Start import StartCls
+			self._start = StartCls(self._core, self._cmd_group)
+		return self._start
 
-	def clone(self) -> 'InbandEmission':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def length(self):
+		"""length commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_length'):
+			from .Length import LengthCls
+			self._length = LengthCls(self._core, self._cmd_group)
+		return self._length
+
+	def clone(self) -> 'ArrayCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InbandEmission(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ArrayCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .Cc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
+	def frequency(self):
+		"""frequency commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_frequency'):
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
+		return self._frequency
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,27 +2,27 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified inband emission limits. Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -35,9 +35,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
 		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Current/RbIndex.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,59 +1,41 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified inband emission limits. Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Rb_Index: int: decimal Resource block index"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Rb_Index: int = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
-		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
-		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
-		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
-		displayed at the GUI. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:CURRent:RBINdex \n
+		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.current.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Return resource block indices for CC<no> inband emission margins. At these RB indices, the CURRent and EXTReme margins
+		have been detected (see method RsCmwLteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/RbIndex.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,40 +2,40 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified inband emission limits. Unit: %
-			- Rb_Index: int: Resource block index"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Rb_Index: int: decimal Resource block index"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.current.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.extreme.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return resource block indices for CC<no> inband emission margins. At these RB indices, the CURRent and EXTReme margins
 		have been detected (see method RsCmwLteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified inband emission limits. Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -43,17 +43,17 @@
 		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.extreme.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
 		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Maximum.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,41 +1,49 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified inband emission limits. Unit: %
-			- Rb_Index: int: Resource block index"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Tx_Power: float = None
 
-	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.extreme.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
-		Return resource block indices for CC<no> inband emission margins. At these RB indices, the CURRent and EXTReme margins
-		have been detected (see method RsCmwLteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
+	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.maximum.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
+
+	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.maximum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Returns the TX power of carrier CC<no>. \n
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,27 +2,27 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified inband emission limits. Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -35,9 +35,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
 		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,91 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 344 total commands, 9 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 24 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def sreliability(self):
-		"""sreliability commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_sreliability'):
-			from .ListPy_.Sreliability import Sreliability
-			self._sreliability = Sreliability(self._core, self._base)
-		return self._sreliability
+	def obw(self):
+		"""obw commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_obw'):
+			from .Obw import ObwCls
+			self._obw = ObwCls(self._core, self._cmd_group)
+		return self._obw
+
+	@property
+	def txPower(self):
+		"""txPower commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_txPower'):
+			from .TxPower import TxPowerCls
+			self._txPower = TxPowerCls(self._core, self._cmd_group)
+		return self._txPower
+
+	@property
+	def margin(self):
+		"""margin commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
+
+	@property
+	def dchType(self):
+		"""dchType commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dchType'):
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
+		return self._dchType
+
+	@property
+	def dallocation(self):
+		"""dallocation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dallocation'):
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
+		return self._dallocation
 
-	@property
-	def modulation(self):
-		"""modulation commands group. 13 Sub-classes, 0 commands."""
-		if not hasattr(self, '_modulation'):
-			from .ListPy_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
-		return self._modulation
-
-	@property
-	def inbandEmission(self):
-		"""inbandEmission commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_inbandEmission'):
-			from .ListPy_.InbandEmission import InbandEmission
-			self._inbandEmission = InbandEmission(self._core, self._base)
-		return self._inbandEmission
-
-	@property
-	def esFlatness(self):
-		"""esFlatness commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_esFlatness'):
-			from .ListPy_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
-		return self._esFlatness
-
-	@property
-	def segment(self):
-		"""segment commands group. 7 Sub-classes, 0 commands."""
-		if not hasattr(self, '_segment'):
-			from .ListPy_.Segment import Segment
-			self._segment = Segment(self._core, self._base)
-		return self._segment
-
-	@property
-	def seMask(self):
-		"""seMask commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_seMask'):
-			from .ListPy_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
-
-	@property
-	def aclr(self):
-		"""aclr commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_aclr'):
-			from .ListPy_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
-		return self._aclr
-
-	@property
-	def power(self):
-		"""power commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_power'):
-			from .ListPy_.Power import Power
-			self._power = Power(self._core, self._base)
-		return self._power
-
-	@property
-	def pmonitor(self):
-		"""pmonitor commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pmonitor'):
-			from .ListPy_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
-		return self._pmonitor
-
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 22 total commands, 4 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 22 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def utra(self):
 		"""utra commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_utra'):
-			from .Aclr_.Utra import Utra
-			self._utra = Utra(self._core, self._base)
+			from .Utra import UtraCls
+			self._utra = UtraCls(self._core, self._cmd_group)
 		return self._utra
 
 	@property
 	def eutra(self):
 		"""eutra commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_eutra'):
-			from .Aclr_.Eutra import Eutra
-			self._eutra = Eutra(self._core, self._base)
+			from .Eutra import EutraCls
+			self._eutra = EutraCls(self._core, self._cmd_group)
 		return self._eutra
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Aclr_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Aclr_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Dallocation.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,41 +4,41 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: List[int]: Number of allocated resource blocks
-			- Offset_Res_Blocks: List[int]: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nr_Res_Blocks: List[int]: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: List[int]: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Nr_Res_Blocks', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('Offset_Res_Blocks', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: List[int] = None
 			self.Offset_Res_Blocks: List[int] = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.aclr.dallocation.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DALLocation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.dallocation.fetch() \n
 		Return the detected allocation for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected allocation results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>,
-		<OffsetResBlocks>}Seg 1, {<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>, <OffsetResBlocks>}Seg 1,
+		{<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DALLocation?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/DchType.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,27 +5,27 @@
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.UplinkChannelType]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DCHType \n
-		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.aclr.dchType.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType \n
+		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.modulation.dchType.fetch() \n
 		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected channel type results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: channel_type: PUSCh | PUCCh Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DCHType?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Eutra:
-	"""Eutra commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class InbandEmissionCls:
+	"""InbandEmission commands group definition. 18 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eutra", core, parent)
+		self._cmd_group = CommandsGroup("inbandEmission", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Eutra_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def scc(self):
+		"""scc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Eutra_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def cc(self):
+		"""cc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Eutra_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def margin(self):
+		"""margin commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
 
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Eutra_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	def clone(self) -> 'Eutra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'InbandEmissionCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Eutra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InbandEmissionCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,36 +5,36 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.average.fetch() \n
 		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
 		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: eutra: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage \n
 		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.average.calculate() \n
 		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
 		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: eutra: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Current.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,36 +5,36 @@
 from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.current.fetch() \n
 		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
 		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: eutra: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent \n
 		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.current.calculate() \n
 		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
 		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: eutra: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Negativ_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Negativ_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Negativ':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NegativCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Negativ(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NegativCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,38 +5,38 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.negativ.average.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_negativ: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_negativ: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage \n
 		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.negativ.average.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_negativ: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_negativ: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,38 +5,38 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.negativ.current.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_negativ: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_negativ: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent \n
 		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.negativ.current.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_negativ: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_negativ: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class EvmSymbolCls:
+	"""EvmSymbol commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("evmSymbol", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Positiv_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Positiv_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Positiv':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'EvmSymbolCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Positiv(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmSymbolCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,38 +5,38 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.positiv.average.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_positiv: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_positiv: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage \n
 		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.positiv.average.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_positiv: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_positiv: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,38 +5,38 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.positiv.current.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_positiv: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_positiv: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent \n
 		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.positiv.current.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: eutra_positiv: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: eutra_positiv: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Utra:
-	"""Utra commands group definition. 8 total commands, 2 Sub-groups, 0 group commands
-	Repeated Capability: UtraAdjChannel, default value after init: UtraAdjChannel.Ch1"""
+class AreaCls:
+	"""Area commands group definition. 6 total commands, 2 Subgroups, 0 group commands
+	Repeated Capability: Area, default value after init: Area.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("utra", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_utraAdjChannel_get', 'repcap_utraAdjChannel_set', repcap.UtraAdjChannel.Ch1)
+		self._cmd_group = CommandsGroup("area", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_area_get', 'repcap_area_set', repcap.Area.Nr1)
 
-	def repcap_utraAdjChannel_set(self, enum_value: repcap.UtraAdjChannel) -> None:
+	def repcap_area_set(self, area: repcap.Area) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to UtraAdjChannel.Default
-		Default value after init: UtraAdjChannel.Ch1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Area.Default
+		Default value after init: Area.Nr1"""
+		self._cmd_group.set_repcap_enum_value(area)
 
-	def repcap_utraAdjChannel_get(self) -> repcap.UtraAdjChannel:
+	def repcap_area_get(self) -> repcap.Area:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def negativ(self):
-		"""negativ commands group. 2 Sub-classes, 0 commands."""
+		"""negativ commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Utra_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
 	def positiv(self):
-		"""positiv commands group. 2 Sub-classes, 0 commands."""
+		"""positiv commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Utra_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	def clone(self) -> 'Utra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AreaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Utra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AreaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Negativ_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Negativ_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Negativ':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'PerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Negativ(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,42 +6,42 @@
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.negativ.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.positiv.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_negativ: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_positiv: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.negativ.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:AVERage \n
+		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.positiv.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_negativ: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_positiv: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:AVERage?', suppressed)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/Current.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,42 +6,42 @@
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.negativ.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.positiv.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_negativ: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_positiv: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.negativ.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:CURRent \n
+		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.positiv.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_negativ: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_positiv: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:CURRent?', suppressed)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Positiv_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Positiv_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Positiv':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Positiv(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,42 +6,42 @@
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.positiv.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.negativ.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_positiv: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_negativ: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.positiv.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:AVERage \n
+		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.negativ.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_positiv: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_negativ: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:AVERage?', suppressed)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,42 +6,42 @@
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import enums
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.positiv.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.negativ.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_positiv: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_negativ: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.positiv.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:CURRent \n
+		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.negativ.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:return: utra_positiv: No help available"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+			:return: utra_negativ: No help available"""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:CURRent?', suppressed)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,59 +1,75 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 30 total commands, 5 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 20 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def ripple(self):
-		"""ripple commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_ripple'):
-			from .EsFlatness_.Ripple import Ripple
-			self._ripple = Ripple(self._core, self._base)
-		return self._ripple
-
-	@property
-	def difference(self):
-		"""difference commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_difference'):
-			from .EsFlatness_.Difference import Difference
-			self._difference = Difference(self._core, self._base)
-		return self._difference
-
-	@property
-	def minr(self):
-		"""minr commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_minr'):
-			from .EsFlatness_.Minr import Minr
-			self._minr = Minr(self._core, self._base)
-		return self._minr
-
-	@property
-	def maxr(self):
-		"""maxr commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_maxr'):
-			from .EsFlatness_.Maxr import Maxr
-			self._maxr = Maxr(self._core, self._base)
-		return self._maxr
-
-	@property
-	def scIndex(self):
-		"""scIndex commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_scIndex'):
-			from .EsFlatness_.ScIndex import ScIndex
-			self._scIndex = ScIndex(self._core, self._base)
-		return self._scIndex
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	@property
+	def margin(self):
+		"""margin commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
+
+	@property
+	def dchType(self):
+		"""dchType commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dchType'):
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
+		return self._dchType
+
+	@property
+	def dallocation(self):
+		"""dallocation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dallocation'):
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
+		return self._dallocation
+
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Difference:
-	"""Difference commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
+class DifferenceCls:
+	"""Difference commands group definition. 7 total commands, 4 Subgroups, 0 group commands
 	Repeated Capability: Difference, default value after init: Difference.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("difference", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_difference_get', 'repcap_difference_set', repcap.Difference.Nr1)
+		self._cmd_group = CommandsGroup("difference", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_difference_get', 'repcap_difference_set', repcap.Difference.Nr1)
 
-	def repcap_difference_set(self, enum_value: repcap.Difference) -> None:
+	def repcap_difference_set(self, difference: repcap.Difference) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Difference.Default
 		Default value after init: Difference.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(difference)
 
 	def repcap_difference_get(self) -> repcap.Difference:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Difference_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Difference_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Difference_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Difference_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Difference':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DifferenceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Difference(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DifferenceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.average.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, difference=repcap.Difference.Default) -> List[float]:
+	def calculate(self, difference=repcap.Difference.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.average.calculate(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.difference.average.calculate(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.current.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, difference=repcap.Difference.Default) -> List[float]:
+	def calculate(self, difference=repcap.Difference.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.current.calculate(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.difference.current.calculate(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.extreme.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, difference=repcap.Difference.Default) -> List[float]:
+	def calculate(self, difference=repcap.Difference.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.extreme.calculate(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.difference.extreme.calculate(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/StandardDev.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.standardDev.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment Unit: dB"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: float Comma-separated list of values, one per measured segment Unit: dB"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maxr:
-	"""Maxr commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
-	Repeated Capability: MaxRange, default value after init: MaxRange.Nr1"""
+class MinrCls:
+	"""Minr commands group definition. 7 total commands, 4 Subgroups, 0 group commands
+	Repeated Capability: MinRange, default value after init: MinRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maxr", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
+		self._cmd_group = CommandsGroup("minr", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
 
-	def repcap_maxRange_set(self, enum_value: repcap.MaxRange) -> None:
+	def repcap_minRange_set(self, minRange: repcap.MinRange) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MaxRange.Default
-		Default value after init: MaxRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MinRange.Default
+		Default value after init: MinRange.Nr1"""
+		self._cmd_group.set_repcap_enum_value(minRange)
 
-	def repcap_maxRange_get(self) -> repcap.MaxRange:
+	def repcap_minRange_get(self) -> repcap.MinRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Maxr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Maxr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Maxr_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Maxr_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Maxr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maxr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.average.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float]:
+	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.average.calculate(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.maxr.average.calculate(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: (float or boolean items) float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.current.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float]:
+	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.current.calculate(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.maxr.current.calculate(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: (float or boolean items) float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.extreme.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float]:
+	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.extreme.calculate(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.maxr.extreme.calculate(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: (float or boolean items) float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/StandardDev.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.standardDev.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment Unit: dB"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minr:
-	"""Minr commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
-	Repeated Capability: MinRange, default value after init: MinRange.Nr1"""
+class MaxrCls:
+	"""Maxr commands group definition. 7 total commands, 4 Subgroups, 0 group commands
+	Repeated Capability: MaxRange, default value after init: MaxRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minr", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
+		self._cmd_group = CommandsGroup("maxr", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
 
-	def repcap_minRange_set(self, enum_value: repcap.MinRange) -> None:
+	def repcap_maxRange_set(self, maxRange: repcap.MaxRange) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MinRange.Default
-		Default value after init: MinRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MaxRange.Default
+		Default value after init: MaxRange.Nr1"""
+		self._cmd_group.set_repcap_enum_value(maxRange)
 
-	def repcap_minRange_get(self) -> repcap.MinRange:
+	def repcap_maxRange_get(self) -> repcap.MaxRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Minr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Minr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Minr_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Minr_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Minr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaxrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaxrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.average.fetch(minRange = repcap.MinRange.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.extreme.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, minRange=repcap.MinRange.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.average.calculate(minRange = repcap.MinRange.Default) \n
+	def calculate(self, minRange=repcap.MinRange.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.minr.extreme.calculate(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: (float or boolean items) float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.current.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, minRange=repcap.MinRange.Default) -> List[float]:
+	def calculate(self, minRange=repcap.MinRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.current.calculate(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.minr.current.calculate(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: (float or boolean items) float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.extreme.fetch(minRange = repcap.MinRange.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.average.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, minRange=repcap.MinRange.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.extreme.calculate(minRange = repcap.MinRange.Default) \n
+	def calculate(self, minRange=repcap.MinRange.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.minr.average.calculate(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: (float or boolean items) float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.standardDev.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment Unit: dB"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: float Comma-separated list of values, one per measured segment. Unit: dB"""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ripple:
-	"""Ripple commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
+class RippleCls:
+	"""Ripple commands group definition. 7 total commands, 4 Subgroups, 0 group commands
 	Repeated Capability: Ripple, default value after init: Ripple.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ripple", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_ripple_get', 'repcap_ripple_set', repcap.Ripple.Nr1)
+		self._cmd_group = CommandsGroup("ripple", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_ripple_get', 'repcap_ripple_set', repcap.Ripple.Nr1)
 
-	def repcap_ripple_set(self, enum_value: repcap.Ripple) -> None:
+	def repcap_ripple_set(self, ripple: repcap.Ripple) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Ripple.Default
 		Default value after init: Ripple.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(ripple)
 
 	def repcap_ripple_get(self) -> repcap.Ripple:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Ripple_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Ripple_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Ripple_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Ripple_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Ripple':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RippleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ripple(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RippleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.average.fetch(ripple = repcap.Ripple.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.current.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.average.calculate(ripple = repcap.Ripple.Default) \n
+	def calculate(self, ripple=repcap.Ripple.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.ripple.current.calculate(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Extreme.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.current.fetch(ripple = repcap.Ripple.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.extreme.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.current.calculate(ripple = repcap.Ripple.Default) \n
+	def calculate(self, ripple=repcap.Ripple.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.ripple.extreme.calculate(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Average.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.extreme.fetch(ripple = repcap.Ripple.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.average.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.extreme.calculate(ripple = repcap.Ripple.Default) \n
+	def calculate(self, ripple=repcap.Ripple.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.esFlatness.ripple.average.calculate(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.standardDev.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment Unit: dB"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: float Comma-separated list of values, one per measured segment Unit: dB"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ScIndex:
-	"""ScIndex commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scIndex", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_minimum'):
-			from .ScIndex_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 1 Sub-classes, 0 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .ScIndex_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'ScIndex':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ScIndex(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class MaximumCls:
+	"""Maximum commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: MaxRange, default value after init: MaxRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
 
-	def repcap_maxRange_set(self, enum_value: repcap.MaxRange) -> None:
+	def repcap_maxRange_set(self, maxRange: repcap.MaxRange) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MaxRange.Default
 		Default value after init: MaxRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(maxRange)
 
 	def repcap_maxRange_get(self) -> repcap.MaxRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Maximum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MAXimum<nr>:CURRent \n
 		Snippet: value: List[int] = driver.multiEval.listPy.esFlatness.scIndex.maximum.current.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return subcarrier indices of the equalizer spectrum flatness measurement for all measured list mode segments. At these SC
 		indices, the current MINimum or MAXimum power of the equalizer coefficients has been detected within the selected range. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maximum')
 			:return: maximum: No help available"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MAXimum{maxRange_cmd_val}:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: MinRange, default value after init: MinRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
 
-	def repcap_minRange_set(self, enum_value: repcap.MinRange) -> None:
+	def repcap_minRange_set(self, minRange: repcap.MinRange) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MinRange.Default
 		Default value after init: MinRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(minRange)
 
 	def repcap_minRange_get(self) -> repcap.MinRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Minimum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MINimum<nr>:CURRent \n
 		Snippet: value: List[int] = driver.multiEval.listPy.esFlatness.scIndex.minimum.current.fetch(minRange = repcap.MinRange.Default) \n
 		Return subcarrier indices of the equalizer spectrum flatness measurement for all measured list mode segments. At these SC
 		indices, the current MINimum or MAXimum power of the equalizer coefficients has been detected within the selected range. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minimum')
 			:return: minimum: No help available"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MINimum{minRange_cmd_val}:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InbandEmission:
-	"""InbandEmission commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class InbandEmissionCls:
+	"""InbandEmission commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inbandEmission", core, parent)
+		self._cmd_group = CommandsGroup("inbandEmission", core, parent)
 
 	@property
 	def margin(self):
 		"""margin commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .InbandEmission_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'InbandEmission':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'InbandEmissionCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InbandEmission(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InbandEmissionCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 5 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 14 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Margin_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
-
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.average.fetch() \n
 		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: margin: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: margin: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.current.fetch() \n
 		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: margin: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: margin: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.extreme.fetch() \n
 		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: margin: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: margin: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:EXTReme?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class FreqErrorCls:
+	"""FreqError commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("freqError", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .RbIndex_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 1 commands."""
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .RbIndex_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
-	def clone(self) -> 'RbIndex':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'FreqErrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RbIndex(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FreqErrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,24 +3,24 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:CURRent \n
 		Snippet: value: List[int] = driver.multiEval.listPy.inbandEmission.margin.rbIndex.current.fetch() \n
 		Return resource block indices of the inband emission measurement for all measured list mode segments. At these RB indices,
 		the CURRent and EXTReme margins have been detected. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: rb_index: Comma-separated list of values, one per measured segment"""
+			:return: rb_index: decimal Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,24 +3,24 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:EXTReme \n
 		Snippet: value: List[int] = driver.multiEval.listPy.inbandEmission.margin.rbIndex.extreme.fetch() \n
 		Return resource block indices of the inband emission measurement for all measured list mode segments. At these RB indices,
 		the CURRent and EXTReme margins have been detected. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: rb_index: Comma-separated list of values, one per measured segment"""
+			:return: rb_index: decimal Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:EXTReme?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.standardDev.fetch() \n
 		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: margin: Comma-separated list of values, one per measured segment Unit: dB"""
+			:return: margin: float Comma-separated list of values, one per measured segment Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,123 +1,123 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 178 total commands, 13 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 178 total commands, 13 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def evm(self):
 		"""evm commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_evm'):
-			from .Modulation_.Evm import Evm
-			self._evm = Evm(self._core, self._base)
+			from .Evm import EvmCls
+			self._evm = EvmCls(self._core, self._cmd_group)
 		return self._evm
 
 	@property
 	def merror(self):
 		"""merror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_merror'):
-			from .Modulation_.Merror import Merror
-			self._merror = Merror(self._core, self._base)
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
 		return self._merror
 
 	@property
 	def perror(self):
 		"""perror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_perror'):
-			from .Modulation_.Perror import Perror
-			self._perror = Perror(self._core, self._base)
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
 		return self._perror
 
 	@property
 	def iqOffset(self):
 		"""iqOffset commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_iqOffset'):
-			from .Modulation_.IqOffset import IqOffset
-			self._iqOffset = IqOffset(self._core, self._base)
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
 		return self._iqOffset
 
 	@property
 	def freqError(self):
 		"""freqError commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_freqError'):
-			from .Modulation_.FreqError import FreqError
-			self._freqError = FreqError(self._core, self._base)
+			from .FreqError import FreqErrorCls
+			self._freqError = FreqErrorCls(self._core, self._cmd_group)
 		return self._freqError
 
 	@property
 	def terror(self):
 		"""terror commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_terror'):
-			from .Modulation_.Terror import Terror
-			self._terror = Terror(self._core, self._base)
+			from .Terror import TerrorCls
+			self._terror = TerrorCls(self._core, self._cmd_group)
 		return self._terror
 
 	@property
 	def tpower(self):
 		"""tpower commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_tpower'):
-			from .Modulation_.Tpower import Tpower
-			self._tpower = Tpower(self._core, self._base)
+			from .Tpower import TpowerCls
+			self._tpower = TpowerCls(self._core, self._cmd_group)
 		return self._tpower
 
 	@property
 	def ppower(self):
 		"""ppower commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_ppower'):
-			from .Modulation_.Ppower import Ppower
-			self._ppower = Ppower(self._core, self._base)
+			from .Ppower import PpowerCls
+			self._ppower = PpowerCls(self._core, self._cmd_group)
 		return self._ppower
 
 	@property
 	def psd(self):
 		"""psd commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_psd'):
-			from .Modulation_.Psd import Psd
-			self._psd = Psd(self._core, self._base)
+			from .Psd import PsdCls
+			self._psd = PsdCls(self._core, self._cmd_group)
 		return self._psd
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Modulation_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Modulation_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def schType(self):
 		"""schType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_schType'):
-			from .Modulation_.SchType import SchType
-			self._schType = SchType(self._core, self._base)
+			from .SchType import SchTypeCls
+			self._schType = SchTypeCls(self._core, self._cmd_group)
 		return self._schType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Modulation_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Dallocation.py`

 * *Files 11% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: List[int]: Number of allocated resource blocks
-			- Offset_Res_Blocks: List[int]: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nr_Res_Blocks: List[int]: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: List[int]: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Nr_Res_Blocks', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('Offset_Res_Blocks', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -32,13 +32,13 @@
 			self.Nr_Res_Blocks: List[int] = None
 			self.Offset_Res_Blocks: List[int] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DALLocation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.modulation.dallocation.fetch() \n
 		Return the detected allocation for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected allocation results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>,
-		<OffsetResBlocks>}Seg 1, {<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>, <OffsetResBlocks>}Seg 1,
+		{<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/DchType.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,27 +5,27 @@
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.UplinkChannelType]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType \n
-		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.modulation.dchType.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DCHType \n
+		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.seMask.dchType.fetch() \n
 		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected channel type results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: channel_type: PUSCh | PUCCh Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DCHType?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dmodulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Dmodulation.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,20 +5,20 @@
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.Modulation]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DMODulation \n
 		Snippet: value: List[enums.Modulation] = driver.multiEval.listPy.modulation.dmodulation.fetch() \n
 		Return the detected modulation scheme for all measured list mode segments. The result is determined from the last
 		measured slot of the statistical length of a segment. If channel type PUCCH is detected, QPSK is returned as modulation
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evm:
-	"""Evm commands group definition. 42 total commands, 3 Sub-groups, 0 group commands"""
+class EvmCls:
+	"""Evm commands group definition. 42 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evm", core, parent)
+		self._cmd_group = CommandsGroup("evm", core, parent)
 
 	@property
 	def rms(self):
 		"""rms commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_rms'):
-			from .Evm_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
 		return self._rms
 
 	@property
 	def peak(self):
 		"""peak commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_peak'):
-			from .Evm_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
 		return self._peak
 
 	@property
 	def dmrs(self):
 		"""dmrs commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_dmrs'):
-			from .Evm_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
 		return self._dmrs
 
-	def clone(self) -> 'Evm':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvmCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Evm(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,43 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 4 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Dmrs_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def rms(self):
+		"""rms commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Dmrs_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def peak(self):
+		"""peak commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	def clone(self) -> 'Dmrs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def array(self):
+		"""array commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_array'):
+			from .Array import ArrayCls
+			self._array = ArrayCls(self._core, self._cmd_group)
+		return self._array
+
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Dmrs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class IqCls:
+	"""Iq commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("iq", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def low(self):
+		"""low commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def high(self):
+		"""high commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.average.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.dmrs.high.average.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Extreme.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.extreme.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.dmrs.low.extreme.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Extreme.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.extreme.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.dmrs.high.extreme.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.standardDev.fetch() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.standardDev.fetch() \n
+		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 14 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.average.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.dmrs.low.average.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.current.fetch() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.current.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_peak_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.current.calculate() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.peak.low.current.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.extreme.fetch() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.extreme.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_peak_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.extreme.calculate() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.peak.high.extreme.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/StandardDev.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.standardDev.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class InbandEmissionCls:
+	"""InbandEmission commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("inbandEmission", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Peak_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def cc(self):
+		"""cc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Peak_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'InbandEmissionCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InbandEmissionCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def rms(self):
+		"""rms commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def peak(self):
+		"""peak commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.average.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.peak.high.average.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Current.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.current.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.peak.high.current.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.extreme.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.peak.high.extreme.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.standardDev.fetch() \n
-		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.standardDev.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class TerrorCls:
+	"""Terror commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("terror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.average.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.peak.low.average.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Current.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.current.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.peak.low.current.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.extreme.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.peak.low.extreme.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.standardDev.fetch() \n
-		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.standardDev.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_rms_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,43 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 42 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Rms_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def rms(self):
+		"""rms commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Rms_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def peak(self):
+		"""peak commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	def clone(self) -> 'Rms':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def dmrs(self):
+		"""dmrs commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dmrs'):
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
+		return self._dmrs
+
+	def clone(self) -> 'MerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rms(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		"""extreme commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbIndexCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbIndexCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.average.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.rms.high.average.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.current.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.rms.high.current.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.extreme.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.rms.high.extreme.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.standardDev.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.standardDev.fetch() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: iq_offset: float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqOffsetCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqOffsetCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.average.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.average.fetch() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: timing_error: float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.average.calculate() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.terror.average.calculate() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: timing_error: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.current.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.current.fetch() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.current.calculate() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.dmrs.low.current.calculate() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.extreme.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.rms.low.extreme.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: evm_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.standardDev.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.standardDev.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FreqError:
-	"""FreqError commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 42 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("freqError", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .FreqError_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def rms(self):
+		"""rms commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .FreqError_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def peak(self):
+		"""peak commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .FreqError_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def dmrs(self):
+		"""dmrs commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dmrs'):
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
+		return self._dmrs
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .FreqError_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'FreqError':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FreqError(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.average.fetch() \n
-		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.average.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: ph_error_rms_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.average.calculate() \n
-		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.rms.high.average.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: ph_error_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.current.fetch() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: frequency_error: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.freqError.current.calculate() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: frequency_error: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.extreme.fetch() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: frequency_error: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.freqError.extreme.calculate() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: frequency_error: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,24 +3,24 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.standardDev.fetch() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: frequency_error: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqOffset:
-	"""IqOffset commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqOffset", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .IqOffset_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .IqOffset_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .IqOffset_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .IqOffset_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'IqOffset':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqOffset(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.average.fetch() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.average.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.average.calculate() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.tpower.average.calculate() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.current.fetch() \n
 		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
+			:return: iq_offset: float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.iqOffset.current.calculate() \n
 		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
+			:return: iq_offset: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.extreme.fetch() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.standardDev.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
+			:return: mag_err_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
-		return response
-
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.extreme.calculate() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.standardDev.fetch() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.standardDev.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment Unit: dBc"""
+			:return: ph_error_peak_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Merror:
-	"""Merror commands group definition. 42 total commands, 3 Sub-groups, 0 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("merror", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rms'):
-			from .Merror_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def peak(self):
-		"""peak commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .Merror_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def dmrs(self):
-		"""dmrs commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_dmrs'):
-			from .Merror_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
-		return self._dmrs
-
-	def clone(self) -> 'Merror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DmrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Merror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DmrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class IemissionsCls:
+	"""Iemissions commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("iemissions", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Dmrs_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Dmrs_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Dmrs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IemissionsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Dmrs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IemissionsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.average.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.dmrs.low.average.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.current.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.current.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.current.calculate() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.rms.low.current.calculate() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.current.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.dmrs.low.current.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.standardDev.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.standardDev.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,67 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PowerCls:
+	"""Power commands group definition. 18 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def cc(self):
+		"""cc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
+
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.average.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.average.fetch() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_dmrs_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.average.calculate() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.dmrs.low.average.calculate() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.current.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.current.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_rms_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.current.calculate() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.rms.low.current.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Extreme.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.extreme.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.dmrs.high.extreme.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/StandardDev.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.standardDev.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.standardDev.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_peak_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Peak_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def area(self):
+		"""area commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_area'):
+			from .Area import AreaCls
+			self._area = AreaCls(self._core, self._cmd_group)
+		return self._area
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Peak_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.current.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.peak.low.current.calculate() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.current.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.current.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: psd: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.current.calculate() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.psd.current.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: psd: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.extreme.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.average.fetch() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: iq_offset: float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.extreme.calculate() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.iqOffset.average.calculate() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: iq_offset: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.standardDev.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.standardDev.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.average.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_peak_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.peak.low.average.calculate() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.current.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.current.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_rms_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.current.calculate() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.rms.high.current.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.extreme.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.peak.high.extreme.calculate() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.standardDev.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.standardDev.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_err_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
 	def low(self):
 		"""low commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_low'):
-			from .Rms_.Low import Low
-			self._low = Low(self._core, self._base)
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
 		return self._low
 
 	@property
 	def high(self):
 		"""high commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_high'):
-			from .Rms_.High import High
-			self._high = High(self._core, self._base)
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
 		return self._high
 
-	def clone(self) -> 'Rms':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rms(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.average.fetch() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.rms.low.average.calculate() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.current.fetch() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.rms.high.current.calculate() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Extreme.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.extreme.fetch() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.rms.high.extreme.calculate() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.standardDev.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.standardDev.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_rms_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.average.fetch() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.rms.high.average.calculate() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: mag_error_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.current.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.current.fetch() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_dmrs_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.current.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.dmrs.low.current.calculate() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Extreme.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.extreme.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.extreme.fetch() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: iq_offset: float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.extreme.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.iqOffset.extreme.calculate() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: iq_offset: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBc"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.standardDev.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.standardDev.fetch() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment Unit: %"""
+			:return: ph_error_dmrs_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Perror:
-	"""Perror commands group definition. 42 total commands, 3 Sub-groups, 0 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("perror", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rms'):
-			from .Perror_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def peak(self):
-		"""peak commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .Perror_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def dmrs(self):
-		"""dmrs commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_dmrs'):
-			from .Perror_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
-		return self._dmrs
-
-	def clone(self) -> 'Perror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DmrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Perror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DmrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/Srs/Limit/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Dmrs_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def pdynamics(self):
+		"""pdynamics commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Dmrs_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Dmrs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Dmrs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.average.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.dmrs.high.average.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.current.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.dmrs.high.current.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.extreme.fetch() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.current.fetch() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: timing_error: float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.extreme.calculate() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.terror.current.calculate() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: timing_error: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:SDEViation \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.standardDev.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Extreme.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.extreme.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.dmrs.low.extreme.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.current.fetch() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.current.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.current.calculate() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.txPower.current.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.extreme.fetch() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.current.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: mag_err_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.extreme.calculate() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.dmrs.high.current.calculate() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: mag_err_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.standardDev.fetch() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.standardDev.fetch() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: obw: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Peak_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def rbw(self):
+		"""rbw commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rbw'):
+			from .Rbw import RbwCls
+			self._rbw = RbwCls(self._core, self._cmd_group)
+		return self._rbw
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Peak_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.average.fetch() \n
 		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_peak_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.peak.high.average.calculate() \n
 		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.current.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.current.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: mag_err_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.current.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.peak.high.current.calculate() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: mag_err_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.extreme.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.current.fetch() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: peak_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.extreme.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.ppower.current.calculate() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: peak_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.standardDev.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.standardDev.fetch() \n
+		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: evm_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.average.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.average.fetch() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: peak_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.average.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.ppower.average.calculate() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: peak_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.current.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.current.fetch() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: evm_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.current.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.dmrs.high.current.calculate() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: evm_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Minimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.extreme.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.minimum.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: psd: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.extreme.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.psd.minimum.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: psd: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.standardDev.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.standardDev.fetch() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: timing_error: float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Rms_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Rms_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Rms':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rms(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.extreme.fetch() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_rms_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.rms.high.extreme.calculate() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_rms_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.average.fetch() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_rms_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.rms.low.average.calculate() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.extreme.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.average.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: psd: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.extreme.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.psd.average.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: psd: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.standardDev.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.standardDev.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Maximum.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.average.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.maximum.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: psd: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.average.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.psd.maximum.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: psd: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.current.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.current.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: evm_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.current.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.rms.low.current.calculate() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: evm_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Extreme.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
 from ........Internal.Core import Core
 from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
 from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme \n
 		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.extreme.fetch() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_rms_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.rms.low.extreme.calculate() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: ph_error_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/StandardDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.standardDev.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.standardDev.fetch() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment Unit: deg"""
+			:return: peak_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ppower:
-	"""Ppower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PsdCls:
+	"""Psd commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ppower", core, parent)
+		self._cmd_group = CommandsGroup("psd", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Ppower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Ppower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Ppower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Ppower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Ppower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Ppower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PsdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ppower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PsdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Minimum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.minimum.fetch() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: peak_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.ppower.minimum.calculate() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: peak_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Average.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.current.fetch() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.average.fetch() \n
+		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: frequency_error: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.current.calculate() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.freqError.average.calculate() \n
+		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: frequency_error: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.maximum.fetch() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.current.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.maximum.calculate() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.tpower.current.calculate() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Maximum.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.minimum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.maximum.fetch() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: peak_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.minimum.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.ppower.maximum.calculate() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: peak_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,24 +3,24 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.standardDev.fetch() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.standardDev.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: peak_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: psd: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,59 +1,43 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Psd:
-	"""Psd commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("psd", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Psd_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Psd_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Psd_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Psd_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Psd_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Psd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Psd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Average.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.average.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.average.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: mag_err_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.average.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.dmrs.high.average.calculate() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: mag_err_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Extreme.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.current.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.extreme.fetch() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: obw: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.current.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.obw.extreme.calculate() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: obw: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.maximum.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.standardDev.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: evm_rms_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
-		return response
-
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.maximum.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.minimum.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.average.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ph_error_peak_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.minimum.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.peak.low.average.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ph_error_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/StandardDev.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.standardDev.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.standardDev.fetch() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: psd: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: evm_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/SchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/SchType.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,20 +5,20 @@
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SchType:
-	"""SchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SchTypeCls:
+	"""SchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("schType", core, parent)
+		self._cmd_group = CommandsGroup("schType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.SidelinkChannelType]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:SCHType \n
 		Snippet: value: List[enums.SidelinkChannelType] = driver.multiEval.listPy.modulation.schType.fetch() \n
 		Returns the sidelink channel type evaluated for modulation results, for all measured list mode segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Terror:
-	"""Terror commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("terror", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Terror_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Terror_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Terror_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Terror_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Terror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Terror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.average.fetch() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.average.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.average.calculate() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.txPower.average.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.extreme.fetch() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: timing_error: float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.terror.extreme.calculate() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: timing_error: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Extreme.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.extreme.fetch() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.extreme.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: mag_err_dmrs_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.extreme.calculate() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.dmrs.low.extreme.calculate() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: mag_err_dmrs_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/StandardDev.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,24 +3,24 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.standardDev.fetch() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.standardDev.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: timing_error: Comma-separated list of values, one per measured segment Unit: Ts (basic LTE time unit)"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,59 +1,67 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Tpower:
-	"""Tpower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 24 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("tpower", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
+
+	@property
+	def cc(self):
+		"""cc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Tpower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Tpower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Tpower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Tpower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Tpower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Tpower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Tpower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.maximum.fetch() \n
 		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.tpower.maximum.calculate() \n
 		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.minimum.fetch() \n
 		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.tpower.minimum.calculate() \n
 		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.maximum.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.minimum.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.maximum.calculate() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.txPower.minimum.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Maximum.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.minimum.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.maximum.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.minimum.calculate() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.txPower.maximum.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,24 +3,23 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.standardDev.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.standardDev.fetch() \n
+		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/Pmonitor/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rms'):
-			from .Pmonitor_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def peak(self):
-		"""peak commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_peak'):
-			from .Pmonitor_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
-
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/Peak.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,28 +3,28 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:PEAK \n
 		Snippet: value: List[float] = driver.multiEval.listPy.pmonitor.peak.fetch() \n
 		Return the power monitor results for all measured segments in list mode. The commands return one power result per
 		subframe for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value within
 		the subframe.
 			INTRO_CMD_HELP: Commands for querying the result list structure: \n
 			- method RsCmwLteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Start.fetch
 			- method RsCmwLteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Length.fetch \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: step_peak_power: Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes. Unit: dBm"""
+			:return: step_peak_power: float Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:PEAK?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Rms.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/Rms.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,28 +3,28 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:RMS \n
 		Snippet: value: List[float] = driver.multiEval.listPy.pmonitor.rms.fetch() \n
 		Return the power monitor results for all measured segments in list mode. The commands return one power result per
 		subframe for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value within
 		the subframe.
 			INTRO_CMD_HELP: Commands for querying the result list structure: \n
 			- method RsCmwLteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Start.fetch
 			- method RsCmwLteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Length.fetch \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: step_rms_power: Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes. Unit: dBm"""
+			:return: step_rms_power: float Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:RMS?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 9 total commands, 1 Sub-groups, 0 group commands"""
+class PowerCls:
+	"""Power commands group definition. 9 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
 	def txPower(self):
 		"""txPower commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_txPower'):
-			from .Power_.TxPower import TxPower
-			self._txPower = TxPower(self._core, self._base)
+			from .TxPower import TxPowerCls
+			self._txPower = TxPowerCls(self._core, self._cmd_group)
 		return self._txPower
 
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TxPower:
-	"""TxPower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class TxPowerCls:
+	"""TxPower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("txPower", core, parent)
+		self._cmd_group = CommandsGroup("txPower", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .TxPower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .TxPower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .TxPower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .TxPower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .TxPower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'TxPower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TxPowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = TxPower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TxPowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.average.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.power.txPower.average.calculate() \n
 		No command help available \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.current.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.power.txPower.current.calculate() \n
 		No command help available \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Maximum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.maximum.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.maximum.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.power.txPower.maximum.calculate() \n
 		No command help available \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Minimum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum \n
 		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.minimum.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: tx_power: float Comma-separated list of values, one per measured segment Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.minimum.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.power.txPower.minimum.calculate() \n
 		No command help available \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/StandardDev.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,25 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.standardDev.fetch() \n
-		Return the total TX power of all component carriers, for all measured list mode segments. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.standardDev.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: mag_err_dmrs_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,59 +1,75 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 24 total commands, 5 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 29 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def obw(self):
-		"""obw commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_obw'):
-			from .SeMask_.Obw import Obw
-			self._obw = Obw(self._core, self._base)
-		return self._obw
-
-	@property
-	def txPower(self):
-		"""txPower commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_txPower'):
-			from .SeMask_.TxPower import TxPower
-			self._txPower = TxPower(self._core, self._base)
-		return self._txPower
-
-	@property
-	def margin(self):
-		"""margin commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .SeMask_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
-
-	@property
-	def dchType(self):
-		"""dchType commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dchType'):
-			from .SeMask_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
-		return self._dchType
-
-	@property
-	def dallocation(self):
-		"""dallocation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dallocation'):
-			from .SeMask_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
-		return self._dallocation
+	def evm(self):
+		"""evm commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_evm'):
+			from .Evm import EvmCls
+			self._evm = EvmCls(self._core, self._cmd_group)
+		return self._evm
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def evPreamble(self):
+		"""evPreamble commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_evPreamble'):
+			from .EvPreamble import EvPreambleCls
+			self._evPreamble = EvPreambleCls(self._core, self._cmd_group)
+		return self._evPreamble
+
+	@property
+	def merror(self):
+		"""merror commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_merror'):
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
+		return self._merror
+
+	@property
+	def perror(self):
+		"""perror commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_perror'):
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
+		return self._perror
+
+	@property
+	def iq(self):
+		"""iq commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_iq'):
+			from .Iq import IqCls
+			self._iq = IqCls(self._core, self._cmd_group)
+		return self._iq
+
+	@property
+	def pdynamics(self):
+		"""pdynamics commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
+
+	@property
+	def pvPreamble(self):
+		"""pvPreamble commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pvPreamble'):
+			from .PvPreamble import PvPreambleCls
+			self._pvPreamble = PvPreambleCls(self._core, self._cmd_group)
+		return self._pvPreamble
+
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Dallocation.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,41 +4,41 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: List[int]: Number of allocated resource blocks
-			- Offset_Res_Blocks: List[int]: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nr_Res_Blocks: List[int]: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: List[int]: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Nr_Res_Blocks', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('Offset_Res_Blocks', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: List[int] = None
 			self.Offset_Res_Blocks: List[int] = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.dallocation.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DALLocation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.aclr.dallocation.fetch() \n
 		Return the detected allocation for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected allocation results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>,
-		<OffsetResBlocks>}Seg 1, {<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>, <OffsetResBlocks>}Seg 1,
+		{<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DALLocation?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/DchType.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,31 +1,28 @@
-from typing import List
-
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from ..... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.UplinkChannelType]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DCHType \n
-		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.seMask.dchType.fetch() \n
-		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected channel type results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. \n
+	def fetch(self) -> enums.UplinkChannelType:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType \n
+		Snippet: value: enums.UplinkChannelType = driver.multiEval.seMask.dchType.fetch() \n
+		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
+		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
+		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: channel_type: PUSCh | PUCCh Comma-separated list of values, one per measured segment"""
+			:return: channel_type: PUSCh | PUCCh"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DCHType?', suppressed)
-		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType?', suppressed)
+		return Conversions.str_to_scalar_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/SeMask/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def area(self):
-		"""area commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_area'):
-			from .Margin_.Area import Area
-			self._area = Area(self._core, self._base)
-		return self._area
+	def rbw(self):
+		"""rbw commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rbw'):
+			from .Rbw import RbwCls
+			self._rbw = RbwCls(self._core, self._cmd_group)
+		return self._rbw
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,58 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Area:
-	"""Area commands group definition. 6 total commands, 2 Sub-groups, 0 group commands
-	Repeated Capability: Area, default value after init: Area.Nr1"""
+class RbwCls:
+	"""Rbw commands group definition. 6 total commands, 3 Subgroups, 0 group commands
+	Repeated Capability: RBWkHz, default value after init: RBWkHz.Rbw30"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("area", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_area_get', 'repcap_area_set', repcap.Area.Nr1)
+		self._cmd_group = CommandsGroup("rbw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_rBWkHz_get', 'repcap_rBWkHz_set', repcap.RBWkHz.Rbw30)
 
-	def repcap_area_set(self, enum_value: repcap.Area) -> None:
+	def repcap_rBWkHz_set(self, rBWkHz: repcap.RBWkHz) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Area.Default
-		Default value after init: Area.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBWkHz.Default
+		Default value after init: RBWkHz.Rbw30"""
+		self._cmd_group.set_repcap_enum_value(rBWkHz)
 
-	def repcap_area_get(self) -> repcap.Area:
+	def repcap_rBWkHz_get(self) -> repcap.RBWkHz:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Area_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Area_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'Area':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'RbwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Area(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_current'):
-			from .Negativ_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_average'):
-			from .Negativ_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Negativ_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	def clone(self) -> 'Negativ':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Negativ(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,25 +5,25 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Margin_Avg_Neg_X: List[float]: No parameter help available
 			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Avg_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
@@ -38,9 +38,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.negativ.average.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:NEGativ:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,25 +5,25 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Margin_Curr_Neg_X: List[float]: No parameter help available
 			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
@@ -38,9 +38,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.negativ.current.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:NEGativ:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Minimum.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,25 +5,25 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: decimal 'Reliability indicator'
 			- Margin_Min_Neg_X: List[float]: No parameter help available
 			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
@@ -38,9 +38,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.negativ.minimum.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:NEGativ:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
+
+	@property
+	def all(self):
+		"""all commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_all'):
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
+		return self._all
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
+		"""current commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_current'):
-			from .Positiv_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
+		"""average commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_average'):
-			from .Positiv_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 1 commands."""
+		"""minimum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Positiv_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
-	def clone(self) -> 'Positiv':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Positiv(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,27 +5,27 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Margin_Avg_Pos_X: List[float]: X-position of margin for selected area Unit: Hz
-			- Margin_Avg_Pos_Y: List[float]: Y-position of margin for selected area Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Margin_Avg_Pos_X: List[float]: float X position of margin for selected area Unit: Hz
+			- Margin_Avg_Pos_Y: List[float]: float Y position of margin for selected area Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Avg_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -38,9 +38,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.positiv.average.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Current.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,27 +5,27 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Margin_Curr_Pos_X: List[float]: X-position of margin for selected area Unit: Hz
-			- Margin_Curr_Pos_Y: List[float]: Y-position of margin for selected area Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Margin_Curr_Pos_X: List[float]: float X position of margin for selected area Unit: Hz
+			- Margin_Curr_Pos_Y: List[float]: float Y position of margin for selected area Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -38,9 +38,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.positiv.current.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Minimum.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,27 +5,27 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Margin_Min_Pos_X: List[float]: X-position of margin for selected area Unit: Hz
-			- Margin_Min_Pos_Y: List[float]: Y-position of margin for selected area Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Margin_Min_Pos_X: List[float]: float X position of margin for selected area Unit: Hz
+			- Margin_Min_Pos_Y: List[float]: float Y position of margin for selected area Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -38,9 +38,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.positiv.minimum.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Obw:
-	"""Obw commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class ObwCls:
+	"""Obw commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("obw", core, parent)
+		self._cmd_group = CommandsGroup("obw", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Obw_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Obw_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Obw_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Obw_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Obw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ObwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Obw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ObwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.average.fetch() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: obw: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.obw.average.calculate() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: obw: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.current.fetch() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: obw: float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.seMask.obw.current.calculate() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: obw: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Extreme.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.extreme.fetch() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.extreme.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: ph_error_peak_low: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.extreme.calculate() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.peak.low.extreme.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: ph_error_peak_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Average.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.standardDev.fetch() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.average.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: obw: Comma-separated list of values, one per measured segment Unit: Hz"""
+			:return: evm_rms_low: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
 		return response
+
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.evm.rms.low.average.calculate() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
+		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: evm_rms_low: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TxPower:
-	"""TxPower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class TxPowerCls:
+	"""TxPower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("txPower", core, parent)
+		self._cmd_group = CommandsGroup("txPower", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .TxPower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .TxPower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .TxPower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .TxPower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .TxPower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'TxPower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TxPowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = TxPower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TxPowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Average.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,37 +1,35 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.average.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.average.read() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'View EVM'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ratio: float Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.average.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.average.fetch() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'View EVM'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ratio: float Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Current.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,37 +1,35 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.current.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.current.read() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'View EVM'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ratio: float Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.current.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
+		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.current.fetch() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'View EVM'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ratio: float Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Maximum.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,37 +1,35 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.maximum.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.maximum.read() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'View EVM'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ratio: float Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.maximum.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
+		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.maximum.fetch() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'View EVM'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ratio: float Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Average.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.minimum.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.average.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: mag_err_peak_high: float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.minimum.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.merror.peak.high.average.calculate() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: mag_err_peak_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Extreme.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,26 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.standardDev.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.extreme.fetch() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: tx_power: Comma-separated list of values, one per measured segment Unit: dBm"""
+			:return: ph_error_dmrs_high: float Comma-separated list of values, one per measured segment Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
 		return response
+
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.multiEval.listPy.modulation.perror.dmrs.high.extreme.calculate() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
+		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: ph_error_dmrs_high: (float or boolean items) float Comma-separated list of values, one per measured segment Unit: deg"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,90 +1,91 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Segment:
-	"""Segment commands group definition. 72 total commands, 7 Sub-groups, 0 group commands
-	Repeated Capability: Segment, default value after init: Segment.Nr1"""
+class ListPyCls:
+	"""ListPy commands group definition. 353 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("segment", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.Nr1)
+		self._cmd_group = CommandsGroup("listPy", core, parent)
 
-	def repcap_segment_set(self, enum_value: repcap.Segment) -> None:
-		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Segment.Default
-		Default value after init: Segment.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
-
-	def repcap_segment_get(self) -> repcap.Segment:
-		"""Returns the current default repeated capability for the child set/get methods"""
-		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+	@property
+	def sreliability(self):
+		"""sreliability commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sreliability'):
+			from .Sreliability import SreliabilityCls
+			self._sreliability = SreliabilityCls(self._core, self._cmd_group)
+		return self._sreliability
 
 	@property
 	def modulation(self):
-		"""modulation commands group. 8 Sub-classes, 0 commands."""
+		"""modulation commands group. 13 Sub-classes, 0 commands."""
 		if not hasattr(self, '_modulation'):
-			from .Segment_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def inbandEmission(self):
-		"""inbandEmission commands group. 3 Sub-classes, 0 commands."""
+		"""inbandEmission commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_inbandEmission'):
-			from .Segment_.InbandEmission import InbandEmission
-			self._inbandEmission = InbandEmission(self._core, self._base)
+			from .InbandEmission import InbandEmissionCls
+			self._inbandEmission = InbandEmissionCls(self._core, self._cmd_group)
 		return self._inbandEmission
 
 	@property
 	def esFlatness(self):
-		"""esFlatness commands group. 4 Sub-classes, 0 commands."""
+		"""esFlatness commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_esFlatness'):
-			from .Segment_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
+			from .EsFlatness import EsFlatnessCls
+			self._esFlatness = EsFlatnessCls(self._core, self._cmd_group)
 		return self._esFlatness
 
 	@property
+	def segment(self):
+		"""segment commands group. 7 Sub-classes, 0 commands."""
+		if not hasattr(self, '_segment'):
+			from .Segment import SegmentCls
+			self._segment = SegmentCls(self._core, self._cmd_group)
+		return self._segment
+
+	@property
 	def seMask(self):
-		"""seMask commands group. 7 Sub-classes, 0 commands."""
+		"""seMask commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_seMask'):
-			from .Segment_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aclr'):
-			from .Segment_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def power(self):
-		"""power commands group. 5 Sub-classes, 0 commands."""
+		"""power commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_power'):
-			from .Segment_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def pmonitor(self):
-		"""pmonitor commands group. 3 Sub-classes, 0 commands."""
+		"""pmonitor commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pmonitor'):
-			from .Segment_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
 		return self._pmonitor
 
-	def clone(self) -> 'Segment':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ListPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Segment(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ListPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Aclr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Aclr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Aclr_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Aclr_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: float: ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
-			- Eutra: float: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: float: ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
-			- Utra_1_Pos: float: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: float: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Utra_2_Neg: float: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: float: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: float: float ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
+			- Eutra: float: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: float: float ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
+			- Utra_1_Pos: float: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: float: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Utra_2_Neg'),
 			ArgStruct.scalar_float('Utra_1_Neg'),
@@ -52,38 +52,38 @@
 			self.Eutra_Negativ: float = None
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.average.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.current.fetch(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
 		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
-			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: enums.ResultStatus2: ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
-			- Utra_1_Pos: enums.ResultStatus2: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: enums.ResultStatus2: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Utra_2_Neg: enums.ResultStatus2: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: enums.ResultStatus2: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: enums.ResultStatus2: float ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
+			- Eutra: enums.ResultStatus2: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: enums.ResultStatus2: float ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
+			- Utra_1_Pos: enums.ResultStatus2: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: enums.ResultStatus2: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_enum('Utra_2_Neg', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Utra_1_Neg', enums.ResultStatus2),
@@ -104,16 +104,16 @@
 			self.Eutra_Negativ: enums.ResultStatus2 = None
 			self.Eutra: enums.ResultStatus2 = None
 			self.Eutra_Positiv: enums.ResultStatus2 = None
 			self.Utra_1_Pos: enums.ResultStatus2 = None
 			self.Utra_2_Pos: enums.ResultStatus2 = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.aclr.average.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.aclr.current.calculate(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
 		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:AVERage?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Average.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: float: ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
-			- Eutra: float: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: float: ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
-			- Utra_1_Pos: float: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: float: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Utra_2_Neg: float: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: float: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: float: float ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
+			- Eutra: float: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: float: float ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
+			- Utra_1_Pos: float: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: float: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Utra_2_Neg'),
 			ArgStruct.scalar_float('Utra_1_Neg'),
@@ -52,38 +52,38 @@
 			self.Eutra_Negativ: float = None
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.current.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.average.fetch(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
 		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:CURRent?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency Unit: dB
-			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency Unit: dB
-			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
-			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: enums.ResultStatus2: ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
-			- Utra_1_Pos: enums.ResultStatus2: ACLR for the first UTRA channel with higher frequency Unit: dB
-			- Utra_2_Pos: enums.ResultStatus2: ACLR for the second UTRA channel with higher frequency Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Utra_2_Neg: enums.ResultStatus2: float ACLR for the second UTRA channel with lower frequency Unit: dB
+			- Utra_1_Neg: enums.ResultStatus2: float ACLR for the first UTRA channel with lower frequency Unit: dB
+			- Eutra_Negativ: enums.ResultStatus2: float ACLR for the first E-UTRA channel below the carrier frequency Unit: dB
+			- Eutra: enums.ResultStatus2: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: enums.ResultStatus2: float ACLR for the first E-UTRA channel above the carrier frequency Unit: dB
+			- Utra_1_Pos: enums.ResultStatus2: float ACLR for the first UTRA channel with higher frequency Unit: dB
+			- Utra_2_Pos: enums.ResultStatus2: float ACLR for the second UTRA channel with higher frequency Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_enum('Utra_2_Neg', enums.ResultStatus2),
 			ArgStruct.scalar_enum('Utra_1_Neg', enums.ResultStatus2),
@@ -104,16 +104,16 @@
 			self.Eutra_Negativ: enums.ResultStatus2 = None
 			self.Eutra: enums.ResultStatus2 = None
 			self.Eutra_Positiv: enums.ResultStatus2 = None
 			self.Utra_1_Pos: enums.ResultStatus2 = None
 			self.Utra_2_Pos: enums.ResultStatus2 = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.aclr.current.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.aclr.average.calculate(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
 		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:CURRent?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Dallocation.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,45 +2,44 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Nr_Res_Blocks: int: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: int: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.dallocation.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DALLocation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dallocation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected allocation results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DALLocation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/DchType.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
 			- Channel_Type: enums.UplinkChannelType: PUSCh | PUCCh"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.UplinkChannelType)]
 
 		def __init__(self):
@@ -31,14 +31,13 @@
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.UplinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DCHType \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.dchType.fetch(segment = repcap.Segment.Default) \n
 		Return the uplink channel type for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected channel type results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .EsFlatness_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .EsFlatness_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .EsFlatness_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .EsFlatness_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
@@ -57,50 +57,50 @@
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:AVERage \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.average.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1) Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) . Unit: dB
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) . Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.average.calculate(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 1 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def scIndex(self):
 		"""scIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scIndex'):
-			from .Current_.ScIndex import ScIndex
-			self._scIndex = ScIndex(self._core, self._base)
+			from .ScIndex import ScIndexCls
+			self._scIndex = ScIndexCls(self._core, self._cmd_group)
 		return self._scIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
@@ -65,58 +65,58 @@
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.current.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1) Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) . Unit: dB
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) . Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.current.calculate(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/ScIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/SchType.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,57 +1,41 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ScIndex:
-	"""ScIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SchTypeCls:
+	"""SchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scIndex", core, parent)
+		self._cmd_group = CommandsGroup("schType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Maximum_1: int: SC index of max (range 1)
-			- Minimum_1: int: SC index of min (range 1)
-			- Maximum_2: int: SC index of max (range 2)
-			- Minimum_2: int: SC index of min (range 2)"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Channel_Type: enums.SidelinkChannelType: PSSCh | PSCCh"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Maximum_1'),
-			ArgStruct.scalar_int('Minimum_1'),
-			ArgStruct.scalar_int('Maximum_2'),
-			ArgStruct.scalar_int('Minimum_2')]
+			ArgStruct.scalar_enum('Channel_Type', enums.SidelinkChannelType)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Maximum_1: int = None
-			self.Minimum_1: int = None
-			self.Maximum_2: int = None
-			self.Minimum_2: int = None
+			self.Channel_Type: enums.SidelinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent:SCINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.current.scIndex.fetch(segment = repcap.Segment.Default) \n
-		Return subcarrier indices of the equalizer spectrum flatness measurement for segment <no> in list mode. At these SC
-		indices, the current minimum and maximum power of the equalizer coefficients have been detected within range 1 and range
-		2. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SCHType \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.schType.fetch(segment = repcap.Segment.Default) \n
+		Returns the sidelink channel type evaluated for modulation results, for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent:SCINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/StandardDev.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,106 +1,91 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1'),
-			ArgStruct.scalar_float('Min_R_1'),
-			ArgStruct.scalar_float('Max_R_1'),
-			ArgStruct.scalar_float('Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
-			self.Min_R_1: float = None
-			self.Max_R_1: float = None
-			self.Min_R_2: float = None
-			self.Max_R_2: float = None
-
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.extreme.fetch(segment = repcap.Segment.Default) \n
-		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
-		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:EXTReme?', self.__class__.FetchStruct())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1) Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position. Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position. Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position. Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position. Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position. Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position. Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position. Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position. Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position. Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position. Unit: deg
+			- Frequency_Error: float: float Carrier frequency error. Unit: Hz
+			- Timing_Error: float: float Transmit time error. Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power. Unit: dBm
+			- Peak_Power: float: float User equipment peak power. Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float('Evm_Rms_Low'),
+			ArgStruct.scalar_float('Evm_Rms_High'),
+			ArgStruct.scalar_float('Evm_Peak_Low'),
+			ArgStruct.scalar_float('Evm_Peak_High'),
+			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float('Frequency_Error'),
+			ArgStruct.scalar_float('Timing_Error'),
+			ArgStruct.scalar_float('Tx_Power'),
+			ArgStruct.scalar_float('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
-
-	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.extreme.calculate(segment = repcap.Segment.Default) \n
-		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:EXTReme?', self.__class__.CalculateStruct())
+			self.Evm_Rms_Low: float = None
+			self.Evm_Rms_High: float = None
+			self.Evm_Peak_Low: float = None
+			self.Evm_Peak_High: float = None
+			self.Mag_Error_Rms_Low: float = None
+			self.Mag_Error_Rms_High: float = None
+			self.Mag_Error_Peak_Low: float = None
+			self.Mag_Err_Peak_High: float = None
+			self.Ph_Error_Rms_Low: float = None
+			self.Ph_Error_Rms_High: float = None
+			self.Ph_Error_Peak_Low: float = None
+			self.Ph_Error_Peak_High: float = None
+			self.Frequency_Error: float = None
+			self.Timing_Error: float = None
+			self.Tx_Power: float = None
+			self.Peak_Power: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation \n
+		Snippet: value: ResultData = driver.prach.modulation.standardDev.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation \n
+		Snippet: value: ResultData = driver.prach.modulation.standardDev.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Ripple_1: float: Max (range 1) - min (range 1) Unit: dB
-			- Ripple_2: float: Max (range 2) - min (range 2) Unit: dB
-			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2) Unit: dB
-			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1) Unit: dB
-			- Min_R_1: float: Min (range 1) Unit: dB
-			- Max_R_1: float: Max (range 1) Unit: dB
-			- Min_R_2: float: Min (range 2) Unit: dB
-			- Max_R_2: float: Max (range 2) Unit: dB"""
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Ripple_1: float: float Max (range 1) - min (range 1) Unit: dB
+			- Ripple_2: float: float Max (range 2) - min (range 2) Unit: dB
+			- Max_R_1_Min_R_2: float: float Max (range 1) - min (range 2) Unit: dB
+			- Max_R_2_Min_R_1: float: float Max (range 2) - min (range 1) Unit: dB
+			- Min_R_1: float: float Min (range 1) Unit: dB
+			- Max_R_1: float: float Max (range 1) Unit: dB
+			- Min_R_2: float: float Min (range 2) Unit: dB
+			- Max_R_2: float: float Max (range 2) Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Ripple_1'),
 			ArgStruct.scalar_float('Ripple_2'),
 			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
@@ -57,9 +57,9 @@
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:SDEViation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.standardDev.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 6 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .Cc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
@@ -41,10 +41,10 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.average.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,38 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
@@ -49,18 +49,18 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.current.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/RbIndex.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from .........Internal.CommandsGroup import CommandsGroup
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Rb_Index: int: Resource block index of margin"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Rb_Index: int: decimal Resource block index of margin"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_int('Rb_Index')]
 
@@ -40,10 +40,10 @@
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:CURRent:RBINdex \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.current.rbIndex.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Return resource block indices of the component carrier CC<c> inband emission measurement for segment <no> in list mode.
 		At these RB indices, the CURRent and EXTReme margins have been detected. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,38 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
@@ -49,18 +49,18 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.extreme.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/RbIndex.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from .........Internal.CommandsGroup import CommandsGroup
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Rb_Index: int: Resource block index of margin"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Rb_Index: int: decimal Resource block index of margin"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_int('Rb_Index')]
 
@@ -40,10 +40,10 @@
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:EXTReme:RBINdex \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Return resource block indices of the component carrier CC<c> inband emission measurement for segment <no> in list mode.
 		At these RB indices, the CURRent and EXTReme margins have been detected. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin: float: Unit: dB"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin: float: float Unit: dB"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
@@ -41,10 +41,10 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.standardDev.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
@@ -38,9 +38,9 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:AVERage \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.average.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/All.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,62 +1,65 @@
+from typing import List
+
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin_Curr_Neg: List[float]: No parameter help available
+			- Margin_Curr_Pos: List[float]: No parameter help available
+			- Margin_Avg_Neg: List[float]: No parameter help available
+			- Margin_Avg_Pos: List[float]: No parameter help available
+			- Margin_Min_Neg: List[float]: No parameter help available
+			- Margin_Min_Pos: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct('Margin_Curr_Neg', DataType.FloatList, None, False, False, 12),
+			ArgStruct('Margin_Curr_Pos', DataType.FloatList, None, False, False, 12),
+			ArgStruct('Margin_Avg_Neg', DataType.FloatList, None, False, False, 12),
+			ArgStruct('Margin_Avg_Pos', DataType.FloatList, None, False, False, 12),
+			ArgStruct('Margin_Min_Neg', DataType.FloatList, None, False, False, 12),
+			ArgStruct('Margin_Min_Pos', DataType.FloatList, None, False, False, 12)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Margin_Curr_Neg: List[float] = None
+			self.Margin_Curr_Pos: List[float] = None
+			self.Margin_Avg_Neg: List[float] = None
+			self.Margin_Avg_Pos: List[float] = None
+			self.Margin_Min_Neg: List[float] = None
+			self.Margin_Min_Pos: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.current.fetch(segment = repcap.Segment.Default) \n
-		No command help available \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:ALL \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.all.fetch(segment = repcap.Segment.Default) \n
+		Return limit line margin values, i.e. vertical distances between the spectrum emission mask and a trace, for segment <no>
+		in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:ALL?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/RbIndex.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
@@ -38,9 +38,9 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent:RBINdex \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.current.rbIndex.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/RbIndex.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,62 +1,46 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Rb_Index: int: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Rb_Index: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.extreme.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/StandardDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,45 +2,47 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Margin: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default) \n
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.standardDev.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
@@ -38,9 +38,9 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:SDEViation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.standardDev.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 6 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .Scc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,21 +1,29 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
+
+	@property
+	def rbIndex(self):
+		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rbIndex'):
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
+		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
@@ -33,16 +41,24 @@
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.average.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
@@ -47,18 +47,18 @@
 	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:CURRent \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.current.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/RbIndex.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from .........Internal.CommandsGroup import CommandsGroup
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
@@ -39,10 +39,10 @@
 	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:CURRent:RBINdex \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.current.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,27 +2,27 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
@@ -40,25 +40,23 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.extreme.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Average.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from ......... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.average.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Rms.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,48 +1,45 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from typing import List
+
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Step_Rms_Power: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct('Step_Rms_Power', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
-
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.standardDev.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
+			self.Step_Rms_Power: List[float] = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:RMS \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pmonitor.rms.fetch(segment = repcap.Segment.Default) \n
+		Return the power monitor results for segment <no> in list mode. The commands return one power result for each subframe of
+		the segment for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value
+		within the subframe. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:RMS?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 11 total commands, 8 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 11 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Modulation_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Modulation_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Modulation_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Modulation_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Modulation_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Modulation_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def schType(self):
 		"""schType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_schType'):
-			from .Modulation_.SchType import SchType
-			self._schType = SchType(self._core, self._base)
+			from .SchType import SchTypeCls
+			self._schType = SchTypeCls(self._core, self._cmd_group)
 		return self._schType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Modulation_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,52 +2,52 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power Unit: dBm
+			- Peak_Power: float: float User equipment peak power Unit: dBm
 			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
@@ -102,119 +102,119 @@
 			self.Evm_Dmrs_High: float = None
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.current.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float or bool: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float or bool: float User equipment power Unit: dBm
+			- Peak_Power: float or bool: float User equipment peak power Unit: dBm
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float or bool: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float or bool: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float or bool: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float or bool: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float or bool: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.average.calculate(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.current.calculate(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,52 +2,52 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power Unit: dBm
+			- Peak_Power: float: float User equipment peak power Unit: dBm
 			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
@@ -102,119 +102,119 @@
 			self.Evm_Dmrs_High: float = None
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.current.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float or bool: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float or bool: float User equipment power Unit: dBm
+			- Peak_Power: float or bool: float User equipment peak power Unit: dBm
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float or bool: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float or bool: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float or bool: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float or bool: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float or bool: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.current.calculate(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.average.calculate(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Dallocation.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,45 +2,44 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Nr_Res_Blocks: int: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: int: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dallocation.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DALLocation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.dallocation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected allocation results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DALLocation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/DchType.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
 			- Channel_Type: enums.UplinkChannelType: PUSCh | PUCCh"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.UplinkChannelType)]
 
 		def __init__(self):
@@ -31,14 +31,13 @@
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.UplinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DCHType \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dchType.fetch(segment = repcap.Segment.Default) \n
 		Return the uplink channel type for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected channel type results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dmodulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Dmodulation.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
 			- Modulation: enums.Modulation: QPSK | Q16 | Q64 | Q256 QPSK, 16-QAM, 64-QAM, 256-QAM"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Modulation', enums.Modulation)]
 
 		def __init__(self):
@@ -35,9 +35,9 @@
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DMODulation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dmodulation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected modulation scheme for segment <no> in list mode. The result is determined from the last measured slot
 		of the statistical length. If channel type PUCCH is detected, QPSK is returned as modulation type because the QPSK limits
 		are applied in that case. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DMODulation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,55 +2,55 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power_Minimum: float: Minimum user equipment power Unit: dBm
-			- Tx_Power_Maximum: float: No parameter help available
-			- Peak_Power_Min: float: Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power_Max: float: Maximum user equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power_Minimum: float: float Minimum user equipment power Unit: dBm
+			- Tx_Power_Maximum: float: float Maximum user equipment power Unit: dBm
+			- Peak_Power_Min: float: float Minimum user equipment peak power Unit: dBm
+			- Peak_Power_Max: float: float Maximum user equipment peak power Unit: dBm
 			- Psd_Minimum: float: No parameter help available
 			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
@@ -113,126 +113,126 @@
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:EXTReme \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.extreme.fetch(segment = repcap.Segment.Default) \n
-		Return modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		Return modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:EXTReme?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power_Minimum: float: Minimum user equipment power Unit: dBm
-			- Tx_Power_Maximum: float: No parameter help available
-			- Peak_Power_Min: float: Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power_Max: float: Maximum user equipment peak power Unit: dBm
-			- Psd_Minimum: float: No parameter help available
-			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float or bool: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power_Minimum: float or bool: float Minimum user equipment power Unit: dBm
+			- Tx_Power_Maximum: float or bool: float Maximum user equipment power Unit: dBm
+			- Peak_Power_Min: float or bool: float Minimum user equipment peak power Unit: dBm
+			- Peak_Power_Max: float or bool: float Maximum user equipment peak power Unit: dBm
+			- Psd_Minimum: float or bool: No parameter help available
+			- Psd_Maximum: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float or bool: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float or bool: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float or bool: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float or bool: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float or bool: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max'),
-			ArgStruct.scalar_float('Psd_Minimum'),
-			ArgStruct.scalar_float('Psd_Maximum'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power_Minimum'),
+			ArgStruct.scalar_float_ext('Tx_Power_Maximum'),
+			ArgStruct.scalar_float_ext('Peak_Power_Min'),
+			ArgStruct.scalar_float_ext('Peak_Power_Max'),
+			ArgStruct.scalar_float_ext('Psd_Minimum'),
+			ArgStruct.scalar_float_ext('Psd_Maximum'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
-			self.Psd_Minimum: float = None
-			self.Psd_Maximum: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power_Minimum: float or bool = None
+			self.Tx_Power_Maximum: float or bool = None
+			self.Peak_Power_Min: float or bool = None
+			self.Peak_Power_Max: float or bool = None
+			self.Psd_Minimum: float or bool = None
+			self.Psd_Maximum: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:EXTReme \n
 		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.extreme.calculate(segment = repcap.Segment.Default) \n
-		Return modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		Return modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/SchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Peak.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,41 +1,45 @@
+from typing import List
+
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SchType:
-	"""SchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("schType", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Channel_Type: enums.SidelinkChannelType: PSSCh | PSCCh"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Step_Peak_Power: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_enum('Channel_Type', enums.SidelinkChannelType)]
+			ArgStruct('Step_Peak_Power', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
-			self.Channel_Type: enums.SidelinkChannelType = None
+			self.Step_Peak_Power: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SCHType \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.schType.fetch(segment = repcap.Segment.Default) \n
-		Returns the sidelink channel type evaluated for modulation results, for segment <no> in list mode. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:PEAK \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pmonitor.peak.fetch(segment = repcap.Segment.Default) \n
+		Return the power monitor results for segment <no> in list mode. The commands return one power result for each subframe of
+		the segment for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value
+		within the subframe. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SCHType?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:PEAK?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,52 +2,52 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power Unit: dBm
+			- Peak_Power: float: float User equipment peak power Unit: dBm
 			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
@@ -104,14 +104,14 @@
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SDEViation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.standardDev.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
 		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pmonitor/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,43 +1,27 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 4 total commands, 3 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rms'):
-			from .Pmonitor_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def peak(self):
-		"""peak commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_peak'):
-			from .Pmonitor_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
-
-	@property
-	def array(self):
-		"""array commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_array'):
-			from .Pmonitor_.Array import Array
-			self._array = Array(self._core, self._base)
-		return self._array
-
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Array:
-	"""Array commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("array", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def start(self):
-		"""start commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_start'):
-			from .Array_.Start import Start
-			self._start = Start(self._core, self._base)
-		return self._start
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def length(self):
-		"""length commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_length'):
-			from .Array_.Length import Length
-			self._length = Length(self._core, self._base)
-		return self._length
-
-	def clone(self) -> 'Array':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Array(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Length.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/Length.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Length:
-	"""Length commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LengthCls:
+	"""Length commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("length", core, parent)
+		self._cmd_group = CommandsGroup("length", core, parent)
 
 	def fetch(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:ARRay:LENGth \n
 		Snippet: value: int = driver.multiEval.listPy.segment.pmonitor.array.length.fetch(segment = repcap.Segment.Default) \n
 		Returns the number of power monitor results for segment <no> contained in a result list for all measured segments. Such a
 		result list is, for example, returned by the command method RsCmwLteMeas.MultiEval.ListPy.Pmonitor.Rms.fetch. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: length: Number of power monitor results"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: length: decimal Number of power monitor results"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:ARRay:LENGth?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Start.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/Start.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,28 +3,28 @@
 from .......Internal import Conversions
 from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .......Internal.Types import DataType
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Start:
-	"""Start commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StartCls:
+	"""Start commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("start", core, parent)
+		self._cmd_group = CommandsGroup("start", core, parent)
 
 	def fetch(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:ARRay:STARt \n
 		Snippet: value: int = driver.multiEval.listPy.segment.pmonitor.array.start.fetch(segment = repcap.Segment.Default) \n
 		Returns the offset of the first power monitor result for segment <no> within a result list for all measured segments.
 		Such a result list is, for example, returned by the command method RsCmwLteMeas.MultiEval.ListPy.Pmonitor.Rms.fetch.
 		A returned <Start> value n indicates that the result for the first subframe of the segment is the (n+1) th result in the
 		power result list over all segments. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: start: Offset of the first power monitor result"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: start: decimal Offset of the first power monitor result"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:ARRay:STARt?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Peak.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/StandardDev.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,45 +1,51 @@
-from typing import List
-
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Step_Peak_Power: List[float]: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float: float Total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct('Step_Peak_Power', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Obw'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
-			self.Step_Peak_Power: List[float] = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Obw: float = None
+			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:PEAK \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pmonitor.peak.fetch(segment = repcap.Segment.Default) \n
-		Return the power monitor results for segment <no> in list mode. The commands return one power result for each subframe of
-		the segment for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value
-		within the subframe. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:SDEViation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.standardDev.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
+		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:PEAK?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Rms.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/Negativ.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,45 +1,55 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Step_Rms_Power: List[float]: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin_Curr_Neg_X: List[float]: No parameter help available
+			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct('Step_Rms_Power', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
-			self.Step_Rms_Power: List[float] = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Margin_Curr_Neg_X: List[float] = None
+			self.Margin_Curr_Neg_Y: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:RMS \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pmonitor.rms.fetch(segment = repcap.Segment.Default) \n
-		Return the power monitor results for segment <no> in list mode. The commands return one power result for each subframe of
-		the segment for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value
-		within the subframe. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:NEGativ \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.current.negativ.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
+		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
+		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
+		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:RMS?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,59 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class ScIndexCls:
+	"""ScIndex commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
-
-	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Power_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Power_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+		self._cmd_group = CommandsGroup("scIndex", core, parent)
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		"""minimum commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Power_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		"""maximum commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Power_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Power_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScIndexCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScIndexCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in subframes
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Tx_Power: float: Total TX power of all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Tx_Power: float: float Total TX power of all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
@@ -38,41 +38,41 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:AVERage \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.average.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.average.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in subframes
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Tx_Power: float: Total TX power of all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Tx_Power: float: float Total TX power of all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
@@ -38,41 +38,41 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CURRent \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.current.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.current.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Maximum.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,28 +2,28 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in subframes
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
 			- Tx_Power_Max: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power_Max')]
@@ -38,41 +38,41 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MAXimum \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.maximum.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MAXimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power_Max: float: No parameter help available"""
+			- Tx_Power_Max: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Max: float = None
+			self.Tx_Power_Max: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.maximum.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Average.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,77 +2,87 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in subframes
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Tx_Power_Min: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float: float Total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Min')]
+			ArgStruct.scalar_float('Obw'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Min: float = None
+			self.Obw: float = None
+			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.minimum.fetch(segment = repcap.Segment.Default) \n
-		Return total TX power results for segment <no> in list mode. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.average.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
+		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power_Min: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float or bool: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float or bool: float Total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Min')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Min: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.minimum.calculate(segment = repcap.Segment.Default) \n
-		No command help available \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.average.calculate(segment = repcap.Segment.Default) \n
+		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
+		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,29 +2,29 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in subframes
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Tx_Power: float: Total TX power of all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Tx_Power: float: float Total TX power of all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
@@ -38,9 +38,9 @@
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:SDEViation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.standardDev.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,75 +1,91 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 16 total commands, 7 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 20 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .SeMask_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
+	def preamble(self):
+		"""preamble commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_preamble'):
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
+		return self._preamble
+
+	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .SeMask_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .SeMask_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .SeMask_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .SeMask_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
-
-	@property
-	def dchType(self):
-		"""dchType commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dchType'):
-			from .SeMask_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
-		return self._dchType
-
-	@property
-	def dallocation(self):
-		"""dallocation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dallocation'):
-			from .SeMask_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
-		return self._dallocation
+	def dpfOffset(self):
+		"""dpfOffset commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dpfOffset'):
+			from .DpfOffset import DpfOffsetCls
+			self._dpfOffset = DpfOffsetCls(self._core, self._cmd_group)
+		return self._dpfOffset
+
+	@property
+	def dsIndex(self):
+		"""dsIndex commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dsIndex'):
+			from .DsIndex import DsIndexCls
+			self._dsIndex = DsIndexCls(self._core, self._cmd_group)
+		return self._dsIndex
+
+	@property
+	def scorrelation(self):
+		"""scorrelation commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_scorrelation'):
+			from .Scorrelation import ScorrelationCls
+			self._scorrelation = ScorrelationCls(self._core, self._cmd_group)
+		return self._scorrelation
+
+	@property
+	def nsymbol(self):
+		"""nsymbol commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_nsymbol'):
+			from .Nsymbol import NsymbolCls
+			self._nsymbol = NsymbolCls(self._core, self._cmd_group)
+		return self._nsymbol
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,30 +2,30 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float: float Total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
@@ -36,53 +36,53 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.average.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.current.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
 		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float or bool: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float or bool: float Total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.average.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.current.calculate(segment = repcap.Segment.Default) \n
 		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
 		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Extreme.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,87 +2,93 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power_Min: float: float Minimum total TX power in the slot Unit: dBm
+			- Tx_Power_Max: float: float Maximum total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float('Tx_Power_Min'),
+			ArgStruct.scalar_float('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Tx_Power_Min: float = None
+			self.Tx_Power_Max: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.current.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:EXTReme \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.extreme.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission extreme results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:EXTReme?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Obw: float or bool: float Occupied bandwidth Unit: Hz
+			- Tx_Power_Min: float or bool: float Minimum total TX power in the slot Unit: dBm
+			- Tx_Power_Max: float or bool: float Maximum total TX power in the slot Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power_Min'),
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power_Min: float or bool = None
+			self.Tx_Power_Max: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.current.calculate(segment = repcap.Segment.Default) \n
-		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:EXTReme \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.extreme.calculate(segment = repcap.Segment.Default) \n
+		Return spectrum emission extreme results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Dallocation.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,28 +2,28 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Nr_Res_Blocks: int: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: int: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
@@ -33,14 +33,13 @@
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DALLocation \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.dallocation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected allocation results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/DchType.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 from ...... import enums
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
 			- Channel_Type: enums.UplinkChannelType: PUSCh | PUCCh"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.UplinkChannelType)]
 
 		def __init__(self):
@@ -31,14 +31,13 @@
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.UplinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DCHType \n
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.dchType.fetch(segment = repcap.Segment.Default) \n
 		Return the uplink channel type for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected channel type results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Minimum.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,94 +1,82 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power_Min: float: Minimum total TX power in the slot Unit: dBm
-			- Tx_Power_Max: float: Maximum total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Tx_Power_Min: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power_Min'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float('Tx_Power_Min')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
 			self.Tx_Power_Min: float = None
-			self.Tx_Power_Max: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.extreme.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission extreme results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
-		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
+	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CC<no>:MINimum \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.cc.minimum.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return TX power results for component carrier CC<no> and a single segment in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:EXTReme?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power_Min: float: Minimum total TX power in the slot Unit: dBm
-			- Tx_Power_Max: float: Maximum total TX power in the slot Unit: dBm"""
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power_Min: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power_Min'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float_ext('Tx_Power_Min')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power_Min: float = None
-			self.Tx_Power_Max: float = None
+			self.Tx_Power_Min: float or bool = None
 
-	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.extreme.calculate(segment = repcap.Segment.Default) \n
-		Return spectrum emission extreme results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
-		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
+	def calculate(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CC<no>:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.cc.minimum.calculate(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:EXTReme?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .Margin_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	@property
 	def current(self):
 		"""current commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Margin_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def negativ(self):
 		"""negativ commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Average_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
 	def positiv(self):
 		"""positiv commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Average_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/Negativ.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,28 +5,28 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
 			- Margin_Avg_Neg_X: List[float]: No parameter help available
 			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -47,9 +47,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.average.negativ.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:AVERage:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/Positiv.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,28 +5,28 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
 			- Margin_Avg_Pos_X: List[float]: No parameter help available
 			- Margin_Avg_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -47,9 +47,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.average.positiv.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:AVERage:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	@property
 	def negativ(self):
 		"""negativ commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Current_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
 	def positiv(self):
 		"""positiv commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Current_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/Positiv.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,51 +5,51 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin_Curr_Neg_X: List[float]: No parameter help available
-			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin_Curr_Pos_X: List[float]: No parameter help available
+			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Curr_Neg_X: List[float] = None
-			self.Margin_Curr_Neg_Y: List[float] = None
+			self.Margin_Curr_Pos_X: List[float] = None
+			self.Margin_Curr_Pos_Y: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.current.negativ.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:POSitiv \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.current.positiv.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:NEGativ?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Negativ.py`

 * *Files 18% similar despite different names*

```diff
@@ -5,51 +5,51 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin_Curr_Pos_X: List[float]: No parameter help available
-			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Margin_Min_Neg_X: List[float]: No parameter help available
+			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Curr_Pos_X: List[float] = None
-			self.Margin_Curr_Pos_Y: List[float] = None
+			self.Margin_Min_Neg_X: List[float] = None
+			self.Margin_Min_Neg_Y: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:POSitiv \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.current.positiv.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:MINimum:NEGativ \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.minimum.negativ.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:POSitiv?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Minimum_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def pdynamics(self):
+		"""pdynamics commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
 
-	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Minimum_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
-
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/ScIndex.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,55 +1,47 @@
-from typing import List
-
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ScIndexCls:
+	"""ScIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("scIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Margin_Min_Neg_X: List[float]: No parameter help available
-			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Maximum_1: int: decimal SC index of 'Max (Range 1) '
+			- Minimum_1: int: decimal SC index of 'Min (Range 1) '
+			- Maximum_2: int: decimal SC index of 'Max (Range 2) '
+			- Minimum_2: int: decimal SC index of 'Min (Range 2) '"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_int('Maximum_1'),
+			ArgStruct.scalar_int('Minimum_1'),
+			ArgStruct.scalar_int('Maximum_2'),
+			ArgStruct.scalar_int('Minimum_2')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Min_Neg_X: List[float] = None
-			self.Margin_Min_Neg_Y: List[float] = None
-
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:MINimum:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.minimum.negativ.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
-		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
-		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
-		}area2, ..., {...}area12 \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			self.Maximum_1: int = None
+			self.Minimum_1: int = None
+			self.Maximum_2: int = None
+			self.Minimum_2: int = None
+
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent:SCINdex \n
+		Snippet: value: FetchStruct = driver.multiEval.esFlatness.current.scIndex.fetch() \n
+		Returns subcarrier indices of the equalizer spectrum flatness measurement. At these SC indices, the current minimum and
+		maximum power of the equalizer coefficients have been detected within range 1 and range 2. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:NEGativ?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent:SCINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Positiv.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,28 +5,28 @@
 from ........Internal.Types import DataType
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in slots
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
 			- Margin_Min_Pos_X: List[float]: No parameter help available
 			- Margin_Min_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -47,9 +47,9 @@
 		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.minimum.positiv.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,48 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Seg_Reliability: int: decimal Reliability indicator for the segment
+			- Statist_Expired: int: decimal Reached statistical length in subframes
+			- Out_Of_Tolerance: int: decimal Percentage of measured subframes with failed limit check Unit: %
+			- Tx_Power: float: float TX power of the component carrier Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
 			self.Tx_Power: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.standardDev.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
-		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
+	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CC<no>:SDEViation \n
+		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.cc.standardDev.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return TX power results for component carrier CC<no> and a single segment in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Sreliability.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Sreliability.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,26 +3,26 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sreliability:
-	"""Sreliability commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SreliabilityCls:
+	"""Sreliability commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sreliability", core, parent)
+		self._cmd_group = CommandsGroup("sreliability", core, parent)
 
 	def fetch(self) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SRELiability \n
 		Snippet: value: List[int] = driver.multiEval.listPy.sreliability.fetch() \n
 		Returns the segment reliability for all measured list mode segments. A common reliability indicator of zero indicates
 		that the results in all measured segments are valid. A non-zero value indicates that an error occurred in at least one of
 		the measured segments. If you get a non-zero common reliability indicator, you can use this command to retrieve the
 		individual reliability values of all measured segments for further analysis. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: seg_reliability: Comma-separated list of values, one per measured segment The meaning of the returned values is the same as for the common reliability indicator, see previous parameter."""
+			:return: seg_reliability: decimal Comma-separated list of values, one per measured segment The meaning of the returned values is the same as for the common reliability indicator, see previous parameter."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SRELiability?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Merror:
-	"""Merror commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("merror", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Merror_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Merror_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Merror_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Merror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Merror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/Average.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Magnitude error value for low EVM window position Unit: %
-			- High: List[float]: Magnitude error value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float Magnitude error value for low EVM window position Unit: %
+			- High: List[float]: float Magnitude error value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -33,21 +33,21 @@
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.merror.average.read() \n
 		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
 		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.merror.average.fetch() \n
 		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
 		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Merror/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Magnitude error value for low EVM window position Unit: %
-			- High: List[float]: Magnitude error value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float Magnitude error value for low EVM window position Unit: %
+			- High: List[float]: float Magnitude error value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -33,21 +33,21 @@
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.merror.current.read() \n
 		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
 		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.merror.current.fetch() \n
 		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
 		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Merror_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/Maximum.py`

 * *Files 9% similar despite different names*

```diff
@@ -4,50 +4,50 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Magnitude error value for low EVM window position Unit: %
-			- High: List[float]: Magnitude error value for high EVM window position Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float Phase error value for low EVM window position Unit: deg
+			- High: List[float]: float Phase error value for high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.merror.maximum.read() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views
-		Magnitude Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.perror.maximum.read() \n
+		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Magnitude Error,
+		Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.merror.maximum.fetch() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views
-		Magnitude Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
+		Snippet: value: ResultData = driver.multiEval.perror.maximum.fetch() \n
+		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Magnitude Error,
+		Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 15 total commands, 8 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 15 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Modulation_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Modulation_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Modulation_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Modulation_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Modulation_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Modulation_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def schType(self):
 		"""schType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_schType'):
-			from .Modulation_.SchType import SchType
-			self._schType = SchType(self._core, self._base)
+			from .SchType import SchTypeCls
+			self._schType = SchTypeCls(self._core, self._cmd_group)
 		return self._schType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Modulation_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,53 +1,53 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power Unit: dBm
+			- Peak_Power: float: float User equipment peak power Unit: dBm
 			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -104,124 +104,124 @@
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 			self.Iq_Gain_Imbalance: float = None
 			self.Iq_Quadrature_Err: float = None
 			self.Evm_Srs: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.average.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.current.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.average.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.modulation.current.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float or bool: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float or bool: float User equipment power Unit: dBm
+			- Peak_Power: float or bool: float User equipment peak power Unit: dBm
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float or bool: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float or bool: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float or bool: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float or bool: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float or bool: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float or bool: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float or bool: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float_ext('Iq_Quadrature_Err'),
 			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+			self.Iq_Gain_Imbalance: float or bool = None
+			self.Iq_Quadrature_Err: float or bool = None
 			self.Evm_Srs: float = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.average.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.current.calculate() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,53 +1,53 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power Unit: dBm
+			- Peak_Power: float: float User equipment peak power Unit: dBm
 			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -104,124 +104,124 @@
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 			self.Iq_Gain_Imbalance: float = None
 			self.Iq_Quadrature_Err: float = None
 			self.Evm_Srs: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.current.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.average.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.current.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.modulation.average.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float or bool: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float or bool: float User equipment power Unit: dBm
+			- Peak_Power: float or bool: float User equipment peak power Unit: dBm
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float or bool: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float or bool: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float or bool: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float or bool: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float or bool: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float or bool: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float or bool: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float_ext('Iq_Quadrature_Err'),
 			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+			self.Iq_Gain_Imbalance: float or bool = None
+			self.Iq_Quadrature_Err: float or bool = None
 			self.Evm_Srs: float = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.current.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
+		Snippet: value: CalculateStruct = driver.multiEval.modulation.average.calculate() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Dallocation.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nr_Res_Blocks: int: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: int: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/DchType.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.UplinkChannelType:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DCHType \n
 		Snippet: value: enums.UplinkChannelType = driver.multiEval.modulation.dchType.fetch() \n
 		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Dmodulation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Dmodulation.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.Modulation:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DMODulation \n
 		Snippet: value: enums.Modulation = driver.multiEval.modulation.dmodulation.fetch() \n
 		Returns the detected modulation scheme in the measured slot. If channel type PUCCH is detected, QPSK is returned as
 		modulation type because the QPSK limits are applied in that case. \n
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,55 +1,55 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power_Minimum: float: Minimum user equipment power Unit: dBm
-			- Tx_Power_Maximum: float: No parameter help available
-			- Peak_Power_Min: float: Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power_Max: float: Maximum user equipment peak power Unit: dBm
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power_Minimum: float: float Minimum user equipment power Unit: dBm
+			- Tx_Power_Maximum: float: float Maximum user equipment power Unit: dBm
+			- Peak_Power_Min: float: float Minimum user equipment peak power Unit: dBm
+			- Peak_Power_Max: float: float Maximum user equipment peak power Unit: dBm
 			- Psd_Minimum: float: No parameter help available
 			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
 			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
@@ -130,110 +130,110 @@
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power_Minimum: float: Minimum user equipment power Unit: dBm
-			- Tx_Power_Maximum: float: No parameter help available
-			- Peak_Power_Min: float: Range: -99.99 dBm to 99.99 dBm, Unit: dBm
-			- Peak_Power_Max: float: Maximum user equipment peak power Unit: dBm
-			- Psd_Minimum: float: No parameter help available
-			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float or bool: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power_Minimum: float or bool: float Minimum user equipment power Unit: dBm
+			- Tx_Power_Maximum: float or bool: float Maximum user equipment power Unit: dBm
+			- Peak_Power_Min: float or bool: float Minimum user equipment peak power Unit: dBm
+			- Peak_Power_Max: float or bool: float Maximum user equipment peak power Unit: dBm
+			- Psd_Minimum: float or bool: No parameter help available
+			- Psd_Maximum: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float or bool: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float or bool: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float or bool: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float or bool: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float or bool: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float or bool: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float or bool: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max'),
-			ArgStruct.scalar_float('Psd_Minimum'),
-			ArgStruct.scalar_float('Psd_Maximum'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power_Minimum'),
+			ArgStruct.scalar_float_ext('Tx_Power_Maximum'),
+			ArgStruct.scalar_float_ext('Peak_Power_Min'),
+			ArgStruct.scalar_float_ext('Peak_Power_Max'),
+			ArgStruct.scalar_float_ext('Psd_Minimum'),
+			ArgStruct.scalar_float_ext('Psd_Maximum'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float_ext('Iq_Quadrature_Err'),
 			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
-			self.Psd_Minimum: float = None
-			self.Psd_Maximum: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power_Minimum: float or bool = None
+			self.Tx_Power_Maximum: float or bool = None
+			self.Peak_Power_Min: float or bool = None
+			self.Peak_Power_Max: float or bool = None
+			self.Psd_Minimum: float or bool = None
+			self.Psd_Maximum: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+			self.Iq_Gain_Imbalance: float or bool = None
+			self.Iq_Quadrature_Err: float or bool = None
 			self.Evm_Srs: float = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
 		Snippet: value: CalculateStruct = driver.multiEval.modulation.extreme.calculate() \n
 		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/SchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/SchType.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SchType:
-	"""SchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SchTypeCls:
+	"""SchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("schType", core, parent)
+		self._cmd_group = CommandsGroup("schType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.SidelinkChannelType:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SCHType \n
 		Snippet: value: enums.SidelinkChannelType = driver.multiEval.modulation.schType.fetch() \n
 		Returns the sidelink channel type evaluated for modulation results. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Modulation_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Modulation/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,53 +1,53 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Iq_Offset: float: I/Q origin offset Unit: dBc
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Iq_Offset: float: float I/Q origin offset Unit: dBc
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power Unit: dBm
+			- Peak_Power: float: float User equipment peak power Unit: dBm
 			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position Unit: %
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position Unit: %
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position Unit: %
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position Unit: %
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position Unit: deg
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position Unit: deg
-			- Iq_Gain_Imbalance: float: Gain imbalance Unit: dB
-			- Iq_Quadrature_Err: float: Quadrature error Unit: deg
-			- Evm_Srs: float: Error vector magnitude result for SRS signals Unit: %"""
+			- Evm_Dmrs_Low: float: float EVM DMRS value, low EVM window position Unit: %
+			- Evm_Dmrs_High: float: float EVM DMRS value, high EVM window position Unit: %
+			- Mag_Err_Dmrs_Low: float: float Magnitude error DMRS value, low EVM window position Unit: %
+			- Mag_Err_Dmrs_High: float: float Magnitude error DMRS value, high EVM window position Unit: %
+			- Ph_Error_Dmrs_Low: float: float Phase error DMRS value, low EVM window position Unit: deg
+			- Ph_Error_Dmrs_High: float: float Phase error DMRS value, high EVM window position Unit: deg
+			- Iq_Gain_Imbalance: float: float Gain imbalance Unit: dB
+			- Iq_Quadrature_Err: float: float Quadrature error Unit: deg
+			- Evm_Srs: float: float Error vector magnitude result for SRS signals Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -106,15 +106,15 @@
 			self.Iq_Gain_Imbalance: float = None
 			self.Iq_Quadrature_Err: float = None
 			self.Evm_Srs: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.modulation.standardDev.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.modulation.standardDev.fetch() \n
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Aclr/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 14 total commands, 5 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def dchType(self):
+		"""dchType commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dchType'):
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
+		return self._dchType
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pdynamics_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def dallocation(self):
+		"""dallocation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dallocation'):
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
+		return self._dallocation
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Pdynamics_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -37,71 +37,71 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.average.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.average.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.average.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -37,71 +37,71 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.current.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.current.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.current.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Maximum.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -37,71 +37,71 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.maximum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.maximum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.maximum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -37,71 +37,71 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.minimum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.minimum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.minimum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pdynamics/StandardDev.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -37,30 +37,30 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.standardDev.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.pdynamics.standardDev.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
 			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Perror/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Phase error value for low EVM window position Unit: deg
-			- High: List[float]: Phase error value for high EVM window position Unit: deg"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float Phase error value for low EVM window position Unit: deg
+			- High: List[float]: float Phase error value for high EVM window position Unit: deg"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -33,21 +33,21 @@
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.perror.average.read() \n
 		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views Magnitude Error,
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Magnitude Error,
 		Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.perror.average.fetch() \n
 		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
 		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views Magnitude Error,
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View Magnitude Error,
 		Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Average.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,50 +4,48 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Phase error value for low EVM window position Unit: deg
-			- High: List[float]: Phase error value for high EVM window position Unit: deg"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position Unit: %
+			- High: List[float]: float EVM value for high EVM window position Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.perror.current.read() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views Magnitude Error,
-		Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.read() \n
+		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.perror.current.fetch() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views Magnitude Error,
-		Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.fetch() \n
+		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'View EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Perror_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Maximum.py`

 * *Files 17% similar despite different names*

```diff
@@ -4,50 +4,50 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Phase error value for low EVM window position Unit: deg
-			- High: List[float]: Phase error value for high EVM window position Unit: deg"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position. Unit: %
+			- High: List[float]: float EVM value for high EVM window position. Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.perror.maximum.read() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views Magnitude Error,
-		Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum \n
+		Snippet: value: ResultData = driver.prach.evmSymbol.maximum.read() \n
+		Returns the values of the EVM RMS bar graphs for the OFDM symbols in the measured preamble. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of EVM values per OFDM symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1 If the preamble contains only one symbol,
+		NCAPs are returned for the remaining symbol. See also 'View EVM vs Symbol'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.perror.maximum.fetch() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Views Magnitude Error,
-		Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum \n
+		Snippet: value: ResultData = driver.prach.evmSymbol.maximum.fetch() \n
+		Returns the values of the EVM RMS bar graphs for the OFDM symbols in the measured preamble. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of EVM values per OFDM symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1 If the preamble contains only one symbol,
+		NCAPs are returned for the remaining symbol. See also 'View EVM vs Symbol'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,67 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 24 total commands, 6 Sub-groups, 0 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 30 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
-	def cc(self):
-		"""cc commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cc'):
-			from .Pmonitor_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
+	def ripple(self):
+		"""ripple commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ripple'):
+			from .Ripple import RippleCls
+			self._ripple = RippleCls(self._core, self._cmd_group)
+		return self._ripple
+
+	@property
+	def difference(self):
+		"""difference commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_difference'):
+			from .Difference import DifferenceCls
+			self._difference = DifferenceCls(self._core, self._cmd_group)
+		return self._difference
+
+	@property
+	def minr(self):
+		"""minr commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_minr'):
+			from .Minr import MinrCls
+			self._minr = MinrCls(self._core, self._cmd_group)
+		return self._minr
+
+	@property
+	def maxr(self):
+		"""maxr commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_maxr'):
+			from .Maxr import MaxrCls
+			self._maxr = MaxrCls(self._core, self._cmd_group)
+		return self._maxr
+
+	@property
+	def scIndex(self):
+		"""scIndex commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scIndex'):
+			from .ScIndex import ScIndexCls
+			self._scIndex = ScIndexCls(self._core, self._cmd_group)
+		return self._scIndex
 
-	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Pmonitor_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .Pmonitor_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pmonitor_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pmonitor_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Pmonitor_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -44,25 +44,25 @@
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.average.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,74 +1,74 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 10 total commands, 5 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 10 total commands, 5 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Cc_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Cc_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Cc_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Cc_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Cc_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,48 +2,48 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.average.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.current.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Minimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,48 +2,48 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.current.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.minimum.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.minimum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,48 +2,48 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.maximum.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.average.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.maximum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,48 +2,48 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.minimum.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.standardDev.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.minimum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Minimum.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,49 +1,68 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
-	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.standardDev.read(carrierComponent = repcap.CarrierComponent.Default) \n
-		Returns the TX power of carrier CC<no>. \n
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.minimum.read() \n
+		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
 
-	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
-		Returns the TX power of carrier CC<no>. \n
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.minimum.fetch() \n
+		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
+
+	# noinspection PyTypeChecker
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float or bool: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
+		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.minimum.calculate() \n
+		No command help available \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -44,25 +44,25 @@
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.current.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Maximum.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
@@ -44,25 +44,25 @@
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum \n
 		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Pmonitor/StandardDev.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,68 +1,44 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits. Unit: %
+			- Tx_Power: float: float Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.minimum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.standardDev.read() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.minimum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
+		Snippet: value: ResultData = driver.multiEval.pmonitor.standardDev.fetch() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.minimum.calculate() \n
-		No command help available \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Iq.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,44 +1,43 @@
+from typing import List
+
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IqCls:
+	"""Iq commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("iq", core, parent)
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count that exceed the specified limits Unit: %
-			- Tx_Power: float: Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Iphase: List[float]: float Normalized I amplitude
+			- Qphase: List[float]: float Normalized Q amplitude"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Iphase: List[float] = None
+			self.Qphase: List[float] = None
 
-	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.standardDev.read() \n
-		Returns the total TX power of all carriers. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.standardDev.fetch() \n
-		Returns the total TX power of all carriers. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ \n
+		Snippet: value: FetchStruct = driver.prach.trace.iq.fetch() \n
+		Returns the results in the I/Q constellation diagram. There is one pair of values per modulation symbol. For preamble
+		format 4, there are 139 symbols. For preamble format 0 to 3, there are 839 symbols. The results are returned in the
+		following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ..., {<IPhase>, <QPhase>}symbol n See also 'View I/Q
+		Constellation'. \n
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ?', self.__class__.FetchStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 20 total commands, 7 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 16 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .SeMask_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .SeMask_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 3 commands."""
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .SeMask_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .SeMask_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .SeMask_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .SeMask_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .SeMask_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot over all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float: float Total TX power in the slot over all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
@@ -31,50 +31,50 @@
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.seMask.average.read() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage \n
 		Snippet: value: ResultData = driver.multiEval.seMask.average.fetch() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot over all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float or bool: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float or bool: float Total TX power in the slot over all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage \n
 		Snippet: value: CalculateStruct = driver.multiEval.seMask.average.calculate() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot over all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float: float Total TX power in the slot over all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
@@ -31,50 +31,50 @@
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.seMask.current.read() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
 		Snippet: value: ResultData = driver.multiEval.seMask.current.fetch() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot over all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float or bool: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float or bool: float Total TX power in the slot over all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
 		Snippet: value: CalculateStruct = driver.multiEval.seMask.current.calculate() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Dallocation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Dallocation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Nr_Res_Blocks: int: decimal Number of allocated resource blocks
+			- Offset_Res_Blocks: int: decimal Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/DchType.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/DchType.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,28 +1,31 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
-from .... import enums
+from typing import List
+
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.UplinkChannelType:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType \n
-		Snippet: value: enums.UplinkChannelType = driver.multiEval.seMask.dchType.fetch() \n
-		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
-		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
-		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
+	def fetch(self) -> List[enums.UplinkChannelType]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DCHType \n
+		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.aclr.dchType.fetch() \n
+		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: channel_type: PUSCh | PUCCh"""
+			:return: channel_type: PUSCh | PUCCh Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType?', suppressed)
-		return Conversions.str_to_scalar_enum(response, enums.UplinkChannelType)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DCHType?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Maximum.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,83 +1,92 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power_Min: float: Minimum total TX power in the slot Unit: dBm
-			- Tx_Power_Max: float: Maximum total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power_Min'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float('Off_Power_Before'),
+			ArgStruct.scalar_float('On_Power_Rms'),
+			ArgStruct.scalar_float('On_Power_Peak'),
+			ArgStruct.scalar_float('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power_Min: float = None
-			self.Tx_Power_Max: float = None
+			self.Off_Power_Before: float = None
+			self.On_Power_Rms: float = None
+			self.On_Power_Peak: float = None
+			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.seMask.extreme.read() \n
-		Return the extreme single value results of the spectrum emission measurement. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
+		Snippet: value: ResultData = driver.prach.pdynamics.maximum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
+		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.seMask.extreme.fetch() \n
-		Return the extreme single value results of the spectrum emission measurement. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
+		Snippet: value: ResultData = driver.prach.pdynamics.maximum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
+		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power_Min: float: Minimum total TX power in the slot Unit: dBm
-			- Tx_Power_Max: float: Maximum total TX power in the slot Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float or bool: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float or bool: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power_Min'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power_Min: float = None
-			self.Tx_Power_Max: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.extreme.calculate() \n
-		Return the extreme single value results of the spectrum emission measurement. The values described below are returned by
-		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
+		Snippet: value: CalculateStruct = driver.prach.pdynamics.maximum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
+		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class TpowerCls:
+	"""Tpower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
-
-	@property
-	def all(self):
-		"""all commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_all'):
-			from .Margin_.All import All
-			self._all = All(self._core, self._base)
-		return self._all
+		self._cmd_group = CommandsGroup("tpower", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 2 Sub-classes, 0 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 2 Sub-classes, 0 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 2 Sub-classes, 0 commands."""
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Margin_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'TpowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TpowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/All.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/All.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Curr_Neg: List[float]: No parameter help available
 			- Margin_Curr_Pos: List[float]: No parameter help available
 			- Margin_Avg_Neg: List[float]: No parameter help available
 			- Margin_Avg_Pos: List[float]: No parameter help available
 			- Margin_Min_Neg: List[float]: No parameter help available
 			- Margin_Min_Pos: List[float]: No parameter help available"""
 		__meta_args_list = [
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def negativ(self):
 		"""negativ commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Average_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
 	def positiv(self):
 		"""positiv commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Average_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/Negativ.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Avg_Neg_X: List[float]: No parameter help available
 			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Avg_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Neg_Y', DataType.FloatList, None, False, True, 1)]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/Positiv.py`

 * *Files 9% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Avg_Pos_X: List[float]: No parameter help available
 			- Margin_Avg_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Avg_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Pos_Y', DataType.FloatList, None, False, True, 1)]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class TriggerCls:
+	"""Trigger commands group definition. 23 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("trigger", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Current_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def multiEval(self):
+		"""multiEval commands group. 2 Sub-classes, 8 commands."""
+		if not hasattr(self, '_multiEval'):
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
+		return self._multiEval
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Current_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def prach(self):
+		"""prach commands group. 1 Sub-classes, 5 commands."""
+		if not hasattr(self, '_prach'):
+			from .Prach import PrachCls
+			self._prach = PrachCls(self._core, self._cmd_group)
+		return self._prach
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def srs(self):
+		"""srs commands group. 1 Sub-classes, 5 commands."""
+		if not hasattr(self, '_srs'):
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
+		return self._srs
+
+	def clone(self) -> 'TriggerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TriggerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/Negativ.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Curr_Neg_X: List[float]: No parameter help available
 			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/Positiv.py`

 * *Files 9% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Curr_Pos_X: List[float]: No parameter help available
 			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Minimum_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Minimum_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DmrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DmrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Negativ.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/Negativ.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Min_Neg_X: List[float]: No parameter help available
 			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Positiv.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/Positiv.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,26 +4,26 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
 			- Margin_Min_Pos_X: List[float]: No parameter help available
 			- Margin_Min_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/SeMask_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/SeMask/StandardDev.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
-			- Obw: float: Occupied bandwidth Unit: Hz
-			- Tx_Power: float: Total TX power in the slot over all component carriers Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits. Unit: %
+			- Obw: float: float Occupied bandwidth Unit: Hz
+			- Tx_Power: float: float Total TX power in the slot over all component carriers Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
@@ -31,21 +31,21 @@
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.seMask.standardDev.read() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
 		Snippet: value: ResultData = driver.multiEval.seMask.standardDev.fetch() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/State.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,39 +1,42 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ScorrelationCls:
+	"""Scorrelation commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("scorrelation", core, parent)
 
 	@property
-	def all(self):
-		"""all commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
-		return self._all
-
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:STATe \n
-		Snippet: value: enums.ResourceState = driver.multiEval.state.fetch() \n
-		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
-		INITiate..., STOP..., ABORt... to change the measurement state. \n
-			:return: meas_status: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available"""
-		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:MEValuation:STATe?')
-		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+	def preamble(self):
+		"""preamble commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_preamble'):
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
+		return self._preamble
+
+	def fetch(self) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation \n
+		Snippet: value: float = driver.prach.modulation.scorrelation.fetch() \n
+		Returns the sequence correlation for single-preamble measurements. It indicates the correlation between the ideal
+		preamble sequence determined from the parameter settings and the measured preamble sequence. A value of 1 corresponds to
+		perfect correlation. A value much smaller than 1 indicates that the preamble sequence was not found. \n
+		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: seq_correlation: float Sequence correlation"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation?', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScorrelationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScorrelationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/State_/All.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/State/All.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,40 +1,33 @@
+from typing import List
+
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Main_State: enums.ResourceState: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available
-			- Sync_State: enums.ResourceState: PEND | ADJ | INV PEND: waiting for resource allocation, adjustment, hardware switching ('pending') ADJ: adjustments finished, measurement running ('adjusted') INV: not applicable, MainState OFF or RDY ('invalid')
-			- Resource_State: enums.ResourceState: QUE | ACT | INV QUE: measurement without resources, no results available ('queued') ACT: resources allocated, acquisition of results in progress but not complete ('active') INV: not applicable, MainState OFF or RDY ('invalid')"""
-		__meta_args_list = [
-			ArgStruct.scalar_enum('Main_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Sync_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Resource_State', enums.ResourceState)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Main_State: enums.ResourceState = None
-			self.Sync_State: enums.ResourceState = None
-			self.Resource_State: enums.ResourceState = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:STATe:ALL \n
-		Snippet: value: FetchStruct = driver.multiEval.state.all.fetch() \n
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetMainState = None, target_sync_state: enums.TargetSyncState = None) -> List[enums.ResourceState]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:STATe:ALL \n
+		Snippet: value: List[enums.ResourceState] = driver.prach.state.all.fetch(timeout = 1.0, target_main_state = enums.TargetMainState.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
 		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
 		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
 		to change the measurement state. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:STATe:ALL?', self.__class__.FetchStruct())
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
+			:return: state: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetMainState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:PRACh:STATe:ALL? {param}'.rstrip())
+		return Conversions.str_to_list_enum(response, enums.ResourceState)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,99 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trace:
-	"""Trace commands group definition. 36 total commands, 10 Sub-groups, 0 group commands"""
+class PpowerCls:
+	"""Ppower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trace", core, parent)
+		self._cmd_group = CommandsGroup("ppower", core, parent)
 
 	@property
-	def rbaTable(self):
-		"""rbaTable commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rbaTable'):
-			from .Trace_.RbaTable import RbaTable
-			self._rbaTable = RbaTable(self._core, self._base)
-		return self._rbaTable
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
 
-	@property
-	def iq(self):
-		"""iq commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_iq'):
-			from .Trace_.Iq import Iq
-			self._iq = Iq(self._core, self._base)
-		return self._iq
-
-	@property
-	def iemissions(self):
-		"""iemissions commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_iemissions'):
-			from .Trace_.Iemissions import Iemissions
-			self._iemissions = Iemissions(self._core, self._base)
-		return self._iemissions
-
-	@property
-	def evmc(self):
-		"""evmc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_evmc'):
-			from .Trace_.Evmc import Evmc
-			self._evmc = Evmc(self._core, self._base)
-		return self._evmc
-
-	@property
-	def evmSymbol(self):
-		"""evmSymbol commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_evmSymbol'):
-			from .Trace_.EvmSymbol import EvmSymbol
-			self._evmSymbol = EvmSymbol(self._core, self._base)
-		return self._evmSymbol
-
-	@property
-	def esFlatness(self):
-		"""esFlatness commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_esFlatness'):
-			from .Trace_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
-		return self._esFlatness
-
-	@property
-	def seMask(self):
-		"""seMask commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_seMask'):
-			from .Trace_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
-
-	@property
-	def aclr(self):
-		"""aclr commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_aclr'):
-			from .Trace_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
-		return self._aclr
-
-	@property
-	def pmonitor(self):
-		"""pmonitor commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pmonitor'):
-			from .Trace_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
-		return self._pmonitor
-
-	@property
-	def pdynamics(self):
-		"""pdynamics commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pdynamics'):
-			from .Trace_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
-		return self._pdynamics
-
-	def clone(self) -> 'Trace':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PpowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trace(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PpowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Aclr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Aclr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Utra_2_Neg: float: Power in the second UTRA channel with lower frequency Unit: dBm
-			- Utra_1_Neg: float: Power in the first UTRA channel with lower frequency Unit: dBm
-			- Eutra_Negativ: float: Power in the first E-UTRA channel with lower frequency Unit: dBm
-			- Eutra: float: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: float: Power in the first E-UTRA channel with higher frequency Unit: dBm
-			- Utra_1_Pos: float: Power in the first UTRA channel with higher frequency Unit: dBm
-			- Utra_2_Pos: float: Power in the second UTRA channel with higher frequency Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Utra_2_Neg: float: float Power in the second UTRA channel with lower frequency Unit: dBm
+			- Utra_1_Neg: float: float Power in the first UTRA channel with lower frequency Unit: dBm
+			- Eutra_Negativ: float: float Power in the first E-UTRA channel with lower frequency Unit: dBm
+			- Eutra: float: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: float: float Power in the first E-UTRA channel with higher frequency Unit: dBm
+			- Utra_1_Pos: float: float Power in the first UTRA channel with higher frequency Unit: dBm
+			- Utra_2_Pos: float: float Power in the second UTRA channel with higher frequency Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Utra_2_Neg'),
 			ArgStruct.scalar_float('Utra_1_Neg'),
 			ArgStruct.scalar_float('Eutra_Negativ'),
 			ArgStruct.scalar_float('Eutra'),
 			ArgStruct.scalar_float('Eutra_Positiv'),
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/Current.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Utra_2_Neg: float: Power in the second UTRA channel with lower frequency Unit: dBm
-			- Utra_1_Neg: float: Power in the first UTRA channel with lower frequency Unit: dBm
-			- Eutra_Negativ: float: Power in the first E-UTRA channel with lower frequency Unit: dBm
-			- Eutra: float: Power in the allocated E-UTRA channel Unit: dBm
-			- Eutra_Positiv: float: Power in the first E-UTRA channel with higher frequency Unit: dBm
-			- Utra_1_Pos: float: Power in the first UTRA channel with higher frequency Unit: dBm
-			- Utra_2_Pos: float: Power in the second UTRA channel with higher frequency Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Utra_2_Neg: float: float Power in the second UTRA channel with lower frequency Unit: dBm
+			- Utra_1_Neg: float: float Power in the first UTRA channel with lower frequency Unit: dBm
+			- Eutra_Negativ: float: float Power in the first E-UTRA channel with lower frequency Unit: dBm
+			- Eutra: float: float Power in the allocated E-UTRA channel Unit: dBm
+			- Eutra_Positiv: float: float Power in the first E-UTRA channel with higher frequency Unit: dBm
+			- Utra_1_Pos: float: float Power in the first UTRA channel with higher frequency Unit: dBm
+			- Utra_2_Pos: float: float Power in the second UTRA channel with higher frequency Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Utra_2_Neg'),
 			ArgStruct.scalar_float('Utra_1_Neg'),
 			ArgStruct.scalar_float('Eutra_Negativ'),
 			ArgStruct.scalar_float('Eutra'),
 			ArgStruct.scalar_float('Eutra_Positiv'),
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 4 total commands, 1 Sub-groups, 2 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 4 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
 	def phase(self):
 		"""phase commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_phase'):
-			from .EsFlatness_.Phase import Phase
-			self._phase = Phase(self._core, self._base)
+			from .Phase import PhaseCls
+			self._phase = PhaseCls(self._core, self._cmd_group)
 		return self._phase
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness \n
 		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.read() \n
 		Returns the values of the equalizer spectrum flatness trace. See also 'View Equalizer Spectrum Flatness'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Comma-separated list of power values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: dB"""
+			:return: power: float Comma-separated list of power values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness \n
 		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.fetch() \n
 		Returns the values of the equalizer spectrum flatness trace. See also 'View Equalizer Spectrum Flatness'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Comma-separated list of power values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: dB"""
+			:return: power: float Comma-separated list of power values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: dB"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness?', suppressed)
 		return response
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/Phase.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/Phase.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Phase:
-	"""Phase commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PhaseCls:
+	"""Phase commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("phase", core, parent)
+		self._cmd_group = CommandsGroup("phase", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe \n
 		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.phase.read() \n
 		Returns the phase values of the equalizer spectrum flatness trace. The GUI shows only the magnitude values. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase: Comma-separated list of phase values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: deg"""
+			:return: phase: float Comma-separated list of phase values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe \n
 		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.phase.fetch() \n
 		Returns the phase values of the equalizer spectrum flatness trace. The GUI shows only the magnitude values. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase: Comma-separated list of phase values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: deg"""
+			:return: phase: float Comma-separated list of phase values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvmSymbol:
-	"""EvmSymbol commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evmSymbol", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .EvmSymbol_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .EvmSymbol_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .EvmSymbol_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'EvmSymbol':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EvmSymbol(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/Maximum.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,33 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.average.read() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'View Error Vector Magnitude'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
+		Snippet: value: List[float] = driver.prach.trace.merror.maximum.read() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.average.fetch() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'View Error Vector Magnitude'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
+		Snippet: value: List[float] = driver.prach.trace.merror.maximum.fetch() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/Current.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,33 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.current.read() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'View Error Vector Magnitude'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.merror.current.read() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.current.fetch() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'View Error Vector Magnitude'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.merror.current.fetch() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/Current.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,33 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.maximum.read() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'View Error Vector Magnitude'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.evm.current.read() \n
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
+		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.maximum.fetch() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'View Error Vector Magnitude'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.evm.current.fetch() \n
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
+		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Evmc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Evmc.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evmc:
-	"""Evmc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EvmcCls:
+	"""Evmc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evmc", core, parent)
+		self._cmd_group = CommandsGroup("evmc", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC \n
 		Snippet: value: List[float] = driver.multiEval.trace.evmc.read() \n
 		Returns the values of the EVM vs subcarrier trace. See also 'View EVM vs Subcarrier'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: %"""
+			:return: ratio: float Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC \n
 		Snippet: value: List[float] = driver.multiEval.trace.evmc.fetch() \n
 		Returns the values of the EVM vs subcarrier trace. See also 'View EVM vs Subcarrier'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: ratio: Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: %"""
+			:return: ratio: float Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned. Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Iemissions:
-	"""Iemissions commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iemissions", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
-	def cc(self):
-		"""cc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_cc'):
-			from .Iemissions_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
+	def enable(self):
+		"""enable commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_enable'):
+			from .Enable import EnableCls
+			self._enable = EnableCls(self._core, self._cmd_group)
+		return self._enable
 
-	def clone(self) -> 'Iemissions':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Iemissions(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/Cc.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,58 +5,58 @@
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class CcCls:
+	"""Cc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC<Nr> \n
 		Snippet: value: List[float] = driver.multiEval.trace.iemissions.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the values of the inband emissions trace for carrier CC<no>. See also 'View Inband Emissions'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: power: Comma-separated list of power values, one value per resource block Unit: dB"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+			:return: power: float Comma-separated list of power values, one value per resource block Unit: dB"""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC<Nr> \n
 		Snippet: value: List[float] = driver.multiEval.trace.iemissions.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the values of the inband emissions trace for carrier CC<no>. See also 'View Inband Emissions'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: power: Comma-separated list of power values, one value per resource block Unit: dB"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+			:return: power: float Comma-separated list of power values, one value per resource block Unit: dB"""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Iq:
-	"""Iq commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iq", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_low'):
-			from .Iq_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def high(self):
-		"""high commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_high'):
-			from .Iq_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'Iq':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Iq(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/High.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/High.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class HighCls:
+	"""High commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Iphase: List[float]: Normalized I amplitude
-			- Qphase: List[float]: Normalized Q amplitude"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Iphase: List[float]: float Normalized I amplitude
+			- Qphase: List[float]: float Normalized Q amplitude"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/Low.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/Low.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,27 +4,27 @@
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.Types import DataType
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LowCls:
+	"""Low commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Iphase: List[float]: Normalized I amplitude
-			- Qphase: List[float]: Normalized Q amplitude"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Iphase: List[float]: float Normalized I amplitude
+			- Qphase: List[float]: float Normalized Q amplitude"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.average.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram at the display shows only a subsection of this trace. Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram in the GUI shows only a subsection of this trace. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.average.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram at the display shows only a subsection of this trace. Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram in the GUI shows only a subsection of this trace. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.current.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram at the display shows only a subsection of this trace. Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram in the GUI shows only a subsection of this trace. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.current.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram at the display shows only a subsection of this trace. Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram in the GUI shows only a subsection of this trace. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Maximum.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.maximum.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram at the display shows only a subsection of this trace. Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram in the GUI shows only a subsection of this trace. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.maximum.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram at the display shows only a subsection of this trace. Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the measure subframe. The values have a spacing of 1.5625 µs. The 705th value is at the start of the 'Measure Subframe' (0 µs) . The diagram in the GUI shows only a subsection of this trace. Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	@property
-	def cc(self):
-		"""cc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_cc'):
-			from .Pmonitor_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	def clone(self) -> 'PositivCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PositivCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/Cc.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,58 +5,58 @@
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class CcCls:
+	"""Cc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC<Nr> \n
 		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the power monitor results for all captured CC<no> subframes. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: power: Comma-separated list of power values, one value per subframe Unit: dBm"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+			:return: power: float Comma-separated list of power values, one value per subframe Unit: dBm"""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC<Nr> \n
 		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the power monitor results for all captured CC<no> subframes. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: power: Comma-separated list of power values, one value per subframe Unit: dBm"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+			:return: power: float Comma-separated list of power values, one value per subframe Unit: dBm"""
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Cc.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/Cc.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,41 +7,41 @@
 from .....Internal.ArgStruct import ArgStruct
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import enums
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class CcCls:
+	"""Cc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Channel_Type: List[enums.RbTableChannelType]: PUSCh | PUCCh | NONE | DL | SSUB | PSSCh | PSCCh PUSCh / PUCCH: for UL slot with RB allocation PSSCh / PSCCh: for SL subframe with RB allocation NONE: UL slot or SL subframe contains no allocated RBs DL: DL slot (only for TDD UL measurements) SSUB: part of special SF (only for TDD UL measurements)
-			- Offset_Rb: List[int]: Offset of first allocated RB for the given channel type
-			- No_Rb: List[int]: Number of allocated RBs for the given channel type"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Channel_Type: List[enums.RbTableChannelType]: PUSCh | PUCCh | NONE | DL | SSUB | PSSCh | PSCCh PUSCh / PUCCH: for UL slot with RB allocation PSSCh / PSCCh: for SL subframe with RB allocation NONE: UL slot or SL subframe contains no allocated RBs. DL: DL slot (only for TDD UL measurements) SSUB: part of special SF (only for TDD UL measurements)
+			- Offset_Rb: List[int]: decimal Offset of first allocated RB for the given channel type
+			- No_Rb: List[int]: decimal Number of allocated RBs for the given channel type"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Channel_Type', DataType.EnumList, enums.RbTableChannelType, False, True, 1),
 			ArgStruct('Offset_Rb', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('No_Rb', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
@@ -54,33 +54,33 @@
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC<Nr> \n
 		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the information of the CC<no> RB allocation table. See also 'View RB Allocation Table'. For uplink measurements,
 		there are three results per captured slot (n = number of captured subframes) : <Reliability>, {<ChannelType>, <OffsetRB>,
 		<NoRB>}slot 1, ..., {...}slot (n*2) For sidelink measurements, there are six results per captured subframe (SF) , three
 		for the PSCCH and three for the PSSCH: <Reliability>, {...}SF 1 (PSCCH) , {...}SF 1 (PSSCH) , ..., {...}SF n (PSCCH) , {..
-		.}SF n ( PSSCH) \n
+		.}SF n (PSSCH) \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC{carrierComponent_cmd_val}?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC<Nr> \n
 		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the information of the CC<no> RB allocation table. See also 'View RB Allocation Table'. For uplink measurements,
 		there are three results per captured slot (n = number of captured subframes) : <Reliability>, {<ChannelType>, <OffsetRB>,
 		<NoRB>}slot 1, ..., {...}slot (n*2) For sidelink measurements, there are six results per captured subframe (SF) , three
 		for the PSCCH and three for the PSSCH: <Reliability>, {...}SF 1 (PSCCH) , {...}SF 1 (PSSCH) , ..., {...}SF n (PSCCH) , {..
-		.}SF n ( PSSCH) \n
+		.}SF n (PSSCH) \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC{carrierComponent_cmd_val}?', self.__class__.ResultData())
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	@property
-	def rbw(self):
-		"""rbw commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rbw'):
-			from .SeMask_.Rbw import Rbw
-			self._rbw = Rbw(self._core, self._base)
-		return self._rbw
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
+
+	def clone(self) -> 'RmsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RmsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Amarker/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,58 +1,74 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.RepeatedCapability import RepeatedCapability
+from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rbw:
-	"""Rbw commands group definition. 6 total commands, 3 Sub-groups, 0 group commands
-	Repeated Capability: RBWkHz, default value after init: RBWkHz.Rbw30"""
+class AmarkerCls:
+	"""Amarker commands group definition. 6 total commands, 5 Subgroups, 0 group commands
+	Repeated Capability: AbsMarker, default value after init: AbsMarker.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_rBWkHz_get', 'repcap_rBWkHz_set', repcap.RBWkHz.Rbw30)
+		self._cmd_group = CommandsGroup("amarker", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_absMarker_get', 'repcap_absMarker_set', repcap.AbsMarker.Nr1)
 
-	def repcap_rBWkHz_set(self, enum_value: repcap.RBWkHz) -> None:
+	def repcap_absMarker_set(self, absMarker: repcap.AbsMarker) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBWkHz.Default
-		Default value after init: RBWkHz.Rbw30"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to AbsMarker.Default
+		Default value after init: AbsMarker.Nr1"""
+		self._cmd_group.set_repcap_enum_value(absMarker)
 
-	def repcap_rBWkHz_get(self) -> repcap.RBWkHz:
+	def repcap_absMarker_get(self) -> repcap.AbsMarker:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Rbw_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def pdynamics(self):
+		"""pdynamics commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Rbw_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def pmonitor(self):
+		"""pmonitor commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pmonitor'):
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
+		return self._pmonitor
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Rbw_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def evMagnitude(self):
+		"""evMagnitude commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_evMagnitude'):
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
+		return self._evMagnitude
 
-	def clone(self) -> 'Rbw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def merror(self):
+		"""merror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_merror'):
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
+		return self._merror
+
+	@property
+	def perror(self):
+		"""perror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_perror'):
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
+		return self._perror
+
+	def clone(self) -> 'AmarkerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rbw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AmarkerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,41 +4,41 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.average.read(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'View Spectrum
 		Emission Mask'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: float Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:AVERage?', suppressed)
 		return response
 
 	def fetch(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:AVERage \n
 		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.average.fetch(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'View Spectrum
 		Emission Mask'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: float Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,41 +4,41 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.current.read(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'View Spectrum
 		Emission Mask'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: float Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:CURRent?', suppressed)
 		return response
 
 	def fetch(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:CURRent \n
 		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.current.fetch(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'View Spectrum
 		Emission Mask'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: float Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Maximum.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,41 +4,41 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.maximum.read(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'View Spectrum
 		Emission Mask'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: float Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:MAXimum?', suppressed)
 		return response
 
 	def fetch(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:MAXimum \n
 		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.maximum.fetch(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'View Spectrum
 		Emission Mask'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: float Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned. Unit: dBm"""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/MultiEval_/VfThroughput.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/VfThroughput.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,23 +2,23 @@
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class VfThroughput:
-	"""VfThroughput commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class VfThroughputCls:
+	"""VfThroughput commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("vfThroughput", core, parent)
+		self._cmd_group = CommandsGroup("vfThroughput", core, parent)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:VFTHroughput \n
 		Snippet: value: float = driver.multiEval.vfThroughput.fetch() \n
-		Queries the 'View Filter Throughput', see 'View Filter Throughput'. \n
+		Queries the 'View Filter Throughput'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: vf_throughput: Unit: %"""
+			:return: vf_throughput: float Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:VFTHroughput?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,120 +1,88 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Prach:
-	"""Prach commands group definition. 67 total commands, 4 Sub-groups, 3 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 25 total commands, 3 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("prach", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Prach_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def trace(self):
-		"""trace commands group. 7 Sub-classes, 0 commands."""
+		"""trace commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .Prach_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
-	def modulation(self):
-		"""modulation commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_modulation'):
-			from .Prach_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
-		return self._modulation
-
-	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .Prach_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
-	def initiate(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:LTE:MEASurement<Instance>:PRACh')
-
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.initiate_with_opc() \n
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.srs.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:PRACh')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:SRS', opc_timeout_ms)
 
 	def stop(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.stop() \n
+		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.srs.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
-		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:PRACh')
+		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:SRS')
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.stop_with_opc() \n
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.srs.stop_with_opc() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:PRACh')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:SRS', opc_timeout_ms)
 
-	def abort(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.abort() \n
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.srs.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:LTE:MEASurement<Instance>:PRACh')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:PRACh')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:SRS', opc_timeout_ms)
 
-	def clone(self) -> 'Prach':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Prach(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Average.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,42 +1,42 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position. Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position. Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position. Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position. Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position. Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position. Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position. Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position. Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position. Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position. Unit: deg
+			- Frequency_Error: float: float Carrier frequency error. Unit: Hz
+			- Timing_Error: float: float Transmit time error. Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power. Unit: dBm
+			- Peak_Power: float: float User equipment peak power. Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -73,89 +73,89 @@
 			self.Timing_Error: float = None
 			self.Tx_Power: float = None
 			self.Peak_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
 		Snippet: value: ResultData = driver.prach.modulation.average.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
 		Snippet: value: ResultData = driver.prach.modulation.average.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position. Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position. Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position. Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position. Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position. Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position. Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position. Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position. Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position. Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position. Unit: deg
+			- Frequency_Error: float or bool: float Carrier frequency error. Unit: Hz
+			- Timing_Error: float or bool: float Transmit time error. Unit: Ts (basic LTE time unit)
+			- Tx_Power: float or bool: float User equipment power. Unit: dBm
+			- Peak_Power: float or bool: float User equipment peak power. Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
 		Snippet: value: CalculateStruct = driver.prach.modulation.average.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Extreme.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,42 +1,44 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position Unit: deg
+			- Frequency_Error: float: float Carrier frequency error Unit: Hz
+			- Timing_Error: float: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power_Minimum: float: float Minimum user equipment power Unit: dBm
+			- Tx_Power_Maximum: float: float Maximum user equipment power Unit: dBm
+			- Peak_Power_Min: float: float Minimum user equipment peak power Unit: dBm
+			- Peak_Power_Max: float: float Maximum user equipment peak power Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -46,16 +48,18 @@
 			ArgStruct.scalar_float('Mag_Err_Peak_High'),
 			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
 			ArgStruct.scalar_float('Ph_Error_Rms_High'),
 			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
 			ArgStruct.scalar_float('Ph_Error_Peak_High'),
 			ArgStruct.scalar_float('Frequency_Error'),
 			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float('Tx_Power_Minimum'),
+			ArgStruct.scalar_float('Tx_Power_Maximum'),
+			ArgStruct.scalar_float('Peak_Power_Min'),
+			ArgStruct.scalar_float('Peak_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Evm_Rms_Low: float = None
 			self.Evm_Rms_High: float = None
@@ -67,95 +71,103 @@
 			self.Mag_Err_Peak_High: float = None
 			self.Ph_Error_Rms_Low: float = None
 			self.Ph_Error_Rms_High: float = None
 			self.Ph_Error_Peak_Low: float = None
 			self.Ph_Error_Peak_High: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
+			self.Tx_Power_Minimum: float = None
+			self.Tx_Power_Maximum: float = None
+			self.Peak_Power_Min: float = None
+			self.Peak_Power_Max: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.prach.modulation.current.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
+		Snippet: value: ResultData = driver.prach.modulation.extreme.read() \n
+		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.prach.modulation.current.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
+		Snippet: value: ResultData = driver.prach.modulation.extreme.fetch() \n
+		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position Unit: deg
+			- Frequency_Error: float or bool: float Carrier frequency error Unit: Hz
+			- Timing_Error: float or bool: float Time error Unit: Ts (basic LTE time unit)
+			- Tx_Power_Minimum: float or bool: float Minimum user equipment power Unit: dBm
+			- Tx_Power_Maximum: float or bool: float Maximum user equipment power Unit: dBm
+			- Peak_Power_Min: float or bool: float Minimum user equipment peak power Unit: dBm
+			- Peak_Power_Max: float or bool: float Maximum user equipment peak power Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power_Minimum'),
+			ArgStruct.scalar_float_ext('Tx_Power_Maximum'),
+			ArgStruct.scalar_float_ext('Peak_Power_Min'),
+			ArgStruct.scalar_float_ext('Peak_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power_Minimum: float or bool = None
+			self.Tx_Power_Maximum: float or bool = None
+			self.Peak_Power_Min: float or bool = None
+			self.Peak_Power_Max: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
-		Snippet: value: CalculateStruct = driver.prach.modulation.current.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
+		Snippet: value: CalculateStruct = driver.prach.modulation.extreme.calculate() \n
+		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DpfOffset:
-	"""DpfOffset commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class DpfOffsetCls:
+	"""DpfOffset commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dpfOffset", core, parent)
+		self._cmd_group = CommandsGroup("dpfOffset", core, parent)
 
 	@property
 	def preamble(self):
 		"""preamble commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_preamble'):
-			from .DpfOffset_.Preamble import Preamble
-			self._preamble = Preamble(self._core, self._base)
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
 		return self._preamble
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset \n
 		Snippet: value: int = driver.prach.modulation.dpfOffset.fetch() \n
 		Returns the automatically detected or manually configured PRACH frequency offset for single-preamble measurements. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: prach_freq_offset: PRACH frequency offset"""
+			:return: prach_freq_offset: decimal PRACH frequency offset"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset?', suppressed)
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'DpfOffset':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DpfOffsetCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DpfOffset(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DpfOffsetCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset_/Preamble.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/Preamble.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,47 +4,48 @@
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Preamble:
-	"""Preamble commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class PreambleCls:
+	"""Preamble commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: Preamble, default value after init: Preamble.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("preamble", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
+		self._cmd_group = CommandsGroup("preamble", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
 
-	def repcap_preamble_set(self, enum_value: repcap.Preamble) -> None:
+	def repcap_preamble_set(self, preamble: repcap.Preamble) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Preamble.Default
 		Default value after init: Preamble.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preamble)
 
 	def repcap_preamble_get(self) -> repcap.Preamble:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	def fetch(self, preamble=repcap.Preamble.Default) -> int:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble<Number> \n
-		Snippet: value: int = driver.prach.modulation.dpfOffset.preamble.fetch(preamble = repcap.Preamble.Default) \n
-		Returns the automatically detected or manually configured PRACH frequency offset for a selected preamble of
-		multi-preamble measurements. \n
+	def fetch(self, preamble=repcap.Preamble.Default) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation:PREamble<Number> \n
+		Snippet: value: float = driver.prach.modulation.scorrelation.preamble.fetch(preamble = repcap.Preamble.Default) \n
+		Returns the sequence correlation for a selected preamble of multi-preamble measurements. It indicates the correlation
+		between the ideal preamble sequence determined from the parameter settings and the measured preamble sequence. A value of
+		1 corresponds to perfect correlation. A value much smaller than 1 indicates that the preamble sequence was not found. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
-			:return: prach_freq_offset: PRACH frequency offset"""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+			:return: seq_correlation: float Sequence correlation"""
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble{preamble_cmd_val}?', suppressed)
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation:PREamble{preamble_cmd_val}?', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'Preamble':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PreambleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Preamble(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PreambleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DsIndex/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DsIndex:
-	"""DsIndex commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class DsIndexCls:
+	"""DsIndex commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dsIndex", core, parent)
+		self._cmd_group = CommandsGroup("dsIndex", core, parent)
 
 	@property
 	def preamble(self):
 		"""preamble commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_preamble'):
-			from .DsIndex_.Preamble import Preamble
-			self._preamble = Preamble(self._core, self._base)
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
 		return self._preamble
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex \n
 		Snippet: value: int = driver.prach.modulation.dsIndex.fetch() \n
 		Returns the automatically detected or manually configured sequence index for single-preamble measurements. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: sequence_index: Sequence index"""
+			:return: sequence_index: decimal Sequence index"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex?', suppressed)
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'DsIndex':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DsIndexCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DsIndex(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DsIndexCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex_/Preamble.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/Preamble.py`

 * *Files 21% similar despite different names*

```diff
@@ -4,47 +4,47 @@
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Preamble:
-	"""Preamble commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class PreambleCls:
+	"""Preamble commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: Preamble, default value after init: Preamble.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("preamble", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
+		self._cmd_group = CommandsGroup("preamble", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
 
-	def repcap_preamble_set(self, enum_value: repcap.Preamble) -> None:
+	def repcap_preamble_set(self, preamble: repcap.Preamble) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Preamble.Default
 		Default value after init: Preamble.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preamble)
 
 	def repcap_preamble_get(self) -> repcap.Preamble:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def fetch(self, preamble=repcap.Preamble.Default) -> int:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex:PREamble<Number> \n
-		Snippet: value: int = driver.prach.modulation.dsIndex.preamble.fetch(preamble = repcap.Preamble.Default) \n
-		Returns the automatically detected or manually configured sequence index for a selected preamble of multi-preamble
-		measurements. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble<Number> \n
+		Snippet: value: int = driver.prach.modulation.dpfOffset.preamble.fetch(preamble = repcap.Preamble.Default) \n
+		Returns the automatically detected or manually configured PRACH frequency offset for a selected preamble of
+		multi-preamble measurements. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
-			:return: sequence_index: Sequence index"""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+			:return: prach_freq_offset: decimal PRACH frequency offset"""
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex:PREamble{preamble_cmd_val}?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble{preamble_cmd_val}?', suppressed)
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Preamble':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PreambleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Preamble(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PreambleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Extreme.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Current.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,44 +1,42 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power_Minimum: float: Minimum user equipment power Unit: dBm
-			- Tx_Power_Maximum: float: Maximum user equipment power Unit: dBm
-			- Peak_Power_Min: float: Minimum user equipment peak power Unit: dBm
-			- Peak_Power_Max: float: Maximum user equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position. Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position. Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position. Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position. Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position. Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position. Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position. Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position. Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position. Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position. Unit: deg
+			- Frequency_Error: float: float Carrier frequency error. Unit: Hz
+			- Timing_Error: float: float Transmit time error. Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power. Unit: dBm
+			- Peak_Power: float: float User equipment peak power. Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -48,18 +46,16 @@
 			ArgStruct.scalar_float('Mag_Err_Peak_High'),
 			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
 			ArgStruct.scalar_float('Ph_Error_Rms_High'),
 			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
 			ArgStruct.scalar_float('Ph_Error_Peak_High'),
 			ArgStruct.scalar_float('Frequency_Error'),
 			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max')]
+			ArgStruct.scalar_float('Tx_Power'),
+			ArgStruct.scalar_float('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Evm_Rms_Low: float = None
 			self.Evm_Rms_High: float = None
@@ -71,103 +67,95 @@
 			self.Mag_Err_Peak_High: float = None
 			self.Ph_Error_Rms_Low: float = None
 			self.Ph_Error_Rms_High: float = None
 			self.Ph_Error_Peak_Low: float = None
 			self.Ph_Error_Peak_High: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
+			self.Tx_Power: float = None
+			self.Peak_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
-		Snippet: value: ResultData = driver.prach.modulation.extreme.read() \n
-		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
+		Snippet: value: ResultData = driver.prach.modulation.current.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
-		Snippet: value: ResultData = driver.prach.modulation.extreme.fetch() \n
-		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
+		Snippet: value: ResultData = driver.prach.modulation.current.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power_Minimum: float: Minimum user equipment power Unit: dBm
-			- Tx_Power_Maximum: float: Maximum user equipment power Unit: dBm
-			- Peak_Power_Min: float: Minimum user equipment peak power Unit: dBm
-			- Peak_Power_Max: float: Maximum user equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits. Unit: %
+			- Evm_Rms_Low: float or bool: float EVM RMS value, low EVM window position. Unit: %
+			- Evm_Rms_High: float or bool: float EVM RMS value, high EVM window position. Unit: %
+			- Evm_Peak_Low: float or bool: float EVM peak value, low EVM window position. Unit: %
+			- Evm_Peak_High: float or bool: float EVM peak value, high EVM window position. Unit: %
+			- Mag_Error_Rms_Low: float or bool: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Rms_High: float or bool: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Peak_Low: float or bool: float Magnitude error peak value, low EVM window position. Unit: %
+			- Mag_Err_Peak_High: float or bool: float Magnitude error peak value, high EVM window position. Unit: %
+			- Ph_Error_Rms_Low: float or bool: float Phase error RMS value, low EVM window position. Unit: deg
+			- Ph_Error_Rms_High: float or bool: float Phase error RMS value, high EVM window position. Unit: deg
+			- Ph_Error_Peak_Low: float or bool: float Phase error peak value, low EVM window position. Unit: deg
+			- Ph_Error_Peak_High: float or bool: float Phase error peak value, high EVM window position. Unit: deg
+			- Frequency_Error: float or bool: float Carrier frequency error. Unit: Hz
+			- Timing_Error: float or bool: float Transmit time error. Unit: Ts (basic LTE time unit)
+			- Tx_Power: float or bool: float User equipment power. Unit: dBm
+			- Peak_Power: float or bool: float User equipment peak power. Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
-		Snippet: value: CalculateStruct = driver.prach.modulation.extreme.calculate() \n
-		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
+		Snippet: value: CalculateStruct = driver.prach.modulation.current.calculate() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Modulation_/Preamble.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Preamble.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,55 +3,55 @@
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 from ....Internal.RepeatedCapability import RepeatedCapability
 from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Preamble:
-	"""Preamble commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class PreambleCls:
+	"""Preamble commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: Preamble, default value after init: Preamble.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("preamble", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
+		self._cmd_group = CommandsGroup("preamble", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
 
-	def repcap_preamble_set(self, enum_value: repcap.Preamble) -> None:
+	def repcap_preamble_set(self, preamble: repcap.Preamble) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Preamble.Default
 		Default value after init: Preamble.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preamble)
 
 	def repcap_preamble_get(self) -> repcap.Preamble:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Preamble_Rel: int: Reliability indicator for the preamble
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position Unit: %
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position Unit: %
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position Unit: %
-			- Evm_Peak_High: float: EVM peak value, high EVM window position Unit: %
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position Unit: %
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position Unit: %
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position Unit: %
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position Unit: deg
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position Unit: deg
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position Unit: deg
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position Unit: deg
-			- Frequency_Error: float: Carrier frequency error Unit: Hz
-			- Timing_Error: float: Transmit time error Unit: Ts (basic LTE time unit)
-			- Tx_Power: float: User equipment power Unit: dBm
-			- Peak_Power: float: User equipment peak power Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Preamble_Rel: int: decimal Reliability indicator for the preamble.
+			- Evm_Rms_Low: float: float EVM RMS value, low EVM window position. Unit: %
+			- Evm_Rms_High: float: float EVM RMS value, high EVM window position. Unit: %
+			- Evm_Peak_Low: float: float EVM peak value, low EVM window position. Unit: %
+			- Evm_Peak_High: float: float EVM peak value, high EVM window position. Unit: %
+			- Mag_Error_Rms_Low: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Rms_High: float: float Magnitude error RMS value, low EVM window position. Unit: %
+			- Mag_Error_Peak_Low: float: float Magnitude error peak value, low EVM window position. Unit: %
+			- Mag_Err_Peak_High: float: float Magnitude error peak value, high EVM window position. Unit: %
+			- Ph_Error_Rms_Low: float: float Phase error RMS value, low EVM window position. Unit: deg
+			- Ph_Error_Rms_High: float: float Phase error RMS value, high EVM window position. Unit: deg
+			- Ph_Error_Peak_Low: float: float Phase error peak value, low EVM window position. Unit: deg
+			- Ph_Error_Peak_High: float: float Phase error peak value, high EVM window position. Unit: deg
+			- Frequency_Error: float: float Carrier frequency error. Unit: Hz
+			- Timing_Error: float: float Transmit time error. Unit: Ts (basic LTE time unit)
+			- Tx_Power: float: float User equipment power. Unit: dBm
+			- Peak_Power: float: float User equipment peak power. Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Preamble_Rel'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -89,30 +89,30 @@
 			self.Tx_Power: float = None
 			self.Peak_Power: float = None
 
 	def read(self, preamble=repcap.Preamble.Default) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble<Number> \n
 		Snippet: value: ResultData = driver.prach.modulation.preamble.read(preamble = repcap.Preamble.Default) \n
 		Return the single value results of the 'EVM vs Preamble' and 'Power vs Preamble' views, for a selected preamble. See also
-		'Views EVM vs Preamble, Power vs Preamble'. \n
+		'View EVM vs Preamble, Power vs Preamble'. \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble{preamble_cmd_val}?', self.__class__.ResultData())
 
 	def fetch(self, preamble=repcap.Preamble.Default) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble<Number> \n
 		Snippet: value: ResultData = driver.prach.modulation.preamble.fetch(preamble = repcap.Preamble.Default) \n
 		Return the single value results of the 'EVM vs Preamble' and 'Power vs Preamble' views, for a selected preamble. See also
-		'Views EVM vs Preamble, Power vs Preamble'. \n
+		'View EVM vs Preamble, Power vs Preamble'. \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble{preamble_cmd_val}?', self.__class__.ResultData())
 
-	def clone(self) -> 'Preamble':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PreambleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Preamble(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PreambleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 14 total commands, 5 Sub-groups, 0 group commands"""
+class EvmSymbolCls:
+	"""EvmSymbol commands group definition. 12 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("evmSymbol", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pdynamics_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def peak(self):
+		"""peak commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Pdynamics_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvmSymbolCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmSymbolCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -37,56 +37,56 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
 		Snippet: value: ResultData = driver.prach.pdynamics.average.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
 		Snippet: value: ResultData = driver.prach.pdynamics.average.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float or bool: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float or bool: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
 		Snippet: value: CalculateStruct = driver.prach.pdynamics.average.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -37,56 +37,56 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
 		Snippet: value: ResultData = driver.prach.pdynamics.current.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
 		Snippet: value: ResultData = driver.prach.pdynamics.current.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float or bool: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float or bool: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
 		Snippet: value: CalculateStruct = driver.prach.pdynamics.current.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,92 +1,104 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
+			ArgStruct.scalar_float('On_Power_Rms_1'),
+			ArgStruct.scalar_float('On_Power_Peak_1'),
+			ArgStruct.scalar_float('On_Power_Rms_2'),
+			ArgStruct.scalar_float('On_Power_Peak_2'),
 			ArgStruct.scalar_float('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
+			self.On_Power_Rms_1: float = None
+			self.On_Power_Peak_1: float = None
+			self.On_Power_Rms_2: float = None
+			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.maximum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
+		Snippet: value: ResultData = driver.srs.pdynamics.maximum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.maximum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
+		Snippet: value: ResultData = driver.srs.pdynamics.maximum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float or bool: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float or bool: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float or bool: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float or bool: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.maximum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
+		Snippet: value: CalculateStruct = driver.srs.pdynamics.maximum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Minimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,92 +1,104 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
+			ArgStruct.scalar_float('On_Power_Rms_1'),
+			ArgStruct.scalar_float('On_Power_Peak_1'),
+			ArgStruct.scalar_float('On_Power_Rms_2'),
+			ArgStruct.scalar_float('On_Power_Peak_2'),
 			ArgStruct.scalar_float('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
+			self.On_Power_Rms_1: float = None
+			self.On_Power_Peak_1: float = None
+			self.On_Power_Rms_2: float = None
+			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.minimum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.srs.pdynamics.minimum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.minimum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.srs.pdynamics.minimum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float or bool: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float or bool: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float or bool: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float or bool: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.minimum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
+		Snippet: value: CalculateStruct = driver.srs.pdynamics.minimum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Pdynamics_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period Unit: dBm
-			- On_Power_Rms: float: ON power mean value over preamble Unit: dBm
-			- On_Power_Peak: float: ON power peak value within preamble Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -37,21 +37,21 @@
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation \n
 		Snippet: value: ResultData = driver.prach.pdynamics.standardDev.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation \n
 		Snippet: value: ResultData = driver.prach.pdynamics.standardDev.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/State.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/State/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetMainState = None, target_sync_state: enums.TargetSyncState = None) -> enums.ResourceState:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:STATe \n
-		Snippet: value: enums.ResourceState = driver.prach.state.fetch() \n
+		Snippet: value: enums.ResourceState = driver.prach.state.fetch(timeout = 1.0, target_main_state = enums.TargetMainState.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
 		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
 		INITiate..., STOP..., ABORt... to change the measurement state. \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: meas_status: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available"""
-		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:PRACh:STATe?')
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetMainState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:PRACh:STATe? {param}'.rstrip())
 		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/EvPreamble.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/EvPreamble.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvPreamble:
-	"""EvPreamble commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EvPreambleCls:
+	"""EvPreamble commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evPreamble", core, parent)
+		self._cmd_group = CommandsGroup("evPreamble", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble \n
 		Snippet: value: List[float] = driver.prach.trace.evPreamble.read() \n
-		Return the values of the EVM vs. preamble traces. See also 'Views EVM vs Preamble, Power vs Preamble'. \n
+		Return the values of the EVM vs preamble traces. See also 'View EVM vs Preamble, Power vs Preamble'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: 32 EVM values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: %"""
+			:return: results: float 32 EVM values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble \n
 		Snippet: value: List[float] = driver.prach.trace.evPreamble.fetch() \n
-		Return the values of the EVM vs. preamble traces. See also 'Views EVM vs Preamble, Power vs Preamble'. \n
+		Return the values of the EVM vs preamble traces. See also 'View EVM vs Preamble, Power vs Preamble'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: 32 EVM values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: %"""
+			:return: results: float 32 EVM values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evm:
-	"""Evm commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evm", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Evm_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Evm_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Evm_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Evm':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Evm(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage \n
 		Snippet: value: List[float] = driver.prach.trace.evm.average.read() \n
-		Return the values of the EVM vs. subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
 		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage \n
 		Snippet: value: List[float] = driver.prach.trace.evm.average.fetch() \n
-		Return the values of the EVM vs. subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
 		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.evm.current.read() \n
-		Return the values of the EVM vs. subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.perror.current.read() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
 		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.evm.current.fetch() \n
-		Return the values of the EVM vs. subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.perror.current.fetch() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
 		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Evm/Maximum.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum \n
 		Snippet: value: List[float] = driver.prach.trace.evm.maximum.read() \n
-		Return the values of the EVM vs. subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
 		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum \n
 		Snippet: value: List[float] = driver.prach.trace.evm.maximum.fetch() \n
-		Return the values of the EVM vs. subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
 		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Iq.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/EvmSymbol/Average.py`

 * *Files 22% similar despite different names*

```diff
@@ -4,40 +4,50 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Iq:
-	"""Iq commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iq", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Iphase: List[float]: Normalized I amplitude
-			- Qphase: List[float]: Normalized Q amplitude"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Low: List[float]: float EVM value for low EVM window position. Unit: %
+			- High: List[float]: float EVM value for high EVM window position. Unit: %"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
+			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Iphase: List[float] = None
-			self.Qphase: List[float] = None
+			self.Low: List[float] = None
+			self.High: List[float] = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ \n
-		Snippet: value: FetchStruct = driver.prach.trace.iq.fetch() \n
-		Returns the results in the I/Q constellation diagram. There is one pair of values per modulation symbol. For preamble
-		format 4, there are 139 symbols. For preamble format 0 to 3, there are 839 symbols. The results are returned in the
-		following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ..., {<IPhase>, <QPhase>}symbol n See also 'View I/Q
-		Constellation'. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ?', self.__class__.FetchStruct())
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:EVMSymbol:AVERage \n
+		Snippet: value: ResultData = driver.prach.evmSymbol.average.read() \n
+		Returns the values of the EVM RMS bar graphs for the OFDM symbols in the measured preamble. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of EVM values per OFDM symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1 If the preamble contains only one symbol,
+		NCAPs are returned for the remaining symbol. See also 'View EVM vs Symbol'. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:EVMSymbol:AVERage?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:EVMSymbol:AVERage \n
+		Snippet: value: ResultData = driver.prach.evmSymbol.average.fetch() \n
+		Returns the values of the EVM RMS bar graphs for the OFDM symbols in the measured preamble. The results of the current,
+		average and maximum bar graphs can be retrieved. There is one pair of EVM values per OFDM symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1 If the preamble contains only one symbol,
+		NCAPs are returned for the remaining symbol. See also 'View EVM vs Symbol'. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:EVMSymbol:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Merror/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage \n
 		Snippet: value: List[float] = driver.prach.trace.merror.average.read() \n
 		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase Error'. \n
+		results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage \n
 		Snippet: value: List[float] = driver.prach.trace.merror.average.fetch() \n
 		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase Error'. \n
+		results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,35 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.merror.current.read() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum \n
+		Snippet: value: List[float] = driver.prach.trace.perror.maximum.read() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
+		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.merror.current.fetch() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum \n
+		Snippet: value: List[float] = driver.prach.trace.perror.maximum.fetch() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
+		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Perror/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,35 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.merror.maximum.read() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage \n
+		Snippet: value: List[float] = driver.prach.trace.perror.average.read() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
+		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.merror.maximum.fetch() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage \n
+		Snippet: value: List[float] = driver.prach.trace.perror.average.fetch() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'View EVM, Magnitude Error, Phase
+		Error'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: %"""
+			:return: results: float The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PositivCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PositivCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.pdynamics.current.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.prach.trace.pdynamics.current.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum \n
+		Snippet: value: List[float] = driver.prach.trace.pdynamics.maximum.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum \n
+		Snippet: value: List[float] = driver.prach.trace.pdynamics.maximum.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Maximum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.maximum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage \n
+		Snippet: value: List[float] = driver.prach.trace.pdynamics.average.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.maximum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage \n
+		Snippet: value: List[float] = driver.prach.trace.pdynamics.average.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. See also 'View Power Dynamics'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the preamble. The values have a spacing of 1.5625 µs. The 705th value is at the start of the preamble (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Current.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.perror.average.read() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.srs.trace.pdynamics.current.read() \n
+		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
+		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
+		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.perror.average.fetch() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.srs.trace.pdynamics.current.fetch() \n
+		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
+		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
+		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Modulation/Nsymbol.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,39 +1,24 @@
-from typing import List
-
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NsymbolCls:
+	"""Nsymbol commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.perror.current.read() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
-		Error'. \n
-		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
-		return response
+		self._cmd_group = CommandsGroup("nsymbol", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.perror.current.fetch() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Views EVM, Magnitude Error, Phase
-		Error'. \n
+	def fetch(self) -> int:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:NSYMbol \n
+		Snippet: value: int = driver.prach.modulation.nsymbol.fetch() \n
+		Queries the number of active OFDM symbols (symbols with result bars) in the EVM vs symbol bar graph. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values Unit: deg"""
+			:return: no_of_symbols: decimal"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:NSYMbol?', suppressed)
+		return Conversions.str_to_int(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Prach_/Trace_/PvPreamble.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Trace/PvPreamble.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PvPreamble:
-	"""PvPreamble commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PvPreambleCls:
+	"""PvPreamble commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pvPreamble", core, parent)
+		self._cmd_group = CommandsGroup("pvPreamble", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble \n
 		Snippet: value: List[float] = driver.prach.trace.pvPreamble.read() \n
-		Return the values of the power vs. preamble traces. See also 'Views EVM vs Preamble, Power vs Preamble'. \n
+		Return the values of the power vs preamble traces. See also 'View EVM vs Preamble, Power vs Preamble'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: 32 power values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: dBm"""
+			:return: results: float 32 power values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble \n
 		Snippet: value: List[float] = driver.prach.trace.pvPreamble.fetch() \n
-		Return the values of the power vs. preamble traces. See also 'Views EVM vs Preamble, Power vs Preamble'. \n
+		Return the values of the power vs preamble traces. See also 'View EVM vs Preamble, Power vs Preamble'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: 32 power values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: dBm"""
+			:return: results: float 32 power values, for preamble 1 to 32 (NCAP for not measured preambles) Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal.StructBase import StructBase
-from ..Internal.ArgStruct import ArgStruct
-from .. import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal.StructBase import StructBase
+from ...Internal.ArgStruct import ArgStruct
+from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Route:
-	"""Route commands group definition. 5 total commands, 1 Sub-groups, 1 group commands"""
+class RouteCls:
+	"""Route commands group definition. 5 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("route", core, parent)
+		self._cmd_group = CommandsGroup("route", core, parent)
 
 	@property
 	def scenario(self):
-		"""scenario commands group. 2 Sub-classes, 2 commands."""
+		"""scenario commands group. 3 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scenario'):
-			from .Route_.Scenario import Scenario
-			self._scenario = Scenario(self._core, self._base)
+			from .Scenario import ScenarioCls
+			self._scenario = ScenarioCls(self._core, self._cmd_group)
 		return self._scenario
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
+	class ValueStruct(StructBase):  # From ReadStructDefinition CmdPropertyTemplate.xml
 		"""Structure for reading output parameters. Fields: \n
 			- Scenario: enums.Scenario: SALone | CSPath | MAPRotocol SALone: Standalone (non-signaling) CSPath: Combined signal path MAPRotocol: Measure at protocol test
-			- Controller: str: Controlling application for scenario CSPath or MAPRotocol
+			- Controller: str: string Controlling application for scenario CSPath or MAPRotocol
 			- Rx_Connector: enums.RxConnector: RF connector for the input path
 			- Rf_Converter: enums.RxConverter: RX module for the input path"""
 		__meta_args_list = [
 			ArgStruct.scalar_enum('Scenario', enums.Scenario),
 			ArgStruct.scalar_str('Controller'),
 			ArgStruct.scalar_enum('Rx_Connector', enums.RxConnector),
 			ArgStruct.scalar_enum('Rf_Converter', enums.RxConverter)]
@@ -37,23 +37,22 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Scenario: enums.Scenario = None
 			self.Controller: str = None
 			self.Rx_Connector: enums.RxConnector = None
 			self.Rf_Converter: enums.RxConverter = None
 
-	# noinspection PyTypeChecker
 	def get_value(self) -> ValueStruct:
 		"""SCPI: ROUTe:LTE:MEASurement<Instance> \n
 		Snippet: value: ValueStruct = driver.route.get_value() \n
-		Returns the configured routing settings. For possible connector and converter values, see 'Values for RF Path Selection'. \n
+		Returns the configured routing settings. For possible connector and converter values, see 'Values for RF path selection'. \n
 			:return: structure: for return value, see the help for ValueStruct structure arguments.
 		"""
 		return self._core.io.query_struct('ROUTe:LTE:MEASurement<Instance>?', self.__class__.ValueStruct())
 
-	def clone(self) -> 'Route':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RouteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Route(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RouteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Route_/Scenario_/MaProtocol.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Route/Scenario/MaProtocol.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MaProtocol:
-	"""MaProtocol commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaProtocolCls:
+	"""MaProtocol commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maProtocol", core, parent)
+		self._cmd_group = CommandsGroup("maProtocol", core, parent)
 
 	def set(self, controler: str = None) -> None:
 		"""SCPI: ROUTe:LTE:MEASurement<Instance>:SCENario:MAPRotocol \n
-		Snippet: driver.route.scenario.maProtocol.set(controler = '1') \n
+		Snippet: driver.route.scenario.maProtocol.set(controler = 'abc') \n
 		Activates the Measure@ProtocolTest scenario and optionally selects the controlling protocol test application. The signal
 		routing and analyzer settings are ignored by the measurement application. Configure the corresponding settings within the
 		protocol test application used in parallel. \n
-			:param controler: String parameter selecting the protocol test application Example: 'Protocol Test1'
+			:param controler: string Protocol test application Example: 'Protocol Test1'
 		"""
 		param = ''
 		if controler:
 			param = Conversions.value_to_quoted_str(controler)
 		self._core.io.write(f'ROUTe:LTE:MEASurement<Instance>:SCENario:MAPRotocol {param}'.strip())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sense:
-	"""Sense commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class SenseCls:
+	"""Sense commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sense", core, parent)
+		self._cmd_group = CommandsGroup("sense", core, parent)
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Sense_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	@property
 	def multiEval(self):
 		"""multiEval commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_multiEval'):
-			from .Sense_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
 		return self._multiEval
 
-	def clone(self) -> 'Sense':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SenseCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sense(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SenseCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/CarrierAggregation.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/CarrierAggregation.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	def get_fshware(self) -> bool:
 		"""SCPI: SENSe:LTE:MEASurement<Instance>:CAGGregation:FSHWare \n
 		Snippet: value: bool = driver.sense.carrierAggregation.get_fshware() \n
 		This command is only relevant for combined signal path measurements in multi-CMW setups. It queries whether the
 		measurement instance and the carrier to be measured are in the same CMW. If they are in different CMWs, the measurement
 		fails. To correct the problem, use another measurement instance or select another carrier, so that both are in the same
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Sense/MultiEval/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def spectrum(self):
 		"""spectrum commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_spectrum'):
-			from .MultiEval_.Spectrum import Spectrum
-			self._spectrum = Spectrum(self._core, self._base)
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
 		return self._spectrum
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class EmtcCls:
+	"""Emtc commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("emtc", core, parent)
 
 	@property
-	def seMask(self):
-		"""seMask commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_seMask'):
-			from .Spectrum_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
+	def nband(self):
+		"""nband commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_nband'):
+			from .Nband import NbandCls
+			self._nband = NbandCls(self._core, self._cmd_group)
+		return self._nband
 
-	def clone(self) -> 'Spectrum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EmtcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Spectrum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EmtcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,27 +1,35 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	@property
-	def rbw(self):
-		"""rbw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbw'):
-			from .SeMask_.Rbw import Rbw
-			self._rbw = Rbw(self._core, self._base)
-		return self._rbw
+	def seMask(self):
+		"""seMask commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_seMask'):
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
+		return self._seMask
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def aclr(self):
+		"""aclr commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_aclr'):
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
+		return self._aclr
+
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,112 +1,104 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 25 total commands, 3 Sub-groups, 3 group commands"""
+class PrachCls:
+	"""Prach commands group definition. 80 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("prach", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Srs_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def trace(self):
-		"""trace commands group. 1 Sub-classes, 0 commands."""
+		"""trace commands group. 7 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .Srs_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
+	def modulation(self):
+		"""modulation commands group. 9 Sub-classes, 0 commands."""
+		if not hasattr(self, '_modulation'):
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
+		return self._modulation
+
+	@property
+	def evmSymbol(self):
+		"""evmSymbol commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_evmSymbol'):
+			from .EvmSymbol import EvmSymbolCls
+			self._evmSymbol = EvmSymbolCls(self._core, self._cmd_group)
+		return self._evmSymbol
+
+	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .Srs_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
-	def initiate(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.initiate() \n
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.prach.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:LTE:MEASurement<Instance>:SRS')
-
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:SRS')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:PRACh', opc_timeout_ms)
 
 	def stop(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.stop() \n
+		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.prach.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
-		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:SRS')
+		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:PRACh')
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.stop_with_opc() \n
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.prach.stop_with_opc() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:SRS')
-
-	def abort(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.abort() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:LTE:MEASurement<Instance>:SRS')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:PRACh', opc_timeout_ms)
 
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.abort_with_opc() \n
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.prach.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwLteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:SRS')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:PRACh', opc_timeout_ms)
 
-	def clone(self) -> 'Srs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PrachCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Srs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PrachCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 14 total commands, 5 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pdynamics_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Pdynamics_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Prach/Pdynamics/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,104 +1,92 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
+			ArgStruct.scalar_float('On_Power_Rms'),
+			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
+			self.On_Power_Rms: float = None
+			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.srs.pdynamics.average.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.prach.pdynamics.minimum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.srs.pdynamics.average.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.prach.pdynamics.minimum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for subframe before preamble without transient period Unit: dBm
+			- On_Power_Rms: float or bool: float ON power mean value over preamble Unit: dBm
+			- On_Power_Peak: float or bool: float ON power peak value within preamble Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after preamble without transient period Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.average.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
+		Snippet: value: CalculateStruct = driver.prach.pdynamics.minimum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -41,64 +41,64 @@
 			self.On_Power_Rms_1: float = None
 			self.On_Power_Peak_1: float = None
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.srs.pdynamics.current.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.srs.pdynamics.average.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.srs.pdynamics.current.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.srs.pdynamics.average.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float or bool: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float or bool: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float or bool: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float or bool: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.current.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
+		Snippet: value: CalculateStruct = driver.srs.pdynamics.average.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Minimum.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/Current.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -41,64 +41,64 @@
 			self.On_Power_Rms_1: float = None
 			self.On_Power_Peak_1: float = None
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.srs.pdynamics.minimum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
+		Snippet: value: ResultData = driver.srs.pdynamics.current.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.srs.pdynamics.minimum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
+		Snippet: value: ResultData = driver.srs.pdynamics.current.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float or bool: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float or bool: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float or bool: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float or bool: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float or bool: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float or bool: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.minimum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
+		Snippet: value: CalculateStruct = driver.srs.pdynamics.current.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Pdynamics_/StandardDev.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Pdynamics/StandardDev.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol Unit: dBm
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol Unit: dBm
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol Unit: dBm
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol Unit: dBm"""
+			- Reliability: int: decimal 'Reliability indicator'
+			- Out_Of_Tolerance: int: decimal Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits. Unit: %
+			- Off_Power_Before: float: float OFF power mean value for time period before SRS symbol Unit: dBm
+			- On_Power_Rms_1: float: float ON power mean value over the first SRS symbol Unit: dBm
+			- On_Power_Peak_1: float: float ON power peak value for the first SRS symbol Unit: dBm
+			- On_Power_Rms_2: float: float ON power mean value over the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- On_Power_Peak_2: float: float ON power peak value for the second SRS symbol (NCAP returned for FDD) Unit: dBm
+			- Off_Power_After: float: float OFF power mean value for subframe after SRS symbol Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -43,21 +43,21 @@
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation \n
 		Snippet: value: ResultData = driver.srs.pdynamics.standardDev.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation \n
 		Snippet: value: ResultData = driver.srs.pdynamics.standardDev.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/State.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/State/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetMainState = None, target_sync_state: enums.TargetSyncState = None) -> enums.ResourceState:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:STATe \n
-		Snippet: value: enums.ResourceState = driver.srs.state.fetch() \n
+		Snippet: value: enums.ResourceState = driver.srs.state.fetch(timeout = 1.0, target_main_state = enums.TargetMainState.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
 		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
 		INITiate..., STOP..., ABORt... to change the measurement state. \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: meas_status: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available"""
-		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:SRS:STATe?')
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetMainState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:SRS:STATe? {param}'.rstrip())
 		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/State_/All.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/State/All.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,40 +1,33 @@
+from typing import List
+
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Main_State: enums.ResourceState: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available
-			- Sync_State: enums.ResourceState: PEND | ADJ | INV PEND: waiting for resource allocation, adjustment, hardware switching ('pending') ADJ: adjustments finished, measurement running ('adjusted') INV: not applicable, MainState OFF or RDY ('invalid')
-			- Resource_State: enums.ResourceState: QUE | ACT | INV QUE: measurement without resources, no results available ('queued') ACT: resources allocated, acquisition of results in progress but not complete ('active') INV: not applicable, MainState OFF or RDY ('invalid')"""
-		__meta_args_list = [
-			ArgStruct.scalar_enum('Main_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Sync_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Resource_State', enums.ResourceState)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Main_State: enums.ResourceState = None
-			self.Sync_State: enums.ResourceState = None
-			self.Resource_State: enums.ResourceState = None
-
-	def fetch(self) -> FetchStruct:
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetMainState = None, target_sync_state: enums.TargetSyncState = None) -> List[enums.ResourceState]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:STATe:ALL \n
-		Snippet: value: FetchStruct = driver.srs.state.all.fetch() \n
+		Snippet: value: List[enums.ResourceState] = driver.srs.state.all.fetch(timeout = 1.0, target_main_state = enums.TargetMainState.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
 		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
 		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
 		to change the measurement state. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:STATe:ALL?', self.__class__.FetchStruct())
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
+			:return: state: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetMainState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:SRS:STATe:ALL? {param}'.rstrip())
+		return Conversions.str_to_list_enum(response, enums.ResourceState)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Average.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage \n
 		Snippet: value: List[float] = driver.srs.trace.pdynamics.average.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage \n
 		Snippet: value: List[float] = driver.srs.trace.pdynamics.average.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Current.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.srs.trace.pdynamics.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum \n
+		Snippet: value: List[float] = driver.srs.trace.pdynamics.maximum.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.srs.trace.pdynamics.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum \n
+		Snippet: value: List[float] = driver.srs.trace.pdynamics.maximum.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 µs. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via remote command. The last 800 µs cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Use RsCmwLteMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
+			:return: power: float 2048 power values, from -1100 µs to +2098.4375 µs relative to the start of the SRS symbol. The values have a spacing of 1.5625 µs. The 705th value is at the start of the SRS symbol (0 µs) . Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trigger:
-	"""Trigger commands group definition. 22 total commands, 3 Sub-groups, 0 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trigger", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	@property
-	def multiEval(self):
-		"""multiEval commands group. 2 Sub-classes, 8 commands."""
-		if not hasattr(self, '_multiEval'):
-			from .Trigger_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
-		return self._multiEval
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def prach(self):
-		"""prach commands group. 1 Sub-classes, 5 commands."""
-		if not hasattr(self, '_prach'):
-			from .Trigger_.Prach import Prach
-			self._prach = Prach(self._core, self._base)
-		return self._prach
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def srs(self):
-		"""srs commands group. 1 Sub-classes, 5 commands."""
-		if not hasattr(self, '_srs'):
-			from .Trigger_.Srs import Srs
-			self._srs = Srs(self._core, self._base)
-		return self._srs
-
-	def clone(self) -> 'Trigger':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RmsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trigger(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RmsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/MultiEval/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,74 +1,74 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 10 total commands, 2 Sub-groups, 8 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 11 total commands, 2 Subgroups, 8 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .MultiEval_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	@property
 	def listPy(self):
-		"""listPy commands group. 0 Sub-classes, 1 commands."""
+		"""listPy commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_listPy'):
-			from .MultiEval_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
 	def get_source(self) -> str:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce \n
 		Snippet: value: str = driver.trigger.multiEval.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'Free Run (Fast Sync) ' Free run with synchronization 'Free Run (No Sync) ' Free run without synchronization 'IF Power' Power trigger (received RF power)
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'Free Run (Fast Sync) ' Free run with synchronization 'Free Run (No Sync) ' Free run without synchronization 'IF Power' Power trigger (received RF power)
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce?')
 		return trim_str_response(response)
 
 	def set_source(self, source: str) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce \n
-		Snippet: driver.trigger.multiEval.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'Free Run (Fast Sync) ' Free run with synchronization 'Free Run (No Sync) ' Free run without synchronization 'IF Power' Power trigger (received RF power)
+		Snippet: driver.trigger.multiEval.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'Free Run (Fast Sync) ' Free run with synchronization 'Free Run (No Sync) ' Free run without synchronization 'IF Power' Power trigger (received RF power)
 		"""
 		param = Conversions.value_to_quoted_str(source)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce {param}')
 
 	def get_threshold(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold \n
 		Snippet: value: float or bool = driver.trigger.multiEval.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: trig_threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:return: trig_threshold: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_threshold(self, trig_threshold: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold \n
 		Snippet: driver.trigger.multiEval.set_threshold(trig_threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param trig_threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:param trig_threshold: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trig_threshold)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlope:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SLOPe \n
@@ -91,65 +91,65 @@
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:SLOPe {param}')
 
 	def get_delay(self) -> float:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay \n
 		Snippet: value: float = driver.trigger.multiEval.get_delay() \n
 		Defines a time delaying the start of the measurement relative to the trigger event. This setting has no influence on free
 		run measurements. \n
-			:return: delay: Range: -250E-6 s to 250E-6 s, Unit: s
+			:return: delay: numeric Range: -250E-6 s to 250E-6 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay?')
 		return Conversions.str_to_float(response)
 
 	def set_delay(self, delay: float) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay \n
 		Snippet: driver.trigger.multiEval.set_delay(delay = 1.0) \n
 		Defines a time delaying the start of the measurement relative to the trigger event. This setting has no influence on free
 		run measurements. \n
-			:param delay: Range: -250E-6 s to 250E-6 s, Unit: s
+			:param delay: numeric Range: -250E-6 s to 250E-6 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(delay)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT \n
 		Snippet: value: float or bool = driver.trigger.multiEval.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: trigger_timeout: Range: 0.01 s to 167772.15 s, Unit: s Additional parameters: OFF | ON (disables | enables the timeout)
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s, Unit: s ON | OFF enables or disables the timeout.
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, trigger_timeout: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT \n
 		Snippet: driver.trigger.multiEval.set_timeout(trigger_timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param trigger_timeout: Range: 0.01 s to 167772.15 s, Unit: s Additional parameters: OFF | ON (disables | enables the timeout)
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s, Unit: s ON | OFF enables or disables the timeout.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT {param}')
 
 	def get_mgap(self) -> int:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP \n
 		Snippet: value: int = driver.trigger.multiEval.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:return: min_trig_gap: Range: 0 slots to 20 slots, Unit: slots
+			:return: min_trig_gap: integer Range: 0 slots to 20 slots, Unit: slots
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP?')
 		return Conversions.str_to_int(response)
 
 	def set_mgap(self, min_trig_gap: int) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP \n
 		Snippet: driver.trigger.multiEval.set_mgap(min_trig_gap = 1) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:param min_trig_gap: Range: 0 slots to 20 slots, Unit: slots
+			:param min_trig_gap: integer Range: 0 slots to 20 slots, Unit: slots
 		"""
 		param = Conversions.decimal_value_to_str(min_trig_gap)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP {param}')
 
 	# noinspection PyTypeChecker
 	def get_smode(self) -> enums.SyncMode:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SMODe \n
@@ -169,31 +169,31 @@
 		param = Conversions.enum_scalar_to_str(sync_mode, enums.SyncMode)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:SMODe {param}')
 
 	# noinspection PyTypeChecker
 	def get_amode(self) -> enums.MevAcquisitionMode:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe \n
 		Snippet: value: enums.MevAcquisitionMode = driver.trigger.multiEval.get_amode() \n
-		Selects whether the R&S CMW synchronizes to a slot boundary or to a subframe boundary. The parameter is relevant for
+		Selects whether the measurement synchronizes to a slot boundary or to a subframe boundary. The parameter is relevant for
 		'Free Run (Fast Sync) ' and for list mode measurements with 'Synchronization Mode' = 'Enhanced'. \n
 			:return: acquisition_mode: SLOT | SUBFrame
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.MevAcquisitionMode)
 
 	def set_amode(self, acquisition_mode: enums.MevAcquisitionMode) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe \n
 		Snippet: driver.trigger.multiEval.set_amode(acquisition_mode = enums.MevAcquisitionMode.SLOT) \n
-		Selects whether the R&S CMW synchronizes to a slot boundary or to a subframe boundary. The parameter is relevant for
+		Selects whether the measurement synchronizes to a slot boundary or to a subframe boundary. The parameter is relevant for
 		'Free Run (Fast Sync) ' and for list mode measurements with 'Synchronization Mode' = 'Enhanced'. \n
 			:param acquisition_mode: SLOT | SUBFrame
 		"""
 		param = Conversions.enum_scalar_to_str(acquisition_mode, enums.MevAcquisitionMode)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe {param}')
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/MultiEval_/Catalog.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Prach/Catalog.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_source(self) -> List[str]:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:CATalog:SOURce \n
-		Snippet: value: List[str] = driver.trigger.multiEval.catalog.get_source() \n
-		Lists all trigger source values that can be set using method RsCmwLteMeas.Trigger.MultiEval.source. \n
-			:return: source_list: Comma-separated list of all supported values. Each value is represented as a string.
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:CATalog:SOURce \n
+		Snippet: value: List[str] = driver.trigger.prach.catalog.get_source() \n
+		Lists all trigger source values that can be set using method RsCmwLteMeas.Trigger.Prach.source. \n
+			:return: source_list: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:CATalog:SOURce?')
+		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Prach.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Prach/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Prach:
-	"""Prach commands group definition. 6 total commands, 1 Sub-groups, 5 group commands"""
+class PrachCls:
+	"""Prach commands group definition. 6 total commands, 1 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("prach", core, parent)
+		self._cmd_group = CommandsGroup("prach", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .Prach_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	def get_source(self) -> str:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce \n
 		Snippet: value: str = driver.trigger.prach.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'IF Power': Power trigger (received RF power)
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'IF Power': Power trigger (received RF power)
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce?')
 		return trim_str_response(response)
 
 	def set_source(self, source: str) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce \n
-		Snippet: driver.trigger.prach.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'IF Power': Power trigger (received RF power)
+		Snippet: driver.trigger.prach.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'IF Power': Power trigger (received RF power)
 		"""
 		param = Conversions.value_to_quoted_str(source)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce {param}')
 
 	def get_threshold(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold \n
 		Snippet: value: float or bool = driver.trigger.prach.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: trig_threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:return: trig_threshold: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_threshold(self, trig_threshold: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold \n
 		Snippet: driver.trigger.prach.set_threshold(trig_threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param trig_threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:param trig_threshold: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trig_threshold)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlope:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SLOPe \n
@@ -81,51 +81,51 @@
 		"""
 		param = Conversions.enum_scalar_to_str(slope, enums.SignalSlope)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:SLOPe {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT \n
 		Snippet: value: float or bool = driver.trigger.prach.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: trigger_timeout: Range: 0.01 s to 167772.15 s, Unit: s Additional parameters: OFF | ON (disables | enables the timeout)
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s, Unit: s ON | OFF enables or disables the timeout.
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, trigger_timeout: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT \n
 		Snippet: driver.trigger.prach.set_timeout(trigger_timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param trigger_timeout: Range: 0.01 s to 167772.15 s, Unit: s Additional parameters: OFF | ON (disables | enables the timeout)
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s, Unit: s ON | OFF enables or disables the timeout.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT {param}')
 
 	def get_mgap(self) -> float:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP \n
 		Snippet: value: float = driver.trigger.prach.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:return: min_trig_gap: Range: 0 s to 1E-3 s, Unit: s
+			:return: min_trig_gap: float Range: 0 s to 1E-3 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP?')
 		return Conversions.str_to_float(response)
 
 	def set_mgap(self, min_trig_gap: float) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP \n
 		Snippet: driver.trigger.prach.set_mgap(min_trig_gap = 1.0) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:param min_trig_gap: Range: 0 s to 1E-3 s, Unit: s
+			:param min_trig_gap: float Range: 0 s to 1E-3 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(min_trig_gap)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP {param}')
 
-	def clone(self) -> 'Prach':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PrachCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Prach(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PrachCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Prach_/Catalog.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/MultiEval/Catalog.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_source(self) -> List[str]:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:CATalog:SOURce \n
-		Snippet: value: List[str] = driver.trigger.prach.catalog.get_source() \n
-		Lists all trigger source values that can be set using method RsCmwLteMeas.Trigger.Prach.source. \n
-			:return: source_list: Comma-separated list of all supported values. Each value is represented as a string.
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:CATalog:SOURce \n
+		Snippet: value: List[str] = driver.trigger.multiEval.catalog.get_source() \n
+		Lists all trigger source values that can be set using method RsCmwLteMeas.Trigger.MultiEval.source. \n
+			:return: source_list: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:CATalog:SOURce?')
+		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Srs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Srs/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 6 total commands, 1 Sub-groups, 5 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 6 total commands, 1 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .Srs_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	def get_source(self) -> str:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:SOURce \n
 		Snippet: value: str = driver.trigger.srs.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'IF Power': Power trigger (received RF power)
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'IF Power': Power trigger (received RF power)
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:SOURce?')
 		return trim_str_response(response)
 
 	def set_source(self, source: str) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:SOURce \n
-		Snippet: driver.trigger.srs.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'IF Power': Power trigger (received RF power)
+		Snippet: driver.trigger.srs.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'IF Power': Power trigger (received RF power)
 		"""
 		param = Conversions.value_to_quoted_str(source)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:SOURce {param}')
 
 	def get_threshold(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:THReshold \n
 		Snippet: value: float or bool = driver.trigger.srs.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: trig_threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:return: trig_threshold: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:THReshold?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_threshold(self, trig_threshold: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:THReshold \n
 		Snippet: driver.trigger.srs.set_threshold(trig_threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param trig_threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:param trig_threshold: (float or boolean) numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trig_threshold)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlope:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:SLOPe \n
@@ -81,51 +81,51 @@
 		"""
 		param = Conversions.enum_scalar_to_str(slope, enums.SignalSlope)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:SLOPe {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:TOUT \n
 		Snippet: value: float or bool = driver.trigger.srs.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: trigger_timeout: Range: 0.01 s to 167772.15 s, Unit: s Additional parameters: OFF | ON (disables | enables the timeout)
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s, Unit: s ON | OFF enables or disables the timeout.
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, trigger_timeout: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:TOUT \n
 		Snippet: driver.trigger.srs.set_timeout(trigger_timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param trigger_timeout: Range: 0.01 s to 167772.15 s, Unit: s Additional parameters: OFF | ON (disables | enables the timeout)
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 167772.15 s, Unit: s ON | OFF enables or disables the timeout.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:TOUT {param}')
 
 	def get_mgap(self) -> float:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:MGAP \n
 		Snippet: value: float = driver.trigger.srs.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:return: min_trig_gap: Range: 0 s to 1E-3 s, Unit: s
+			:return: min_trig_gap: float Range: 0 s to 1E-3 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:MGAP?')
 		return Conversions.str_to_float(response)
 
 	def set_mgap(self, min_trig_gap: float) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:MGAP \n
 		Snippet: driver.trigger.srs.set_mgap(min_trig_gap = 1.0) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:param min_trig_gap: Range: 0 s to 1E-3 s, Unit: s
+			:param min_trig_gap: float Range: 0 s to 1E-3 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(min_trig_gap)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:MGAP {param}')
 
-	def clone(self) -> 'Srs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Srs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Implementations/Trigger_/Srs_/Catalog.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Implementations/Trigger/Srs/Catalog.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_source(self) -> List[str]:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:CATalog:SOURce \n
 		Snippet: value: List[str] = driver.trigger.srs.catalog.get_source() \n
 		Lists all trigger source values that can be set using method RsCmwLteMeas.Trigger.Srs.source. \n
-			:return: source_list: Comma-separated list of all supported values. Each value is represented as a string.
+			:return: source_list: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgLinkedEventArgs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgLinkedEventArgs.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Class defining Linked argument Event."""
+
 import time
 
 
 class ArgLinkedEventArgs(object):
 	"""Contains event data for suppressed argument."""
 
 	def __init__(self, link_name: str, arg_name: str, value: object = None, context: str = '', timestamp: time = None):
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgSingle.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgSingle.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,57 @@
+"""Single argument definition for a scalar argument."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
+from .InstrumentErrors import RsInstrException
+
 from .Types import DataType
 
 
 class ArgSingle(object):
 	"""Single Argument outside a structure - used for composing query arguments.
 	Contains the argument value as well (self.value)."""
 
-	def __init__(self, name: str, value, data_type: DataType, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
+	def __init__(self, name: str, value, data_type: DataType, enum_type=None, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
 		self.name = name if name else ''
 		self.argument_ix = None
 		self.value = value
 		self.data_type = data_type
+		self.enum_type = enum_type
 		self.is_optional = is_optional
 		self.is_open_list = is_open_list
 		self.repetition = repetition
 		self.intern_link = intern_link
 		self.conv_from_scpi_string = None
 		self.conv_to_scpi_string = None
 
-		if self.data_type == DataType.Enum:
-			self.assert_mandatory_has_value(self)
-			if self.value is not None:
-				self.enum_type = type(self.value)
-				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
-				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
-		elif self.data_type == DataType.EnumList:
-			self.assert_mandatory_has_value(self)
+		if self.data_type.is_scalar_enum:
+			# self.assert_mandatory_has_value(self)
+			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
+			self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
+		elif self.data_type.is_list_enum:
+			# self.assert_mandatory_has_value(self)
 			if self.value is not None:
-				self.enum_type = type(self.value[0])
 				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
 				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
 		else:
 			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type)
 			self.conv_to_scpi_string = ConverterToScpiString(self.data_type)
 
 		self.check_consistency()
 
 	@classmethod
-	def as_open_list(cls, name: str, value: object, data_type: DataType) -> 'ArgSingle':
+	def as_open_list(cls, name: str, value: object, data_type: DataType, enum_type=None) -> 'ArgSingle':
 		"""Creates new ArgSingle of open list type.Use this method for all non-interleaved list types. \n
-		:param name: name of the argument.
-		:param value: value of the argument.
-		:param data_type: data type of the argument.
-		:return: ArgSingle object of an open list type."""
-		return cls(name, value, data_type, False, True, 1, None)
+		:param name: name of the argument
+		:param value: value of the argument
+		:param data_type: data type of the argument
+		:param enum_type: enum type if the data_type is Enum or EnumExt (or list of those)
+		:return: ArgSingle object of an open list type"""
+		return cls(name, value, data_type, enum_type, False, True, 1, None)
 
 	def __str__(self):
 		opt = '~' if self.is_optional else ''
 		name = f" '{self.name}'" if self.name != '' else ''
 		out = f"SingleArg {opt}{self.data_type.name}{name}"
 
 		if self.is_open_list is False and self.repetition > 1:
@@ -72,15 +75,15 @@
 
 	# noinspection PyUnusedLocal
 	def assert_is_optional(self, obj=None) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
-		raise Exception(f'Single argument is not optional: {self}')
+		raise RsInstrException(f'Single argument is not optional: {self}')
 
 	# noinspection PyUnusedLocal
 	def assert_mandatory_has_value(self, value_obj=None) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
@@ -93,11 +96,11 @@
 
 	def check_consistency(self) -> None:
 		"""Checks the consistency of the object"""
 		if self.value is None:
 			return
 		if isinstance(self.value, list):
 			if self.data_type.is_scalar:
-				raise Exception(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
 		else:
 			if self.data_type.is_list:
-				raise Exception(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgSingleList.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgSingleList.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Single argument definition for a list argument."""
+
 from .ArgSingle import ArgSingle
 from .ArgStringComposer import compose_cmd_string_from_single_args
 
 
 class ArgSingleList(object):
 	"""Contains methods for composing cmd string for the list of single arguments.
 	Used in methods with 1+ set or query arguments.
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgSingleSuppressed.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgSingleSuppressed.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Contains definition for an argument that is suppressed and not exposed to the user.
+Usually such arguments are also linked to a callback."""
+
 from .Types import DataType
 
 
 class ArgSingleSuppressed(object):
 	"""Single suppressed Argument - used in Query_XxXx_Suppressed() to remove it from the returned value.
 	It does not contain:
 	- 'value' attribute, since this is discarded or linked internally directly  in the Query_XxXx_Suppressed().
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStringComposer.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStringComposer.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 The composing of the SCPI parameter string is similar for the ArgStruct and ArgSingle[] objects, therefore they share the same module."""
 
 from typing import Dict
 
 from .ArgSingle import ArgSingle
 from .ArgStruct import ArgStruct
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class SingleComposer:
 	"""Composes strings for single argument.
 	Provides Composer interface with 3 functions:
 	- from_scalar_arg
 	- from_list_arg
@@ -135,15 +136,15 @@
 					# The last argument, ignore the repetitions and convert the whole list to string
 					string_arg.append(composer.from_list_arg(arg))
 				else:
 					# The optional argument, which has no value. End the entire string_arg composition
 					arg.assert_is_optional(values_obj)
 					opt_null_ix = arg_ix
 			else:
-				# More than one arguments remaining. Loop through them interleaving the result strings
+				# More than one argument remaining. Loop through them interleaving the result strings
 				# Interleaving arguments must all have values
 
 				# Check if each list has at least Repetition number of elements
 				cycles_error = False
 				alignments_error = False
 				cycle = -1
 				data = {}
@@ -151,19 +152,18 @@
 					arg = args[x]
 					curr_size: int = composer.get_arg_list_size(arg)
 					curr_cycle: int = curr_size // arg.repetition
 					curr_align: int = curr_size % arg.repetition
 					data[x] = (curr_size, curr_cycle, curr_align)
 
 					if curr_size < 0:
-						raise Exception(
-							f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
 
 					if arg.repetition > curr_size:
-						raise Exception(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
 
 					# noinspection PyChainedComparisons
 					if cycle >= 0 and curr_cycle != cycle:
 						cycles_error = True
 
 					cycle = curr_cycle
 
@@ -171,23 +171,21 @@
 						alignments_error = True
 
 				if cycles_error:
 					message = 'Arguments interleaving is not aligned - all the cycles must be the same. Actual cycles:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] sliced by {get_plural_string("element", args[x].repetition)} ' \
 							f'results in {data[x][0] / args[x].repetition} cycles\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				if alignments_error:
 					message = 'At least one argument has a list size not dividable by the defined repetitions:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] modulo {args[x].repetition}x results in {data[x][0] % args[x].repetition}\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				for x in range(cycle):
 					for y in range(arg_ix, arg_count):
 						arg = args[y]
 						string_arg.append(composer.from_list_arg(arg, arg.repetition * x, arg.repetition))
 
 	if opt_null_ix >= 0:
@@ -198,15 +196,15 @@
 			if arg.has_value(values_obj):
 				rest.append(arg.name)
 
 		if len(rest):
 			msg = f"Optional Argument '{args[opt_null_ix].name}' has no value, but the further ones do. " \
 				f"If you skip an optional argument, you have to skip all the ones following it. " \
 				f"Clear the values for the rest of the argument(s):\n{', '.join(rest)}"
-			raise Exception(msg)
+			raise RsInstrException(msg)
 
 	return ','.join(string_arg)
 
 
 def compose_cmd_string_from_single_args(args: Dict[int, ArgSingle]) -> str:
 	"""Returns SCPI-composed string based on the single args specification.
 	We can use the same function as for the struct arguments, with the difference of providing a SingleComposer.
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStruct.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStruct.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""Definition for an argument which is a part of a structure."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStruct(object):
 	"""Describes an argument in data structures.
 	This info is used to parse a string query response to the output structure,
 	or to parse the output structure to the string parameter for writing.
 	Contains reference to the value in the owning structure."""
@@ -121,17 +124,17 @@
 	def assert_is_optional(self, obj) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		value = getattr(obj, self.name)
 		if value is None:
-			raise Exception(f"Structure '{obj}', argument without value is not optional: {self}")
+			raise RsInstrException(f"Structure '{obj}', argument without value is not optional: {self}")
 		else:
-			raise Exception(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
+			raise RsInstrException(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
 
 	def assert_mandatory_has_value(self, obj) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		if getattr(obj, self.name) is None:
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStructList.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStructList.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""See the class docstring."""
+
 from .ArgStringComposer import StructComposer, compose_cmd_string_from_struct_args
 from .ArgStructStringParser import ArgStructStringParser
 from .StructBase import StructBase
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructList(object):
 	"""Contains methods for composing cmd string and parsing cmd response to the provided structure instance."""
 
 	RAW_DATA_PROP_NAME = 'RawReturnData'
 
@@ -53,22 +56,22 @@
 			# Still some args to go
 			if arg.is_open_list is True:
 				# The previous loop ended because the next argument had is_open_list True
 				if arg_ix == (arg_count - 1):
 					# This is the last argument, ignore the repetitions and take the whole rest of the elements
 					parser.to_list_value(arg, True, 0, parser.remaining, parser.remaining, 1)
 				else:
-					# More than one arguments remaining. Loop through them interleaving the result strings
+					# More than one argument remaining. Loop through them interleaving the result strings
 					open_list_args = {key: value for key, value in self.args.items() if key >= arg_ix}
 
 					# Accumulate the number of repetitions from all the open_list_args
 					period: int = sum(open_list_args[ix].repetition for ix in open_list_args)
 					reminder: int = parser.remaining % period
 					if reminder != 0:
-						raise Exception(
+						raise RsInstrException(
 							f'Arguments parsing is not aligned - source string elements remaining to parse {parser.remaining}'
 							f'is not dividable by the summary Period {period} of all the open list arguments:\n' + '\n'.join(['{}'.format(x) for x in open_list_args]))
 					# Go through the arguments and accumulate the list content
 					offset = 0
 					for x in open_list_args:
 						arg = open_list_args[x]
 						parser.to_list_value(arg, False, offset, arg.repetition, period, -1)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ArgStructStringParser.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ArgStructStringParser.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,12 @@
+"""See the class docstring."""
+
 from . import Utilities
 from .ArgStruct import ArgStruct
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructStringParser:
 	"""Class for parsing a response from the instrument to an output structure of arguments.
 	It is used by the ArgStructList class for filling structures with return values."""
 
 	def __init__(self, struct, value: str):
@@ -17,34 +20,34 @@
 		"""Remaining items to parse."""
 		return self.count - self.position
 
 	def to_scalar_value(self, arg: ArgStruct):
 		"""Parses the current element to a scalar argument."""
 		assert arg.data_type.is_scalar, f'to_scalar_value() method only works with scalar values. Data type: {arg.data_type}'
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse a scalar value to structure argument. Response contains only {self.count} elements, "
 				f"argument '{arg.name}' has position {self.position + 1}.\n"
 				f"Response (commas replaced by new lines):\n" + Utilities.truncate_string_from_end('\n'.join(self.elements), 1000))
 		string = self.elements[self.position]
 		value = arg.conv_from_scpi_string.get_one_element_value(string)
 		setattr(self.struct, arg.name, value)
 		self.position += 1
 
 	def to_list_value(self, arg: ArgStruct, increase_pos: bool, offset: int, count: int, period: int, cycles: int) -> None:
 		"""Parses more elements to the list argument - slicing."""
 		assert arg.data_type.is_list, f'to_list_value method only works with list values. Data type: {arg.data_type}'
 		if cycles < 0:
 			cycles = self.remaining // period
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse an list value to the argument '{arg.name}', "
 				f"because the element position {self.position} is over the parsed list length {self.count}")
 		if (self.position + offset + count) > self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse the whole list value to the argument '{arg.name}', because the element position {self.position} "
 				f"plus the argument offset {offset} and argument length {count} would be over the parsed list length {self.count}")
 
 		result = []
 		for cycle in range(cycles):
 			start_ix = self.position + (cycle * period) + offset
 			for i in range(count):
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/CommandsGroup.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/CommandsGroup.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 from enum import Enum
 from typing import List
 from .Core import Core
 from .RepeatedCapability import RepeatedCapability as RepCap
 from .InstrumentErrors import DriverValueError
 
 
@@ -38,27 +40,27 @@
 		return self.multi_repcap_types != ''
 
 	def add_existing_child(self, child: 'CommandsGroup') -> None:
 		"""Adds the child to the parent's list of created children.
 		This is used when the group is cloned, where the whole existing tree of groups have to be recreated"""
 		self.existing_children.append(child)
 
-	def set_repcap_enum_value(self, enum_value: Enum) -> None:
-		"""Sets RepCap value as enum
-		Default is not allowed."""
+	def set_repcap_enum_value(self, enum_value: Enum or int) -> None:
+		"""Sets RepCap value as enum or integer
+		Default is not allowed here."""
 		try:
 			self.rep_cap.set_enum_value(enum_value)
 		except ValueError:
 			raise DriverValueError(self.io.resource_name, f"Commands group RepCap value '{self.rep_cap.name}.Default' cannot be set. Please select a concrete value.")
 
 	def get_repcap_enum_value(self) -> Enum:
 		"""Returns RepCap value as enum"""
 		return self.rep_cap.get_enum_value()
 
-	def get_repcap_cmd_value(self, enum_value: Enum, enum_type) -> str:
+	def get_repcap_cmd_value(self, enum_value: Enum or int, enum_type) -> str:
 		"""Returns the current string of RepCapCmdValue for the entered RepCapEnumName
 		The enum_value can be a repcap of the current CommandsGroup or any of their parents"""
 		# Use the static functions of the RepeatedCapability to get the non-default value
 		# It is faster, since there is no need to use the RepCap instance
 		if not RepCap.clsm_is_default_value(enum_value, enum_type):
 			return RepCap.clsm_get_cmd_string_value(enum_value, enum_type)
 		# Default value - get it from the group or the parent groups
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Conversions.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Conversions.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,14 +1,20 @@
+"""Contains conversion functions for SCPI string -> parameter and vice versa."""
+
 import math
 import struct
 import sys
 from enum import Enum
-from typing import List
+from typing import List, Tuple
+from .ScpiEnums import ScpiEnum, enum_spec_prefixes, enum_spec_strings
+from .Properties import Properties
+from datetime import datetime
 
 from . import Utilities
+from .InstrumentErrors import RsInstrException
 
 
 class BinFloatFormat(Enum):
 	"""Binary format of a float number."""
 	Single_4bytes = 1
 	Single_4bytes_swapped = 2
 	Double_8bytes = 3
@@ -24,15 +30,15 @@
 
 
 def assert_string_data(value: str) -> None:
 	"""Asserts value is string type."""
 	assert isinstance(value, str), f"Input value type must be string. Actual type: {type(value)}, value: {value}"
 
 
-def assert_list_data(value: list) -> None:
+def assert_list_data(value: List) -> None:
 	"""Asserts value is list type."""
 	assert isinstance(value, list), f"Input value type must be a list. Actual type: {type(value)}, value: {value}"
 
 
 def _get_endianness_symbol(swap_endianness: bool) -> str:
 	"""Based on the current endianness returns the symbol used in the 'struct' module."""
 	if swap_endianness is False:
@@ -143,15 +149,15 @@
 bool_true_lookup = frozenset(['1', 'on', 'On', 'ON', 'true', 'True', 'TRUE'])
 bool_false_lookup = frozenset(['0', 'off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 pure_bool_false_lookup = frozenset(['off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 
 
 def str_to_bool(string: str) -> bool:
 	"""Converts string to boolean value.
-	The function robust, and case insensitive.
+	The function is robust, and case-insensitive.
 	If the string can not be converted to a boolean, the function returns False."""
 	assert_string_data(string)
 	if string in bool_true_lookup:
 		return True
 	if string in bool_false_lookup:
 		return False
 	# If leading/trailing spaces
@@ -193,24 +199,38 @@
 
 
 number_plus_inf_lookup = frozenset(['Inf', 'INF', 'INFINITY', '+Inf', '+INF', '+inf', '+INFINITY', '+Infinity', '+infinity'])
 number_minus_inf_lookup = frozenset(['-Inf', '-INF', '-inf', '-INFINITY', '-Infinity', '-infinity'])
 number_nan_lookup = frozenset(['Nan', 'NAN', 'nan', 'NaN', 'NAV', 'NaV', 'NCAP', 'INV', 'NONE', 'none', 'None', 'DTX', 'UND', 'und'])
 number_max_lookup = frozenset(['OFL', 'ofl', 'Ofl'])
 number_min_lookup = frozenset(['UFL', 'ufl', 'Ufl'])
+number_si_suffix = {
+	'pHz': 1E-12, 'MHz': 1E+6, 'kHz': 1E+3, 'GHz': 1E+9, 'mHz': 1E-3, 'uHz': 1E-6, 'µHz': 1E-6, 'THz': 1E+12, 'nHz': 1E-9, 'ns': 1E-9, 'fW': 1E-15,
+	'pW': 1E-12, 'nW': 1E-9, 'uW': 1E-6, 'µW': 1E-6, 'mW': 1E-3, 'kW': 1E3, 'MW': 1E6, 'GW': 1E9, 'MV': 1E+6, 'MA': 1E+6, 'ps': 1E-12, 'fs': 1E-15,
+	'km': 1E+3, 'kV': 1E+3, 'kA': 1E+3, 'pF': 1E-2, 'Hz': 1.0, 'mm': 1E-3, 'mA': 1E-3, 'mF': 1E-3, 'mV': 1E-3, 'pV': 1E-12, 'nF': 1E-9, 'nA': 1E-9,
+	'nV': 1E-9, 'nm': 1E-9, 'pm': 1E-12, 'us': 1E-6, 'µs': 1E-6, 'uF': 1E-6, 'µF': 1E-6, 'ms': 1E-3, 'uA': 1E-6, 'µA': 1E-6, 'uV': 1E-6, 'µV': 1E-6,
+	'um': 1E-6, 'µm': 1E-6, 'pA': 1E-12, 'V': 1, 'W': 1, 'A': 1, 'F': 1, 's': 1, 'm': 1}
 int_neg_inf = -(sys.maxsize - 1)
-enum_spec_prefixes = {'_minus': '-', '_plus': '+', '_': ''}
-enum_spec_strings = {'_dash_': '-', '_dot_': '.'}
+
+
+def strip_si_suffix(string: str) -> Tuple[bool, str, float]:
+	"""Tries to find defined suffixes in the text and returns the stripped text and the multiplier as double number.
+	If no known suffix is detected, the method returns false, strippedText=text, multiplier=1.0
+	Example: text='123 MHz' strippedText='123' multiplier=1E6"""
+	for suffix in number_si_suffix.keys():
+		if string.endswith(suffix):
+			return True, string[:-len(suffix)].rstrip(), number_si_suffix[suffix]
+	return False, string, 1.0
 
 
 def str_to_int(string: str) -> int:
 	"""Converts string to integer value. Float values are coerced to integer.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0
 	value = str_special_values_to_int(string)
 	if value:
 		return value
 
 	# Hexadecimal numbers
@@ -232,15 +252,24 @@
 		if ',' in string:
 			return int(string[2:string.find(',')], 8)
 		else:
 			return int(string[2:], 8)
 	# Simulation
 	if string == 'Simulating':
 		return 0
-	return int(round(float(string)))
+	try:
+		return int(round(float(string)))
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return int(round(float(result[1]) * result[2]))
+		except ValueError:
+			raise ValueError(f"could not convert string to integer: '{string}'")
 
 
 def str_special_values_to_int(string: str) -> int:
 	"""Converts special string values to integer. Returns None if no special value was found."""
 	assert_string_data(string)
 	if string in number_plus_inf_lookup or string in number_max_lookup:
 		return sys.maxsize
@@ -270,17 +299,17 @@
 	if result is not None:
 		return result
 	return str_to_int(string)
 
 
 def str_to_float(string: str) -> float:
 	"""Converts string to float value.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0.0
 	if string in number_plus_inf_lookup:
 		return math.inf
 	if string in number_minus_inf_lookup:
 		return -math.inf
 	if string in number_nan_lookup:
@@ -299,15 +328,24 @@
 		return -sys.float_info.max / 100
 	if string == 'ULEU':
 		return sys.float_info.max / 10
 	if string == 'ULEL':
 		return -sys.float_info.max / 10
 	if string == 'Simulating':
 		return 0.0
-	return float(string)
+	try:
+		return float(string)
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return float(result[1]) * result[2]
+		except ValueError:
+			raise ValueError(f"could not convert string to float: '{string}'")
 
 
 def str_to_float_or_bool(string: str) -> float or bool:
 	"""Similar to str_to_float, but for special values "ON/OFF" the function returns boolean"""
 	result = string_to_pure_bool(string)
 	if result is not None:
 		return result
@@ -320,24 +358,24 @@
 
 
 def bool_to_str(value: bool) -> str:
 	"""Converts boolean to 'ON' or 'OFF' string."""
 	if type(value) is bool:
 		return 'ON' if value is True else 'OFF'
 	else:
-		raise Exception(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
+		raise RsInstrException(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
 
 
 def str_enclose_by_quotes(string: str) -> str:
 	"""Returns string enclosed by single quotes."""
 	assert_string_data(string)
-	return "'" + string + "'"
+	return Properties.scpi_quotes + string + Properties.scpi_quotes
 
 
-def list_to_csv_str(value: list) -> str:
+def list_to_csv_str(value: List, delimiter: str = ',') -> str:
 	"""Converts list of elements to strings separated by commas.
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string -> string no quotes
@@ -345,18 +383,18 @@
 	assert_list_data(value)
 	result = []
 	for x in value:
 		el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_str: '{x}'")
 		result.append(el)
-	return ','.join(result)
+	return delimiter.join(result)
 
 
-def list_to_csv_quoted_str(value: list) -> str:
+def list_to_csv_quoted_str(value: List) -> str:
 	"""Converts list of elements to quoted strings separated by commas.
 	Only string elements are enclosed by single quotes
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
@@ -368,29 +406,28 @@
 		if isinstance(x, str):
 			el = str_enclose_by_quotes(x)
 		else:
 			el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_quoted_str: '{x}'")
 		result.append(el)
-
 	return ','.join(result)
 
 
 def decimal_value_to_str(x: int or float) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float"""
 	if isinstance(x, int) and type(x) is not bool:
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
+		raise RsInstrException(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
 
 
 def decimal_or_bool_value_to_str(x: int or float or bool) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float
@@ -398,15 +435,15 @@
 	if type(x) is bool:
 		return bool_to_str(x)
 	if isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
+		raise RsInstrException(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
 
 
 def value_to_str(x: int or bool or float or str or Enum) -> str:
 	"""Converts scalar value to string.
 	Supported element types:
 	- int
 	- bool
@@ -418,17 +455,19 @@
 	elif isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	elif isinstance(x, str):
 		return x
 	elif isinstance(x, Enum):
+		if isinstance(x.value, str):
+			return enum_value_to_scpi_string(x.value)
 		return enum_value_to_scpi_string(x.name)
 	else:
-		raise Exception(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
+		raise RsInstrException(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
 
 
 def enum_value_to_scpi_string(enum_value: str) -> str:
 	"""Conversion EnumValue -> SCPI_String
 	Unescapes all the special characters that can not be contained in the enum member definition, but can be sent to the instrument as enum string.
 	Use this to send the scpi enum value to the instrument."""
 	for key in enum_spec_prefixes:
@@ -443,15 +482,15 @@
 	"""Converts scalar value to string enclosed by single quotes.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string
 	- enum"""
-	return f"'{value_to_str(x)}'"
+	return Properties.scpi_quotes + value_to_str(x) + Properties.scpi_quotes
 
 
 def str_to_float_list(string: str) -> List[float]:
 	"""Converts string with comma-separated values to list of Floats."""
 	assert_string_data(string)
 	if not string:
 		return []
@@ -504,103 +543,158 @@
 		return []
 	result = [*map(Utilities.trim_str_response, string.split(','))]
 	if clear_one_empty_item and len(result) == 1 and result[0] == '':
 		return []
 	return result
 
 
-def _find_in_enum_members(item: str, enum_members: List[str]) -> int:
-	"""Matches a string in the provided list of member strings.
-	The item must be not fully matched.
-	The item is matched if a member string starts with the item (the item is a prefix of the member).
-	Example: item='CONN' will match the enum_member 'CONNected'
-	If the item contains a comma, only the value before comma is considered
-	Returns found index in the enum_members list"""
-	if ',' in item:
-		item = item[:item.index(',')].strip()
-	i = 0
-	for x in enum_members:
-		if x.startswith(item):
-			return i
-		i += 1
-
-	# smart matching:
-	# item = 'MAX' matches enum 'MAXpeak'
-	# item = 'SPECtrum1' matches enum 'SPEC1'
-	# item = 'SPEC' matches enum 'SPECtrum1'
-
-	item = ''.join([c for c in item if not c.islower()])
-	# item must be longer than 1 character
-	if len(item) < 2:
-		return -1
-	i = 0
-	for x in enum_members:
-		x_uc = ''.join([c for c in x if not c.islower()])
-		if x_uc == item:
-			return i
-		i += 1
-	return -1
-
-
-def str_to_scalar_enum_helper(string: str, enum_type: Enum, enum_members=None) -> Enum:
+def str_to_scalar_enum_helper(string: str, scpi_enum: ScpiEnum, array_search: bool, exc_if_not_found) -> Enum:
 	"""Converts string to one enum element.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	value = Utilities.trim_str_response(string)
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
-
-	# Search in the enum member and return the index of the matched item
-	ix = _find_in_enum_members(value, enum_members)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
-	# If the result is -1 (not found), try to replace the special values and search again
-	# This is done to improve the performance, since most of the enums have no special values
-	enum_members_conv = [enum_value_to_scpi_string(x) for x in enum_members]
-	ix = _find_in_enum_members(value, enum_members_conv)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
+	array_search signal no need to force the comma removing,
+	because the elements definitely do not have any commas - commas have been used to split string to the list of strings
+	The function can also return:
+	- integer special value, if the string was not found in the enum, and it is a special value.
+	- input string, if the string was not found and raise_if_not_found is set to False - used for the EnumExt types."""
+	if scpi_enum.has_quotes:
+		value = Utilities.trim_str_response(string, mode=Utilities.TrimStringMode.white_chars_double_quotes)
+	else:
+		value = Utilities.trim_str_response(string)
+	enum_value = scpi_enum.find_in_enum_members(value, False)
+	if enum_value is not None:
+		return enum_value
+	if array_search is False:
+		# If the result is still -1 (not found), try to force removing the comma in the string.
+		enum_value = scpi_enum.find_in_enum_members(value, True)
+		if enum_value is not None:
+			return enum_value
 	# If not found, search in the special integer numbers:
 	spec_value = str_special_values_to_int(value)
-	if not spec_value:
-		raise Exception(f"String '{value}' can not be found in the enum type '{enum_type}'")
+	if spec_value:
+		# noinspection PyTypeChecker
+		return spec_value
+	if exc_if_not_found:
+		raise RsInstrException(f"String '{value}' can not be found in the enum type '{scpi_enum.enum_type}'")
 	# noinspection PyTypeChecker
-	return spec_value
+	return Utilities.trim_str_response(string)
 
 
-def str_to_list_enum_helper(string: str, enum_type: Enum, enum_members=None) -> List[Enum]:
-	"""Converts string to list of enum elements.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
+def str_to_simple_scalar_enum(string: str, enum_type, case_sensitive: bool = True, ignore_underscores: bool = False) -> Enum or None:
+	"""Converts string to one enum element.
+	Does not handle special value or non-mandatory parts.
+	The function is used in core only for standard enum conversions, not for SCPI enum conversions."""
+	value = Utilities.trim_str_response(string)
+	enum_members = [x.name for x in enum_type]
+	enum_members_mod = [x.name for x in enum_type]
+	if not case_sensitive:
+		enum_members_mod = [x.upper() for x in enum_members]
+		value = value.upper()
+	if ignore_underscores:
+		enum_members_mod = [x.replace('_', '') for x in enum_members_mod]
+		value = value.replace('_', '')
+	if value in enum_members_mod:
+		return enum_type[enum_members[enum_members_mod.index(value)]]
+	return None
+
+
+def str_to_list_enum_helper(string: str, scpi_enum: ScpiEnum, exc_if_not_found: bool = True) -> List[Enum]:
+	"""Converts string to list of enum elements. separated by comma"""
 	elements = string.split(',')
-	return [str_to_scalar_enum_helper(x, enum_type, enum_members) for x in elements]
+	return [str_to_scalar_enum_helper(x, scpi_enum, True, exc_if_not_found) for x in elements]
 
 
 def enum_scalar_to_str(data, enum_type) -> str:
 	"""Converts enum scalar value to string."""
 	assert isinstance(data, enum_type), f"Expected command parameter {enum_type}, actual data type: {type(data)}. Value: {data}"
 	return value_to_str(data)
 
 
+def enum_ext_scalar_to_str(data, enum_type) -> str:
+	"""Converts enum scalar value to string.
+	If the input value is string, the function returns the string with single quotes."""
+	if isinstance(data, str):
+		# Return string with quotes
+		return value_to_quoted_str(Utilities.trim_str_response(data))
+	assert isinstance(data, enum_type), f"Expected command parameter string or {enum_type}, actual data type: {type(data)}. Value: {data}"
+	return value_to_str(data)
+
+
 def enum_list_to_str(data: List, enum_type) -> str:
 	"""Converts enum list to csv-string."""
 	# For enums, check that each element is an enum
 	assert all(isinstance(x, enum_type) for x in data), f"Expected command parameter list of {enum_type}, detected one or more elements of non-enum type. Value: {data}"
 	return list_to_csv_str(data)
 
 
+def enum_ext_list_to_str(data: List, enum_type) -> str:
+	"""Converts enum list to csv-string. Allows the elements to be either enum or string."""
+	assert all((isinstance(x, enum_type or str) or isinstance(x, str)) for x in data), f"Expected command parameter list of strings or {enum_type}, detected one or more elements of non-enum/non-string type. Value: {data}"
+	return list_to_csv_quoted_str(data)
+
+
 def str_to_scalar_enum(string: str, enum_type) -> Enum:
-	"""Converts string to one enum element."""
-	return str_to_scalar_enum_helper(string, enum_type)
+	"""Converts string to one enum element.
+	Throws exception if the string can not be converted to an enum element or a special value."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=True)
+
+
+def str_to_scalar_enum_ext(string: str, enum_type) -> Enum:
+	"""Converts string to one enum element.
+	Compared to str_to_scalar_enum, in case the string can not be converted, it is returned trimmed for quotes and ."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=False)
 
 
 def str_to_list_enum(string: str, enum_type) -> List[Enum]:
 	"""Converts string to list of enum elements."""
-	return str_to_list_enum_helper(string, enum_type)
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type))
+
+
+def str_to_list_enum_ext(string: str, enum_type) -> List[Enum]:
+	"""Converts string to list of enum or string elements."""
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type), exc_if_not_found=False)
+
+
+def convert_ts_to_datetime(timestamp: datetime or float) -> datetime:
+	"""Converts timestamp as float to datetime. For datetime tuple it just passes the value."""
+	if isinstance(timestamp, float) or isinstance(timestamp, int):
+		return datetime.fromtimestamp(timestamp)
+	return timestamp
+
+
+def get_timestamp_string(timestamp: datetime or float) -> str:
+	"""Returns the timestamp as string. The timestamp can be a datetime tuple or float seconds coming from the time.time()."""
+	timestamp = convert_ts_to_datetime(timestamp)
+	cur_time = timestamp.strftime('%H:%M:%S.%f')[:-3]
+	return cur_time
+
+
+def get_timedelta_fixed_string(time_start: datetime or float, time_end: datetime or float) -> str:
+	"""Returns the time span as string - fixed in the format of '%H:%M:%S.%f'."""
+	time_a = convert_ts_to_datetime(time_start)
+	time_b = convert_ts_to_datetime(time_end)
+	frac = (time_b - time_a).total_seconds()
+	wh = math.floor(frac)
+	d = int(wh / 86400)
+	h = int((wh - (d * 86400)) / 3600)
+	m = int((wh - (d * 86400 + h * 3600)) / 60)
+	s = int((wh - (d * 86400 + h * 3600 + m * 60)))
+	ms = int((frac - wh) * 1000)
+	res = f'{h:02d}:{m:02d}:{s:02d}.{ms:03d}'
+	if d > 0:
+		res = f'{d}d ' + res
+	return res
+
+
+def get_timedelta_string(time_a: datetime or float, time_b: datetime or float) -> str:
+	"""Returns the time span as string - dynamic based on the difference."""
+	time_a = convert_ts_to_datetime(time_a)
+	time_b = convert_ts_to_datetime(time_b)
+	if time_b < time_a:
+		return '0.000 ms'
+	diff = time_b - time_a
+	if diff.seconds < 10:
+		return f'{diff.total_seconds() * 1000:0.3f} ms'
+	elif diff.seconds < 1000:
+		a = diff.total_seconds()
+		return f'{a:0.3f} secs'
+	hours, remainder = divmod(diff.seconds, 3600)
+	minutes, seconds = divmod(remainder, 60)
+	return f'{hours:02d}:{minutes:02d}:{seconds:02d}'
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ConverterFromScpiString.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ConverterFromScpiString.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,32 @@
+"""See the class docstring."""
+
 from enum import Enum
 
 from .Conversions import str_to_bool, str_to_int, str_to_int_or_bool, str_to_float, str_to_float_or_bool, str_to_scalar_enum_helper
 from .Conversions import str_to_str_list, str_to_bool_list, str_to_int_list, str_to_int_or_bool_list, str_to_float_list, str_to_float_or_bool_list, str_to_list_enum_helper
 from .Types import DataType
 from .Utilities import trim_str_response
+from .InstrumentErrors import RsInstrException
+from .ScpiEnums import ScpiEnum
 
 
 class ConverterFromScpiString:
 	"""Converter from SCPI response string to argument value
 	For list argument types, you must use the method get_one_element_value in a loop for each element.
 	Provides methods:
 	- get_one_element_value(str): returns one scalar value converted from the SCPI string.
 	- get_list_value(str): return complete list value converted from the SCPI string.
 	- get_value(str): calls either get_one_element_value or get_list_value() depending on the data type. \n
 	The reason for the different methods is, that sometimes the list data are interleaved with other arguments.
 	In order to parse them properly, the ArgStructStringParser module must be able to set the argument value element-by-element.
-	On the other side, the driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
+	The driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
-		self.enum_type = enum_type
+		self.scpi_enum = None
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
 
 		if self.element_type == DataType.RawString:
 			self.converter = trim_str_response
 			self.list_converter = str_to_str_list
 
@@ -46,30 +50,29 @@
 			self.converter = str_to_float
 			self.list_converter = str_to_float_list
 
 		elif self.element_type == DataType.FloatExt:
 			self.converter = str_to_float_or_bool
 			self.list_converter = str_to_float_or_bool_list
 
-		elif self.element_type == DataType.Enum:
-			assert self.enum_type, f"For data type enum, you have to define the enum_type variable."
+		elif self.element_type.is_scalar_enum:
+			assert enum_type, f"For data type enum, you have to define the enum_type variable."
 			# noinspection PyTypeChecker
-			self.enum_members = [x.name for x in self.enum_type]
+			self.scpi_enum = ScpiEnum(enum_type)
 		else:
-			raise Exception(f"Unsupported data type '{data_type}'")
+			raise RsInstrException(f"Unsupported data type '{data_type}'")
 
 	def get_one_element_value(self, scpi_string: str):
-		"""Returns single element !!! of the argument value converted from the SCPI string (single element)"""
+		"""Returns single element (not an array!!!) of the argument value converted from the SCPI string (single element)"""
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
-		if self.element_type is DataType.Enum:
-			return str_to_scalar_enum_helper(scpi_string, self.enum_type, self.enum_members)
+		if self.element_type.is_scalar_enum:
+			return str_to_scalar_enum_helper(scpi_string, self.scpi_enum, False, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.converter(scpi_string)
 
 	def get_value(self, scpi_string: str):
 		"""Returns complete value of the argument converted from the SCPI string (list or scalar)"""
 		if not self.data_type.is_list:
 			return self.get_one_element_value(scpi_string)
-
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
 		if self.element_type is DataType.Enum:
-			return str_to_list_enum_helper(scpi_string, self.enum_type, self.enum_members)
+			return str_to_list_enum_helper(scpi_string, self.scpi_enum, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.list_converter(scpi_string)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/ConverterToScpiString.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/ConverterToScpiString.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
+"""See the class docstring."""
+
 from enum import Enum
 
-from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str
+from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str, enum_ext_scalar_to_str, enum_ext_list_to_str
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
-def value_to_scpi_string(data, data_type: DataType):
-	"""Method to be used in the driver implementation.
-	Convert data to SCPI string parameter: data -> str"""
+def value_to_scpi_string(data, data_type: DataType) -> str:
+	"""Convert data to SCPI string parameter: data -> str.
+	Does not work with enum data types."""
 	if data_type.is_list:
 		assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 	else:
 		assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
 	# Strings are enclosed by single quotes
 	if data_type == DataType.StringList:
 		assert all(isinstance(x, str) for x in data), f"Expected command parameter list of strings, detected one or more elements of non-string type. Value: {data}"
@@ -46,35 +49,37 @@
 	elif data_type == DataType.IntegerExtList or data_type == DataType.FloatExtList:
 		assert all((isinstance(x, int) or isinstance(x, float) or isinstance(x, bool)) for x in data), f"Expected command parameter list of numbers or booleans, detected one or more elements of non-number type. Value: {data}"
 		return list_to_csv_str(data)
 	elif data_type == DataType.IntegerExt or data_type == DataType.FloatExt:
 		assert (isinstance(data, int) or isinstance(data, float) or isinstance(data, bool)), f"Expected command parameter number or boolean, actual data type: {type(data)}. Value: {data}"
 		return value_to_str(data)
 	else:
-		raise Exception(f"Unsupported data type: '{type(data_type)}'.")
+		raise RsInstrException(f"Unsupported data type: '{type(data_type)}'.")
 
 
 class ConverterToScpiString:
 	"""Converter from argument value to SCPI string.
 	Provides method get_value(arg_value) -> str
 	"""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
 		self.enum_type = enum_type
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
-		if self.element_type == DataType.Enum:
+		if self.element_type == DataType.Enum or self.element_type == DataType.EnumExt:
 			assert self.enum_type, f"For data_type {data_type.name}, you have to define the enum_type variable."
 
 	def get_value(self, data) -> str:
 		"""Returns SCPI string converted from the argument data."""
 		if self.data_type.is_list:
 			assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 		else:
 			assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
-
 		if self.data_type == DataType.Enum:
 			return enum_scalar_to_str(data, self.enum_type)
-		elif self.data_type == DataType.EnumList:
+		if self.data_type == DataType.EnumExt:
+			return enum_ext_scalar_to_str(data, self.enum_type)
+		if self.data_type == DataType.EnumList:
 			return enum_list_to_str(data, self.enum_type)
-
+		if self.data_type == DataType.EnumExtList:
+			return enum_ext_list_to_str(data, self.enum_type)
 		return value_to_scpi_string(data, self.data_type)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Core.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Core.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,28 +1,126 @@
-import re
+"""See the class docstring."""
+
 from typing import Callable
 
-from . import InstrumentOptions as Options, Conversions as Conv
+from . import InstrumentOptions as Options
 from .ArgSingle import ArgSingle
 from .ArgSingleList import ArgSingleList
 from .Conversions import BinFloatFormat, BinIntFormat
 from .Instrument import Instrument
-from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode
-from .Utilities import parse_token_to_key_and_value, trim_str_response
+from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode, OpcSyncQueryMechanism
+from .ScpiLogger import LoggingMode
+from .InstrumentErrors import RsInstrException
+from .Properties import Properties
 
 
 class Core(object):
 	"""Main driver component. Provides: \n
 		- Main core constructor
 		- 'io' interface for all the write / query operations
 		- Command parameters string composer for single arguments...
 		- Link handlers adding / changing / deleting
 
 		Version history:
 
+		1.70.0 (27.02.2024)
+			- Added settings profile 'XK41' for R&S Software Defined Radios.
+			- Added settings 'FirstCmds' where you can send the defined commands right after the init. Send more commands in a row with ';;' separator.
+			- Added settings 'EachCmdPrefix' - this prefix is added to each command sent to the instrument. Supported values are also 'lf', 'cr', 'tab'
+
+		1.60.0 (31.01.2024)
+			- Added Properties script for global properties.
+			- Added Properties.scpi_quotes, string option settings token: 'ScpiQuotes'. Example: ScpiQuotes=double. Default: Single
+			- Fixed VisaPluginSocketIo read() method for cases where the session is lost. The method now generates exception in that case.
+			- Added settings 'OpcSyncQueryMechanism' with values: Standard, AlsoCheckMav, ClsOnlyCheckMavErrQueue, OnlyCheckMavErrQueue
+
+		1.54.0 (27.06.2023)
+			- Added new options profile for ATS chambers.
+			- Added settings boolean token EachCmdAsQuery. Example: EachCmdAsQuery=True. Default: False
+
+		1.53.0 (18.10.2022)
+			- Improved mode where the instrument works with a session from another object.
+			- Silently ignoring invalid *IDN? string.
+			- Added new options profile 'Minimal' for non-SCPI-99 instruments.
+
+		1.52.0 (28.09.2022)
+			- Fixed DisableOpcQuery=True settings effect.
+			- Improved robustness of the TerminationCharacter option value entry.
+			- Added new options profile for CMQ500.
+
+		1.51.0 (08.09.2022)
+			- Changed the accepted IDN? response to more permissive.
+			- added methods go_to_remote() and go_to_local()
+			- added methods file_exists() and get_file_size()
+
+		1.50.0 (23.06.2022)
+			- Added relative timestamp to the logger.
+			- ScpiLogger can read GlobalData class variables making it possible to define common target and reference timestamp for all instances.
+			- Logger stream entries are by default immediately flushed, making sure that the log is complete.
+			- Added time statistic methods get_total_execution_time(), get_total_time(), reset_time_statistics().
+
+		1.24.0 (03.06.2022)
+			- Changed parsing of SYST:ERR? response to tolerate +0,"No Error" response.
+			- Added settings integer token OpenTimeout. Example: OpenTimeout=5000. Default: 0
+			- Added settings boolean token ExclusiveLock. Example: ExclusiveLock=True. Default: False
+
+		1.23.0 (24.05.2022)
+			- Added stripping of trailing commas when parsing the *IDN? response.
+			- If the Resource Manager does not find any default VISA implementation, it falls back to R&S VISA - relevant for LINUX or macOS
+			- Other typos and formatting corrections.
+
+		1.22.0 (20.04.2022)
+			- Added optional parameter timeout to reset()
+			- Added query list methods:  query_bool_list, query_bool_list_with_opc
+
+		1.21.0 (07.01.2022)
+			- Added logging to UDP port (49200) to integrate with new R&S Instrument Control plugin for Pycharm
+
+		1.20.0 (19.11.2021)
+			- Fixed logging strings when device name was a substring of the resource name
+
+		1.18.0 (build 64) 05.11.2021
+			- Added setting profile for non-standard instruments. Example of the options string: options='Profile=hm8123'
+
+		1.17.0 (build 63) 15.10.2021
+			- Added correct conversion of strings with SI suffixes (e.g.: MHz, KHz, THz, GHz, ms, us) to float and integer
+
+		1.16.0 (build 62) 31.08.2021
+			- Changed default encoding of string<=>bin from utf-8 to charmap.
+			- Added settable encoding for the session. Property: RsInstrument.encoding
+
+		1.15.0 (build 61) 17.08.2021
+			- Added support for EnumExt and EnumExtList
+			- Added support for custom scpi enums
+			- Improved exception handling in cases where the instrument session is closed.
+			- Fixed warning in Instrument.py
+			- Fixed Instrument.query_bin_block() for timeout errors
+			- Repeated capabilities are now allowed to be integer numbers as well
+
+		1.14.0 (build 53) 12.07.2021
+			- Scpi logger time entries now support not only datetime tuples, but also float timestamps
+			- changed handling of the syst:err? responses - now they are always Tuple (code, message)
+			- StatusException has new field errors_list: List[ Tuple[code, message] ]
+			- Added logger.log_status_check_ok property. This allows for skipping lines with 'Status check: OK'
+
+		1.12.0 (build 50) 26.06.2021
+			- Added SCPI Logger
+			- Simplified constructor's options string format - removed DriverSetup=() syntax:
+			Instead of "DriverSetup=(TerminationCharacter='\n')", you use "TerminationCharacter='\n'"
+			The original format is still supported.
+
+			- Fixed calling SYST:ERR? even if *STB? returned 0
+			- Replaced @ni backend with @ivi for resource manager - this is necessary for the future pyvisa version 1.12+
+
+		1.11.0 (build 49) 09.06.2021
+			- Added is_connection_active() + reconnect()
+
+		1.10.1 (build 47) 01.06.2021
+			- Fixed bug with error checking when events are defined
+
 		1.10.0 (build 46) 03.05.2021
 			- Added methods to Instrument: query_struct_with_opc(), query_str_suppressed_with_opc()
 
 		1.9.0 (build 45) 13.04.2021
 			- Added option to set callbacks before_write and before_query
 			- When a RepCap has a member with integer number 0 defined, the command string interpretation of such member is '0', not empty string
 
@@ -32,15 +130,15 @@
 		1.7.7 (build 42) 26.11.2020
 			- Extended ArgSingleList.compose_cmd_string() to 9 arguments
 
 		1.7.6 (build 41) 23.11.2020
 			- Extended data types for IntegerExt, FloatExt, IntegerExtArray, FloatExtArray
 
 		1.7.5 (build 40) 12.11.2020
-			- Extended Conversions method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
+			- Extended 'Conversions' method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
 
 		1.7.4 (build 39) 11.09.2020
 			- Fixed parsing of the instrument errors when an error message contains two double quotes
 
 		1.7.3 (build 38) 21.10.2020
 			- Added 'UND' to the list of float numbers that are represented as NaN
 
@@ -60,15 +158,15 @@
 
 		1.4.0 (build 32) 17.09.2020
 			- Added recognition of RsVisa library location for linux when using options string 'SelectVisa=rs'
 			- Fixed bug in reading binary data 16 bit
 
 		1.3.0 (build 31) 04.09.2020
 			- added DRIVERSETUP_QUERYOPT to the driver's option string
-			- *OPT? is no longer performed at the init, but only at the first access to options string.
+			- *OPT? is no longer performed at the init, but only at the first access to the options string.
 				In addition, the *OPT? query is executed with 1000 ms timeout, and the errors are suppressed
 
 		1.2.0 (build 30), 03.08.2020
 			- Fixed NRP-Z session parameters: vxi_capable = False, io_segment_size = 1000000
 
 		1.1.0 (build 29), 20.06.2020
 			- Added RepeatedCapability and base class CommandsGroup
@@ -89,85 +187,94 @@
 			reset: bool = False,
 			driver_options: str = None,
 			user_options: str = None,
 			direct_session: object = None):
 		"""Initializes new driver session. For cleaner code, use the class methods: \n
 		- Core.from_existing_session() - initializes a new Core with an existing pyvisa session."""
 
-		self.core_version = '1.9.0'
-		self.simulating = False
-		self.supported_idn_patterns = []
-		self.supported_instr_models = []
-
-		self._args_single_list = ArgSingleList()
-		sett_dr = self._parse_init_settings_string(driver_options)
-		self._apply_settings_to_core(sett_dr)
-		sett_user = self._parse_init_settings_string(user_options)
-		self._apply_settings_to_core(sett_user)
+		self.core_version = '1.55.0'
+		self.resource_name = resource_name
 
 		# Typical settings for the Core
 		self._instrumentSettings = InstrumentSettings(
 			InstrViClearMode.execute_on_all,  # Instrument viClear mode
 			False,  # Full model name. True: SMW200A, False: SMW
 			0,  # Delay by each write
 			0,  # Delay by each read
-			100000,  # Max chunk read / write size in bytes
+			1000000,  # Max chunk read / write size in bytes
 			WaitForOpcMode.stb_poll,  # Waiting for OPC Mode: Status byte polling
 			30000,  # OPC timeout
 			10000,  # VISA timeout
 			60000,  # Self-test timeout
 			Options.ParseMode.Auto,  # *OPT? response parsing mode
 			BinFloatFormat.Single_4bytes,  # Format for parsing of binary float numbers
 			BinIntFormat.Integer32_4bytes,  # Format for parsing of binary integer numbers
-			False  # OPC query after each setting
+			False,  # OPC query after each setting
+			LoggingMode.Off,
+			OpcSyncQueryMechanism.only_check_mav_err_queue
+			# Logging mode
 		)
 
-		self._instrumentSettings.apply_option_settings(sett_dr)
-		self._instrumentSettings.apply_option_settings(sett_user)
+		self._instrumentSettings.apply_option_settings(driver_options)
+		self._instrumentSettings.apply_option_settings(user_options)
 
-		# Resolve the direct_session to handle. Options for direct_session type:
-		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
-		# - string in case of a simulation session
-		handle = direct_session
-		if handle:
-			# Check if the entered 'direct_session' is either the driver object or the Visa session
-			if hasattr(direct_session, 'get_session_handle'):
-				assert hasattr(direct_session, '_core'), f"Direct session is a class type. It must be an instance of the top-level driver class."
-				handle = direct_session.get_session_handle()
-			# Check if the handle is not a simulation mode string
-			if isinstance(handle, str):
-				if "Simulating session, resource name " in handle:
-					self.simulating = True
-					handle = None
+		self.simulating = self._instrumentSettings.simulating
+		self.supported_idn_patterns = self._instrumentSettings.supported_idn_patterns
+		self.supported_instr_models = self._instrumentSettings.supported_instr_models
 
-		self.io = Instrument(resource_name, self.simulating, self._instrumentSettings, handle)
+		self._args_single_list = ArgSingleList()
+		handle = self._resolve_direct_session(direct_session)
+		self.io = Instrument(self.resource_name, self.simulating, self._instrumentSettings, handle)
 		self.io.query_instr_status = True
+		# Update the resource name if it changed, for example because of the direct session
+		self.resource_name = self.io.resource_name
+		self.allow_reconnect = self.io.allow_reconnect
 
-		self._apply_settings_to_instrument(sett_dr)
-		self._apply_settings_to_instrument(sett_user)
-
+		self._apply_settings_to_instrument(self._instrumentSettings)
+		self._apply_global_properties(self._instrumentSettings)
 		self.io.set_simulating_cmds()
 
 		if id_query:
 			self.io.fits_idn_pattern(self.supported_idn_patterns, self.supported_instr_models)
 
 		if reset:
 			self.io.reset()
 		else:
 			self.io.check_status()
 
 	@classmethod
 	def from_existing_session(cls, session: object, driver_options: str = None) -> 'Core':
 		"""Creates a new Core object with the entered 'session' reused."""
 		# noinspection PyTypeChecker
-		return cls(None, False, False, driver_options, None, session)
+		return cls(resource_name=None, id_query=False, reset=False, driver_options=driver_options, user_options=None, direct_session=session)
 
 	def __str__(self):
 		return f"Core session '{self.io.resource_name}'"
 
+	def _resolve_direct_session(self, direct_session):
+		# Resolve the direct_session to handle. Options for direct_session type:
+		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
+		# - string in case of a simulation session
+		handle = direct_session
+		if not direct_session:
+			return None
+		# Check if the entered 'direct_session' is either the driver object or the Visa session
+		if hasattr(direct_session, 'get_session_handle'):
+			if not hasattr(direct_session, '_core'):
+				raise RsInstrException('Direct session is a class type. It must be an instance of the top-level driver class.')
+			handle = direct_session.get_session_handle()
+		# If the handle is a simulating session, change the session to simulating and set disable the 'from existing session' feature
+		if isinstance(handle, str):
+			mand_string = 'Simulating session, resource name '
+			if mand_string in handle:
+				self.resource_name = handle[len(mand_string):].strip().strip("'").strip()
+				self.simulating = True
+				handle = None
+		return handle
+
 	def set_link_handler(self, link_name: str, handler: Callable) -> Callable:
 		"""Adds / Updates link handler for the entered link_name.
 		Handler API: handler(event_args: ArgLinkedEventArgs)
 		Returns the previous registered handler, or None if no handler was registered before."""
 		return self.io.set_link_handler(link_name, handler)
 
 	def del_link_handler(self, link_name: str) -> Callable:
@@ -176,82 +283,30 @@
 		return self.io.del_link_handler(link_name)
 
 	def del_all_link_handlers(self) -> int:
 		"""Deletes all the link handlers.
 		Returns number of deleted links."""
 		return self.io.del_all_link_handlers()
 
-	# noinspection PyMethodMayBeStatic
-	def _parse_init_settings_string(self, text: str) -> dict:
-		"""Parses init string to a dictionary of settings: name -> value."""
-		tokens = {}
-		if not text:
-			return tokens
-
-		# Text enclosed in single brackets '' must have the commas escaped
-		literal_pattern = r"'([^']+)'"
-		while True:
-			# literal loop
-			m = re.search(literal_pattern, text)
-			if not m:
-				break
-			lit_part = '"' + m.group(1).replace(',', '<COMMA_ESC>') + '"'
-			text = text.replace(m.group(0), lit_part)
-
-		# Remove all the class-options enclosed by round brackets e.g. "<groupName>=(<groupTokens>)"
-		group_pattern = r'(\w+)\s*=\s*\(([^\)]*)\)'
-		# Match class-settings, add them as separate keys with groupName_Key
-		while True:
-			# Group loop
-			m = re.search(group_pattern, text)
-			if not m:
-				break
-			text = text.replace(m.group(0), '')
-			group_name = m.group(1).upper()
-			group_tokens = m.group(2).strip().split(',')
-			for token in group_tokens:
-				key, value = parse_token_to_key_and_value(token)
-				if value:
-					tokens[f'{group_name}_{key.upper()}'] = value
-
-		# All groups are removed from the text, now we can use splitting on commas and remove white-space-only elements
-		for token in text.split(','):
-			key, value = parse_token_to_key_and_value(token.replace('<COMMA_ESC>', ','))
-			if value:
-				tokens[key.upper()] = value
-		return tokens
-
-	def _apply_settings_to_core(self, settings: dict) -> None:
-		"""Applies settings relevant for the Core from the dictionary."""
-		value = settings.get('SIMULATE')
-		if value:
-			self.simulating = Conv.str_to_bool(value)
-
-		value = settings.get('SUPPORTEDINSTRMODELS')
-		if value:
-			self.supported_instr_models = [*map(trim_str_response, value.split('/'))]
-
-		value = settings.get('SUPPORTEDIDNPATTERNS')
-		if value:
-			self.supported_idn_patterns = [*map(trim_str_response, value.split('/'))]
-
-	def _apply_settings_to_instrument(self, settings: dict) -> None:
-		"""Applies settings relevant for the Instrument from the dictionary."""
-		value = settings.get('QUERYINSTRUMENTSTATUS')
-		if value:
-			self.io.query_instr_status = Conv.str_to_bool(value)
-
-		value = settings.get('SIMULATIONIDNSTRING')
-		if value and self.simulating:
-			# Use the '*' instead of the ',' in the value to avoid comma as token delimiter
-			self.io.idn_string = value.replace('*', ',')
+	def _apply_settings_to_instrument(self, settings: InstrumentSettings) -> None:
+		"""Applies settings relevant for the Instrument from the InstrumentSettings structure."""
+		if settings.instrument_status_check is not None:
+			self.io.query_instr_status = settings.instrument_status_check
+		if self.simulating and settings.instrument_simulation_idn_string is not None:
+			self.io.idn_string = settings.instrument_simulation_idn_string
+
+	@staticmethod
+	def _apply_global_properties(settings: InstrumentSettings) -> None:
+		"""Applies settings valid for the entire module. All are available in the module 'Properties'."""
+		if settings.scpi_quotes is not None:
+			Properties.scpi_quotes = settings.scpi_quotes
 
 	def compose_cmd_arg_param(
 			self, arg1: ArgSingle, arg2: ArgSingle = None, arg3: ArgSingle = None, arg4: ArgSingle = None, arg5: ArgSingle = None, arg6: ArgSingle = None) -> str:
-		"""Composes command parameter string based on the single arguments definition."""
+		"""Composes command parameter string based on the single argument definition."""
 		return self._args_single_list.compose_cmd_string(arg1, arg2, arg3, arg4, arg5, arg6)
 
 	def get_last_sent_cmd(self) -> str:
 		"""Returns the last commands sent to the instrument. Only works in simulation mode"""
 		return self.io.get_last_sent_cmd()
 
 	def get_session_handle(self):
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InstrumentErrors.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InstrumentErrors.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,63 +1,79 @@
+"""Definition of RsInstrument exceptions, assert functions, and other error-related functions."""
+
+from typing import List, Tuple
+
+
 class RsInstrException(Exception):
 	"""Exception base class for all the RsInstrument exceptions."""
 	def __init__(self, message: str):
 		super(RsInstrException, self).__init__(message)
+		self.message = message
 
 
 class TimeoutException(RsInstrException):
 	"""Exception for timeout errors."""
 	def __init__(self, message: str):
 		super(TimeoutException, self).__init__(message)
 
 
 class StatusException(RsInstrException):
-	"""Exception for instrument status errors."""
-	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+	"""Exception for instrument status errors.
+	Tje field  errors_list contains the complete list of all the errors with messages and codes."""
+	def __init__(self, rsrc_name: str, message: str, errors_list: List[Tuple[int, str]], first_exc: Exception = None):
+		self.rsrc_name: str = rsrc_name
+		self.first_exc: Exception = first_exc
+		self.errors_list: List[Tuple[int, str]] = errors_list
 		super(StatusException, self).__init__(message)
 
 
 class UnexpectedResponseException(RsInstrException):
 	"""Exception for instrument unexpected responses."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(UnexpectedResponseException, self).__init__(message)
 
 
 class ResourceError(RsInstrException):
 	"""Exception for resource name - e.g. resource not found."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(ResourceError, self).__init__(message)
 
 
 class DriverValueError(RsInstrException):
 	"""Exception for different driver value settings e.g. RepCap values or Enum values."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(DriverValueError, self).__init__(message)
 
 
-def assert_no_instrument_status_errors(rsrc_name: str, errors: list, context: str = '') -> None:
-	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
-	if errors is None:
-		return
-	if len(errors) == 0:
+def get_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '') -> str or None:
+	"""Checks the errors list and of it contains at least one element, it returns the error message.
+	Otherwise, it returns None."""
+	if errors is None or len(errors) == 0:
 		return
 	if context:
 		message = f"'{rsrc_name}': {context} "
 	else:
 		message = f"'{rsrc_name}': "
+	errors_msg = '\n'.join([f'{x[0]},"{x[1]}"' for x in errors])
 	if len(errors) == 1:
-		message += f'Instrument error detected: {errors[0]}'
-		raise StatusException(rsrc_name, message)
+		message += f'Instrument error detected: {errors_msg}'
+		return message
 	if len(errors) > 1:
-		message += '{} Instrument errors detected:\n{}'.format(len(errors), '\n'.join(errors))
-		raise StatusException(rsrc_name, message)
+		message += f'{len(errors)} Instrument errors detected:\n{errors_msg}'
+		return message
+
+
+def assert_no_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '', first_exc=None) -> None:
+	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
+	msg = get_instrument_status_errors(rsrc_name, errors, context)
+	if msg:
+		raise StatusException(rsrc_name, msg, errors, first_exc=first_exc)
 
 
 def throw_opc_tout_exception(opc_tout: int, used_tout: int, context: str = '') -> None:
 	"""Throws TimeoutException - use it for any timeout error."""
 	if not context:
 		message = ''
 	else:
@@ -83,21 +99,21 @@
 
 def assert_query_has_qmark(query: str, context: str = '') -> None:
 	"""Throws Exception if the query does not contain any question marks."""
 	if '?' in query:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Query commands must contain question-marks. Sent query: '{0}'".format(query.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
 
 
 def assert_cmd_has_no_qmark(command: str, context: str = '') -> None:
 	"""Throws Exception if the query contains a question marks."""
 	if '?' not in command:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Set commands must not contain question-marks. Sent command: '{0}'".format(command.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InstrumentOptions.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InstrumentOptions.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 import re
 from enum import Enum
 
 from .Utilities import trim_str_response
 
 
 class ParseMode(Enum):
@@ -10,14 +12,15 @@
 	KeepOriginal = 1
 	KeepBeforeDash = 2
 	KeepAfterDash = 3
 	Auto = 4
 
 
 class Options(object):
+	"""Class for handling the instrument options - parsing from the *OPT? string and providing method get_all()"""
 	_optionsList = []
 
 	def __init__(self, options_str: str, mode=ParseMode.Auto):
 		"""Initializes the options with the *OPT? return string."""
 		self._initialize_from_string(options_str, mode)
 
 	def __str__(self):
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/InternalLinker.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/InternalLinker.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,16 @@
+"""Links a variable from a structure to a callback in the driver."""
+
 from time import time
 from typing import Dict, Callable
 
 from . import ArgSingle, ArgSingleSuppressed
 from .ArgLinkedEventArgs import ArgLinkedEventArgs
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class InternalLinker(object):
 	"""Class for:
 		- cutting out suppressed arguments from a device response.
 		- invoking a handler if the argument has InternalLinking defined.
 		- holds dictionary of handlers where the dict_key is the InternalLinking string.
@@ -44,22 +47,22 @@
 		Returns number of deleted links."""
 		count = len(self._handlers)
 		self._handlers = {}
 		return count
 
 	def cut_from_response_string(self, arg: ArgSingleSuppressed, response: str, context: str) -> str:
 		"""Takes the string 'response', removes the suppressed argument value from it and returns the rest.
-		The cut out part is sent via handler if the internal linking exists for that argument exists."""
+		The cut-out part is sent via handler if the internal linking exists for that argument exists."""
 		result = ''
 		if arg.argument_ix is None:
-			raise Exception(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
+			raise RsInstrException(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
 		if arg.argument_ix != 0:
-			raise Exception(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
 		if arg.is_open_list:
-			raise Exception(f'Open List arguments can not be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Open List arguments can not be suppressed. Argument: {arg}')
 		repetition = 0
 		i = 0
 		for c in response:
 			if c == ',':
 				repetition += 1
 			if repetition == arg.repetition:
 				break
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/IoTransferEventArgs.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/IoTransferEventArgs.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the IoTransferEventArgs class."""
+
 import itertools
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
 
 
 class IoTransferEventArgs(object):
@@ -48,25 +50,25 @@
 		return cls(True, opc_sync, None, context)
 
 	@classmethod
 	def write_str(cls, opc_sync: bool, total_size: int, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of write string \n
 		:param opc_sync: defines if the command is OPC-synchronised
 		:param total_size: size of the data to write
-		:param context: SCPI command write. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write string operation."""
+		:param context: SCPI command write. It is truncated to maximum of 100 characters
+		:return: IoTransferEventArgs object of a write-string operation."""
 		obj = cls(False, opc_sync, total_size, context)
 		obj.binary = False
 		return obj
 
 	@classmethod
 	def write_bin(cls, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of read binary data \n
 		:param context: SCPI command. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write binary data operation."""
+		:return: IoTransferEventArgs object of a write-binary-data operation."""
 		# noinspection PyTypeChecker
 		obj = cls(False, False, None, context.rstrip())
 		obj.binary = True
 		return obj
 
 	def __str__(self):
 		if self.binary:
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/RepeatedCapability.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/RepeatedCapability.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the RepeatedCapability class."""
+
 from enum import Enum
 
 
 # Command integer value that signals Default value "DEFAULT"
 VALUE_DEFAULT = -1
 
 # Command integer value that signals "EMPTY"
@@ -26,39 +28,47 @@
 	def __str__(self) -> str:
 		out = f'RepCap {self.name}'
 		if self._enum_value is not None:
 			out += f" = {self._enum_value}"
 		return out
 
 	@classmethod
-	def clsm_assert_type(cls, enum_value: Enum, enum_type) -> None:
-		"""Static assertion function to check if the entered value is a member of the defined repcap enum"""
+	def clsm_assert_type(cls, enum_value: Enum or int, enum_type) -> None:
+		"""Static assertion function to check if the entered value is a member of the defined repcap enum.
+		In addition, the integer value is also supported."""
+		if isinstance(enum_value, int):
+			return
 		if not isinstance(enum_value, enum_type):
 			raise TypeError(f"RepCap value must be of type '{enum_type}'. Entered value type: {type(enum_value)}, value '{enum_value}'")
 
 	@classmethod
-	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum, enum_type) -> int:
+	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum or int, enum_type) -> int:
 		"""Static function to get an integer interpretation of a direct enum value
 		Does not work with Empty or Default"""
 		RepeatedCapability.clsm_assert_type(enum_value, enum_type)
+		if isinstance(enum_value, int):
+			return enum_value
 		return enum_value.value
 
 	@classmethod
-	def clsm_is_default_value(cls, enum_value: Enum, enum_type) -> bool:
+	def clsm_is_default_value(cls, enum_value: Enum or int, enum_type) -> bool:
 		"""Returns True, if the entered value is enum.Default"""
 		return cls.clsm_get_direct_cmd_value_int(enum_value, enum_type) == VALUE_DEFAULT
 
 	def is_default_value(self) -> bool:
 		"""Returns True, if the repcap value is enum.Default"""
 		return RepeatedCapability.clsm_is_default_value(self._enum_value, self.enum_type)
 
-	def set_enum_value(self, enum_value: Enum) -> None:
+	def set_enum_value(self, enum_value: Enum or int) -> None:
 		"""Sets new enum value. Can not be Default"""
 		if RepeatedCapability.clsm_is_default_value(enum_value, self.enum_type):
 			raise ValueError(f"Setting RepCap enum value '{enum_value}' is not allowed. Please select a concrete value")
+		if isinstance(enum_value, int):
+			# Find the enum value that corresponds to the entered integer value
+			enum_value = self.enum_type(enum_value)
 		self._enum_value = enum_value
 
 	def get_enum_value(self) -> Enum:
 		"""Returns the actual enum value"""
 		return self._enum_value
 
 	def set_to_start_value(self) -> None:
@@ -66,16 +76,17 @@
 		self.set_enum_value(self._start_value)
 
 	def matches_type(self, enum_type) -> bool:
 		"""Returns true, if the entered type matches the EnumType"""
 		return self.enum_type == enum_type
 
 	@classmethod
-	def clsm_get_cmd_string_value(cls, enum_value: Enum, enum_type) -> str:
-		"""Converts RepCap integer value to string
+	def clsm_get_cmd_string_value(cls, enum_value: Enum or int, enum_type) -> str:
+		"""Class method version of the get_cmd_string_value().
+		Converts RepCap integer value to string
 		ValueEmpty is converted to "" (Not valid, but tolerated)
 		ValueDefault throws an exception
 		0 is converted to "" (Not valid, but tolerated)
 		Positive numbers are converted to integer strings e.g. 1 => '1' """
 		number = cls.clsm_get_direct_cmd_value_int(enum_value, enum_type)
 		if number == VALUE_EMPTY:
 			return ''
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/StreamReader.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/StreamReader.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,19 @@
+"""See the docstring for the StreamReader class."""
+
 from enum import Enum
 from os import path
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Enum):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
 	File = 2
 
 
 class StreamReader:
 	"""Lightweight stream reader implementation. Data source can be: \n
 	- variable
@@ -21,31 +25,32 @@
 		:param source: Source type for the stream. Variable / File
 		:param data: Depending on the 'binary' and 'source':
 		For source type Variable the data must be either bytes() or str
 		For source type File data must be string with existing file path."""
 		self._source = source
 		self._binary = binary
 		self._start_ptr = 0
+		self._read_len = 0
 
 		if self._source == Type.Variable:
 			if self._binary:
 				assert isinstance(data, bytes), f'Data must be of bytes type. Actual type: {type(data)}'
 			else:
 				assert isinstance(data, str), f'Data must be of string type. Actual type: {type(data)}'
 			self._data = data
 			self._full_len = len(self._data)
 		elif self._source == Type.File:
 			assert isinstance(data, str), f'Data must be of string type (file path). Actual type: {type(data)}'
 			if not path.isfile(data):
-				raise Exception(f'File does not exist. File path: {data}')
+				raise RsInstrException(f'File does not exist. File path: {data}')
 			self.file_path = data
 			self._data = open(self.file_path, 'rb' if self._binary else 'r')
 			self._full_len = path.getsize(self.file_path)
 		else:
-			raise Exception(f'StreamReader unknown type {source}')
+			raise RsInstrException(f'StreamReader unknown type {source}')
 
 	@classmethod
 	def as_bin_var(cls, data: bytes) -> 'StreamReader':
 		"""Creates new StreamReader from bytes.
 		:param data: [bytes] data for the stream."""
 		return cls(True, Type.Variable, data)
 
@@ -100,29 +105,34 @@
 		If the remaining length is smaller than the chunk_size, the method returns the remaining length only.
 		:param chunk_size: chunk to read. If not set, the method reads the entire data."""
 		assert self._data is not None, 'StreamReader buffer is invalid. You have probably closed it already.'
 		chunk_size = len(self) if chunk_size is None else chunk_size
 		chunk_size = min(chunk_size, len(self))
 		if chunk_size < 0:
 			raise ValueError(f'Chunk size can not be negative number: {chunk_size}')
-
+		self._read_len += chunk_size
 		if self._source == Type.Variable:
 			self._start_ptr += chunk_size
 			return self._data[self._start_ptr - chunk_size: self._start_ptr]
 		elif self._source == Type.File:
 			self._start_ptr += chunk_size
 			return self._data.read(chunk_size)
 
-	def read_as_binary(self, chunk_size: int = None) -> bytes:
+	@property
+	def read_len(self) -> int:
+		"""Returns number of bytes read from the stream since its creation."""
+		return self._read_len
+
+	def read_as_binary(self, encoding: str, chunk_size: int = None) -> bytes:
 		"""Same as read(), but always returns the data in binary format.
 		Practically works exactly as read() for binary streams.
-		For string streams, the method converts the returned data using utf-8 encoding to bytes()."""
+		For string streams, the method converts the returned data using the provided encoding to bytes()."""
 		if self._binary:
 			return self.read(chunk_size)
 		else:
-			return self.read(chunk_size).encode('utf-8')
+			return self.read(chunk_size).encode(encoding)
 
 	def close(self):
 		"""Closes the StreamReader. You can not use its instance afterwards."""
 		if self._source == Type.File and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/StreamWriter.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/StreamWriter.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,23 @@
+"""See the docstring for the StreamWriter class."""
+
 from enum import Flag
 from typing import AnyStr
+from io import BytesIO, StringIO
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Flag):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
-	File = 2
-	FileAppend = 6
+	Forget = 2
+	File = 4
+	FileAppend = 12
 
 
 class StreamWriter:
 	"""Lightweight stream writer implementation. Data target can be: \n
 	- bytes
 	- string
 	- file"""
@@ -19,41 +25,48 @@
 	def __init__(self, binary: bool, target: Type, meta_data=None):
 		"""Initializes StreamWriter instance.\n
 		:param binary: True: Binary data, False: ASCII data
 		:param target: Target for the stream. Variable / File (FileAppend)
 		:param meta_data: Only valid for File and FileAppend - define file path as string:
 		For Type.File, data must be string with file path. If the file exists, it will be overwritten.
 		For Type.FileAppend, data must be string with file path. If the file exists, it will be appended."""
-		self._binary = binary
-		self._written_len = 0
+		self._binary: bool = binary
+		self._written_len: int = 0
 		self._target = target
 
 		if Type.Variable in self._target:
 			assert meta_data is None, f'You can not define input meta_data for a Variable StreamWriter.'
-			self._data: AnyStr = bytes() if binary else ''
+			self._data = BytesIO() if binary else StringIO()
+		elif Type.Forget in self._target:
+			self._data: AnyStr = ''
 		elif Type.File in self._target:
 			assert isinstance(meta_data, str), f'Additional data must be of string type (file path). Actual type: {type(meta_data)}'
 			self._file_path = meta_data
 			mode = 'w' if self._target == Type.File else 'a'
 			mode += 'b' if self._binary else ''
 			self._data = open(self._file_path, mode)
 		else:
-			raise Exception(f'StreamWriter unknown target {target}')
+			raise RsInstrException(f'StreamWriter unknown target {target}')
 
 	@classmethod
 	def as_bin_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with bytes variable."""
 		return cls(True, Type.Variable)
 
 	@classmethod
 	def as_string_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with string variable."""
 		return cls(False, Type.Variable)
 
 	@classmethod
+	def as_forget(cls) -> 'StreamWriter':
+		"""Creates new StreamWriter which writes to nowhere - forgets the data."""
+		return cls(False, Type.Forget)
+
+	@classmethod
 	def as_bin_file(cls, file_path: str, append: bool = False) -> 'StreamWriter':
 		"""Creates new StreamWriter to binary file.
 		:param file_path: [str] Path to the file.
 		:param append: Optional [bool] If True, the content is appended to the existing content."""
 		return cls(True, Type.FileAppend if append else Type.File, file_path)
 
 	@classmethod
@@ -67,14 +80,16 @@
 		if Type.Variable in self._target:
 			mode = 'binary' if self._binary else 'string'
 			return f'StreamWriter {mode} variable, current size {size_to_kb_mb_string(len(self), True)}'
 		if Type.File in self._target:
 			mode = 'binary' if self._binary else 'text'
 			append = ' appended' if Type.FileAppend in self._target else ''
 			return f'StreamWriter {mode} file{append}, current{append} size {size_to_kb_mb_string(len(self), True)}, file: {self._file_path}'
+		if Type.Forget in self._target:
+			return 'StreamWriter to nowhere.'
 
 	def __len__(self):
 		"""Returns remaining length."""
 		return self._written_len
 
 	def __enter__(self):
 		return self
@@ -88,49 +103,62 @@
 		File streams are always binary."""
 		return self._binary
 
 	def write(self, data: AnyStr) -> None:
 		"""Writes chunk to the stream.
 			- For Type.Bytes data must be bytes.
 			- For Type.String, data must be string.
-			- For Type.File and Type.FileAppend, data must be bytes"""
+			- For Type.File and Type.FileAppend, data must be bytes."""
+		if Type.Forget in self._target:
+			self._written_len += len(data)
+			return
+
 		assert self._data is not None, 'StreamWriter buffer is invalid. You have probably closed it already.'
 		if self._binary:
 			assert isinstance(data, bytes), f'Bytes data is required. Actual type: {type(data)}. {self}'
 		else:
 			assert isinstance(data, str), f'String data is required. Actual type: {type(data)}. {self}'
-
 		if Type.Variable in self._target:
-			self._data += data
+			self._data.write(data)
 		elif Type.File in self._target:
 			self._data.write(data)
 		self._written_len += len(data)
 
-	def switch_to_string_data(self) -> None:
+	def switch_to_string_data(self, encoding: str) -> None:
 		"""Switches from binary to string data.
-		For variables, the current content is converted.
+		For variables, the current content is converted to string using the provided encoding.
 		For files, they are closed and reopened as for appended text writing."""
 		if self._binary is False:
 			return
 		self._binary = False
 		if Type.Variable in self._target:
-			if len(self) == 0:
-				self._data = ''
-			else:
-				# noinspection PyUnresolvedReferences
-				self._data = self._data.decode('utf-8')
+			self._data = StringIO(self.content.decode(encoding))
 		elif Type.File in self._target:
 			self._data.close()
 			self._data = open(self._file_path, 'a')
 
+	# noinspection PyTypeChecker
 	@property
 	def content(self) -> AnyStr:
-		"""Returns content of the writer. Does only work with variable types."""
-		assert Type.Variable in self._target, f'Can not return content for the current {self}'
+		"""Returns content of the writer. Only works with variable types."""
+		if self._target == Type.Forget:
+			return ''
+		if self._target != Type.Variable:
+			raise RsInstrException(f'Can not return content for the current {self}')
 		# noinspection PyTypeChecker
-		return self._data
+		if not self._data:
+			return None
+		self._data.seek(0)
+		ret_val = self._data.read()
+		self._data.close()
+		return ret_val
+
+	@property
+	def written_len(self) -> int:
+		"""Returns number of bytes written to the stream since its creation."""
+		return self._written_len
 
 	def close(self) -> None:
 		"""Closes the StreamWriter. You can not use its instance afterwards."""
 		if Type.File in self._target and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/StructBase.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/StructBase.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,22 @@
+"""See the docstring for the StructBase class."""
+
 from .Types import DataType
 
 
 class StructBase:
 	"""Base class for all the driver's argument structures."""
 	def __init__(self, owner):
 		self.__meta_args_link = dict()
 		ix = 0
 		for arg in self.__get_meta_args_list(owner):
 			arg.argument_ix = ix
 			ix += 1
 
-			if arg.data_type == DataType.Enum or arg.data_type == DataType.EnumList:
+			if arg.data_type in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]:
 				assert arg.enum_type, f"Struct Argument '{arg.name}' is of enum type, you must define the parameter 'enum_type'"
 			else:
 				assert not arg.enum_type, f"Struct Argument '{arg.name}' data type is '{arg.data_type.name}'. You must set the parameter 'enum_type' to None"
 
 			if arg.is_optional:
 				# set all optional values to None
 				setattr(self, arg.name, None)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Types.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Types.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,70 @@
+"""Data type class for the variables containing all the methods related to data types."""
+
 from enum import Enum, auto
 from typing import Any
 
 
+# noinspection PyArgumentList
 class DataType(Enum):
-	"""Data type of a variable in the driver."""
+	"""Data type of variable in the driver."""
 	String = auto()
 	RawString = auto()
 	Integer = auto()
 	IntegerExt = auto()
 	Boolean = auto()
 	Float = auto()
 	FloatExt = auto()
 	Enum = auto()
+	EnumExt = auto()
 	StringList = auto()
 	RawStringList = auto()
 	IntegerList = auto()
 	IntegerExtList = auto()
 	BooleanList = auto()
 	FloatList = auto()
 	FloatExtList = auto()
 	EnumList = auto()
+	EnumExtList = auto()
 
 	@property
 	def is_list(self) -> bool:
 		"""Returns True, if the data type is a list."""
 		return self in frozenset(
 			{
 				DataType.StringList,
 				DataType.RawStringList,
 				DataType.IntegerList,
 				DataType.IntegerExtList,
 				DataType.BooleanList,
 				DataType.FloatList,
 				DataType.FloatExtList,
-				DataType.EnumList
+				DataType.EnumList,
+				DataType.EnumExtList
 			})
 
 	@property
 	def is_scalar(self) -> bool:
 		"""Returns True, if the data type is a scalar."""
 		return not self.is_list
 
 	@property
+	def is_scalar_enum(self) -> bool:
+		"""Returns True, if the data type is a scalar enum or enum_ext."""
+		return self == DataType.Enum or self == DataType.EnumExt
+
+	@property
+	def is_list_enum(self) -> bool:
+		"""Returns True, if the data type is a list enum or list enum_ext."""
+		return self == DataType.EnumList or self == DataType.EnumExtList
+
+	@property
 	def is_enum(self) -> bool:
-		"""Returns True, if the data type is enum or enum array."""
-		return self == DataType.Enum or self == DataType.EnumList
+		"""Returns True, if the data type is enum or enum array - including the extended."""
+		return self in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]
 
 	@property
 	def is_raw_string(self) -> bool:
 		"""Returns True for raw string and raw string list."""
 		return self == DataType.RawString or self == DataType.RawStringList
 
 	@property
@@ -81,14 +97,16 @@
 			return DataType.IntegerExt
 		elif self == DataType.FloatList:
 			return DataType.Float
 		elif self == DataType.FloatExtList:
 			return DataType.FloatExt
 		elif self == DataType.EnumList:
 			return DataType.Enum
+		elif self == DataType.EnumExtList:
+			return DataType.EnumExt
 
 	def get_default_value(self, enm: Enum = None) -> Any:
 		"""Returns default value for the current type.
 		If the data type is Enum or EnumString, you have to provide the enum class."""
 		if self.is_list:
 			return []
 		if self == DataType.RawString:
@@ -103,7 +121,9 @@
 			return 0
 		elif self == DataType.Float:
 			return 0.0
 		elif self == DataType.FloatExt:
 			return 0.0
 		elif self == DataType.Enum:
 			return enm(0)
+		elif self == DataType.EnumExt:
+			return enm(0)
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/Utilities.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/Utilities.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Utilities for string manipulation and string formatting for the user."""
+
 from enum import Flag
 from typing import Tuple
 
 
 class TrimStringMode(Flag):
 	"""Trimming mode for strings."""
 	white_chars_only = 1
@@ -133,7 +135,41 @@
 
 
 def calculate_chunks_count(data_size: int, chunk_size: int) -> int:
 	"""Returns number of chunks needed to transfer the data_size split to maximum of chunk_size blocks. \n
 	:param data_size: total data size
 	:param chunk_size: maximum size of one block"""
 	return (data_size // chunk_size) + (1 if (data_size % chunk_size) > 0 else 0)
+
+
+def escape_nonprintable_chars(string: str, encoding: str = 'charmap') -> str:
+	"""
+	Replace nonprintable characters in string s by its hex representation.
+	"""
+	if string.isprintable():
+		return string
+	new_string = ''
+	for char in string:
+		if char.isprintable():
+			new_string += char
+		elif char == '\n':
+			new_string += r'\n'
+		elif char == '\r':
+			new_string += r'\r'
+		elif char == '\t':
+			new_string += r'\t'
+		else:
+			byte = bytes(char, encoding)
+			char = byte.hex()
+			new_string += r'\x' + char
+	return new_string
+
+
+def shorten_string_middle(string: str, max_len: int) -> str:
+	"""If the length of the string is bigger than the max_len,
+	the middle of the string is abbreviated with ' .... ' """
+	count = len(string)
+	if count <= max_len:
+		return string
+	half = int((max_len - 6) / 2)
+	md = (max_len - 6) % 2
+	return string[:half + md] + ' .... ' + string[(count - half):]
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/VisaPluginSocketIo.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/VisaPluginSocketIo.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,28 @@
+"""See the docstring for the SocketIo class."""
+
 import socket
 import re
 from contextlib import contextmanager
+from typing import Any
+
+from .InstrumentErrors import RsInstrException
 
 # noinspection PyPackageRequirements
 import pyvisa
 
 
 class SocketIo:
-
+	"""Socket IO plugin providing implementations for all the necessary VISA functions. This class does not need the underlying VISA installation."""
 	def __init__(self, resource_name: str):
 		self.session = socket.socket()
 		self.resource_name = resource_name
 		m = re.search(r'TCPIP::([^:]+)::([^:]+)::SOCKET', self.resource_name)
 		if not m:
-			raise Exception(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
+			raise RsInstrException(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
 		self.host = m.group(1).strip()
 		self.port = int(m.group(2).strip())
 		self._read_termination = None
 		self._chunk_size = 1024
 		self._timeout = 5000
 		self.visalib = VisaLib(self)
 
@@ -90,14 +95,22 @@
 
 	# noinspection PyUnusedLocal
 	def read_bytes(self, count: int, **kwargs) -> bytes:
 		"""Reads count bytes"""
 		data, status = self.visalib.read(self.session, count)
 		return data
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		self.write("&GTR")
+
 	# noinspection PyUnusedLocal
 	@contextmanager
 	def ignore_warning(self, filter_value: int) -> None:
 		"""Context property with no effect for the socket connection"""
 		try:
 			yield None
 		finally:
@@ -106,15 +119,15 @@
 
 	def close(self) -> None:
 		"""Closes the socket connection"""
 		self.session.close()
 
 
 class VisaLib:
-
+	"""Implementation of the pyvisa's VisaLib providing the method read()"""
 	def __init__(self, socket_io: SocketIo):
 		self._socket_io = socket_io
 
 	def __str__(self):
 		return "SocketIO"
 
 	# noinspection PyUnresolvedReferences
@@ -127,14 +140,16 @@
 
 		try:
 			while True:
 				to_read_len = chunk_size - read_len
 				if to_read_len <= 0:
 					break
 				data = session.recv(to_read_len)
+				if not data:
+					raise pyvisa.VisaIOError(pyvisa.constants.VI_ERROR_CONN_LOST)
 				chunk += data
 				read_len += len(data)
 
 				if self._socket_io.read_termination is not None:
 					# Read termination character is ON, look for it and stop the reading if found
 					term_char = self._socket_io.read_termination.encode()
 					if term_char in data:
@@ -159,17 +174,18 @@
 				more_data_available = True
 
 		return_code = pyvisa.constants.StatusCode.success_max_count_read if more_data_available else pyvisa.constants.StatusCode.success
 		return chunk, return_code
 
 
 class ResourceManager:
-
+	"""Implementation of the VISA's Resource Manager."""
 	def __init__(self):
 		self.VisaManufacturerName = "SocketIO"
 		self.connection = None
 
-	def open_resource(self, resource_name: str) -> SocketIo:
-		"""Creates new Socket connection"""
+	# noinspection PyUnusedLocal
+	def open_resource(self, resource_name: str, access_mode: Any = None, open_timeout: Any = None) -> SocketIo:
+		"""Creates new Socket connection. access_mode and open_timeout are here for compatibility reasons with the pyvisa rm.open_resource()"""
 		self.connection = SocketIo(resource_name)
 		self.connection.connect()
 		return self.connection
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/VisaSession.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/VisaSession.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,23 @@
+"""Visa Session is an extension of the pure VISA providing higher level of methods regardless of the session kind."""
+
 import time
 from enum import Enum, Flag
-from typing import Tuple, Callable, AnyStr
+from typing import List, Tuple, Callable, AnyStr
 import os.path
 import re
 import threading
 
 # noinspection PyPackageRequirements
 import pyvisa
+from pyvisa.errors import StatusCode
 
 from .VisaPluginSocketIo import ResourceManager, SocketIo
 from . import InstrumentSettings, InstrumentErrors, Conversions as Conv
-from .InstrumentSettings import WaitForOpcMode, InstrViClearMode as ViClearMode
+from .InstrumentSettings import WaitForOpcMode, OpcSyncQueryMechanism, InstrViClearMode as ViClearMode
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 from .Utilities import size_to_kb_mb_string, calculate_chunks_count
 import platform
 import struct
 
 
@@ -37,14 +40,16 @@
 	bin_known_len = 3
 	bin_unknown_len = 4
 
 
 class StatusByte(Flag):
 	"""Status Byte flags."""
 	NONE = 0x00
+	custom_bit_0 = 0x01
+	custom_bit_1 = 0x02
 	error_queue_not_empty = 0x04
 	questionable_status_reg = 0x08
 	message_available = 0x10
 	event_status_byte = 0x20
 	request_service = 0x40
 	operation_status_reg = 0x80
 
@@ -64,14 +69,22 @@
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		self._std_bin_block_header_max_len: int = 999999999
 		self._lock = None
 		self.disable_opc_query: bool = settings.disable_opc_query
 		self.last_status = None
 		self.visa_library_name = None
+		self.resource_name = resource_name  # might be changed later if direct_session is used
+		self.encoding = settings.encoding  # default encoder between bytes and string
+		self.cmd_idn = settings.cmd_idn
+		self.skip_status_system_setting = settings.skip_status_system_setting
+		self.skip_clear_status = settings.skip_clear_status
+		self.stb_in_error_check = settings.stb_in_error_check
+		self.opc_sync_query_mechanism = settings.opc_query_sync_mechanism
+		self.each_cmd_prefix = settings.each_cmd_prefix
 
 		# Implemented for interface compatibility with VisaSessionSim
 		self.cached_to_stream = False
 
 		# Event handlers
 		# noinspection PyTypeChecker
 		self.on_read_chunk_handler: Callable = None
@@ -80,36 +93,36 @@
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		if self.reusing_session:
 			# Reuse the session
-			assert isinstance(direct_session, pyvisa.Resource) or isinstance(direct_session, SocketIo), f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'"
-			self._session = direct_session
-			self._resource_name = self._session.resource_name
+			self._session = VisaSession.get_and_check_direct_session(direct_session)
+			self.resource_name = self._session.resource_name
 		else:
 			# Create new session
 			# Check resource_name for the trailing (SelectVisa=..)
 			pure_resource_name, visa_select = self._get_pure_resource_name(resource_name)
 			if settings.visa_select is not None:
 				visa_select = settings.visa_select
 			self._rm = VisaSession.get_resource_manager(visa_select)
 			self.manufacturer = self._get_visa_manufacturer()
 
 			# Resource manager opening
 			try:
-				self._session = self._rm.open_resource(pure_resource_name)
+				acc_mode = pyvisa.constants.AccessModes.no_lock if settings.exclusive_lock is False else pyvisa.constants.AccessModes.exclusive_lock
+				self._session = self._rm.open_resource(resource_name=pure_resource_name, open_timeout=settings.open_timeout, access_mode=acc_mode)
 			except pyvisa.VisaIOError as e:
 				if e.error_code != pyvisa.constants.StatusCode.error_resource_not_found:
 					raise e
 				message = e.description
 				message += f"\nLibrary: {self._rm.visalib}\nManufacturer: {self.manufacturer}\nResource Name: '{resource_name}'"
 				raise InstrumentErrors.ResourceError(resource_name, message)
-			self._resource_name = resource_name
+			self.resource_name = resource_name
 
 		# Decide, whether to create a new thread lock or the existing one from the session
 		if hasattr(self._session, 'session_thread_rlock'):
 			rlock = self._session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
@@ -136,28 +149,22 @@
 			self._interface_type = SessionKind.vxi11
 			if self._session.resource_class == 'SOCKET':
 				self._interface_type = SessionKind.socket
 
 		# Specifics for different interfaces
 		self._assure_write_with_tc = settings.assure_write_with_tc
 		self._term_char = settings.term_char
-		self._term_char_bin = self._term_char.encode('utf-8')
+		self._term_char_bin = self._term_char.encode(self.encoding)
 		self._session.write_termination = ''
-		self.vxi_capable = True
+		self.vxi_capable = settings.vxi_capable
 
 		if self._interface_type == SessionKind.serial:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
 		elif self._interface_type == SessionKind.socket:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
-		else:
-			self._session.read_termination = ''
 
 		# NRP-Z specific settings
 		if self.is_rsnrp_session():
 			self.disable_opc_query = True
 			# NRP-Z does not support chunk reading, therefore the segment must be in one piece
 			settings.io_segment_size = 1000000
 			self.vxi_capable = False
@@ -166,78 +173,125 @@
 		self.read_delay = settings.read_delay
 		self._viclear_exe_mode = settings.viclear_exe_mode
 		self._opc_wait_mode = settings.opc_wait_mode
 
 		# Parameters that need to be coerced based on Vxi-capability
 		if self.vxi_capable:
 			self._add_term_char_to_write_bin_block = settings.add_term_char_to_write_bin_block
+			self._session.read_termination = ''
 		else:
 			self._add_term_char_to_write_bin_block = True
+			self._session.read_termination = self._term_char
+			self._assure_write_with_tc = True
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self._session.chunk_size = settings.io_segment_size
 		self._data_chunk_size = settings.io_segment_size
 
-		# Must call the VISA viClear() before the any communication with the instrument
+		# Must call the VISA viClear() before any communication with the instrument
 		self.clear()
 
 		# Further steps are for NRP-Z session not valid
 		if self.is_rsnrp_session():
 			return
 
+		# First commands, can be more than one, separated by ';;'
+		if settings.first_cmds:
+			cmds = settings.first_cmds.split(';;')
+			for cmd in cmds:
+				if cmd.startswith('<w>'):
+					self.write(cmd[3:])
+				elif cmd.startswith('<q>'):
+					_ = self._query_str_no_events(cmd[3:])
+				elif '?' in cmd:
+					_ = self._query_str_no_events(cmd)
+				else:
+					self.write(cmd)
+
 		# Clear instrument status
-		self.write('*CLS')
-		if self.vxi_capable:
-			stb = self._read_stb()
-			if stb & StatusByte.message_available:
-				self._flush_junk_data()
+		if self.skip_clear_status is False:
+			self.write('*CLS')
+			if self.vxi_capable:
+				stb = self._read_stb()
+				if stb & StatusByte.message_available:
+					self._flush_junk_data()
 
 		# Apply settings for ESE and SRE, plus coerce the _opcWaitMode if necessary
 		self._opc_wait_mode = self._set_regs_ese_sre(self._opc_wait_mode)
 
 	@staticmethod
+	def get_and_check_direct_session(direct_session):
+		"""Returns direct session if it's a proper type.
+		If the direct_session is None, the function returns None.
+		If the direct_session is of an unsupported type, the function raises RsInstrException."""
+		if direct_session is None:
+			return None
+		# Reuse the session
+		if not isinstance(direct_session, pyvisa.Resource) and not isinstance(direct_session, SocketIo):
+			raise InstrumentErrors.RsInstrException(f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'")
+		return direct_session
+
+	@staticmethod
 	def _get_pure_resource_name(resource_name: str):
 		"""Returns pure resource name stripped of the (SelectVisa) part and the visa_select string"""
 		m = re.search(r'(.+)\(SelectVisa=([^),]+)\)', resource_name)
 		if not m:
 			return resource_name, None
 		resource_name = m.group(1).strip()
 		visa_select = m.group(2).strip()
 		return resource_name, visa_select
 
 	@classmethod
 	def get_resource_manager(cls, visa_select: str) -> pyvisa.ResourceManager:
 		"""Returns resource manager for the desired VISA implementation"""
 		operating_system = platform.system().lower()
+		vsl = None if visa_select is None else visa_select.lower()
 		bittness = struct.calcsize('P') * 8
-		if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
-			return pyvisa.ResourceManager()
-		if visa_select.lower() in ['@ni', 'ni', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
-			return pyvisa.ResourceManager('@ni')
-		if visa_select.lower() in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
-			return pyvisa.ResourceManager('@py')
-		if 'rohde&schwarz' in visa_select.lower() or 'rohdeschwarz' in visa_select.lower() or visa_select.lower() == 'rsvisa' or visa_select.lower() == 'rs' or visa_select.lower() == 'r&s':
+		# Try if you find the default VISA dll
+		try:
+			if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@ni', 'ni', 'ivi', '@ivi', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
+				return pyvisa.ResourceManager('@py')
+		except ValueError:
+			# None of the required implementations found, fall back to the R&S VISA
+			visa_select = 'rsvisa'
+			vsl = visa_select.lower()
+
+		# from here, RsVisa implementation is considered
+		if 'rohde&schwarz' in vsl or 'rohdeschwarz' in vsl or vsl == 'rsvisa' or vsl == 'rs' or vsl == 'r&s':
 			if operating_system == 'windows':
 				if bittness == 32:
 					visa_select = r'c:\Windows\SysWOW64\RsVisa32.dll'
 				else:
 					visa_select = r'c:\Windows\system32\RsVisa32.dll'
 				return pyvisa.ResourceManager(visa_select)
 			elif operating_system == 'linux':
 				# The default install location may be different
 				# for debian/red hat/opensuse derived distributions
 				check_visa = [f'/usr/lib{bittness}/librsvisa.so', r'/usr/lib/librsvisa.so']
 				for check in check_visa:
 					if os.path.isfile(check):
 						return pyvisa.ResourceManager(check)
+			elif operating_system == 'darwin':
+				# MacOS
+				check_visa = [f'/Library/Frameworks/RsVisa.framework/Versions/Current/RsVisa/librsvisa.dylib']
+				for check in check_visa:
+					if os.path.isfile(check):
+						return pyvisa.ResourceManager(check)
 
-		if visa_select.lower() in ['socketio', 'socket', 'none']:
+		if vsl in ['socketio', 'socket', 'none']:
 			return ResourceManager()
+
 		return pyvisa.ResourceManager(visa_select)
 
 	def _get_visa_manufacturer(self) -> str:
 		"""Returns manufacturer of the current VISA"""
 		if hasattr(self._rm, 'VisaManufacturerName'):
 			return self._rm.VisaManufacturerName
 		try:
@@ -256,14 +310,26 @@
 		setattr(self._session, 'session_thread_rlock', lock)
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
 
+	def lock_resource(self, timeout: int, requested_key: str or bytes = None) -> bytes or None:
+		"""Locks the instrument to prevent it from communicating with other clients."""
+		if requested_key is None:
+			self._session.lock_excl(timeout)
+			return None
+		else:
+			return self._session.lock(timeout, requested_key)
+
+	def unlock_resource(self) -> None:
+		"""Unlocks the instrument to other clients."""
+		self._session.unlock()
+
 	@property
 	def visa_timeout(self) -> int:
 		"""See the visa_timeout.setter."""
 		return int(self._session.timeout)
 
 	@visa_timeout.setter
 	def visa_timeout(self, value: int) -> None:
@@ -278,73 +344,96 @@
 	@data_chunk_size.setter
 	def data_chunk_size(self, chunk_size: int) -> None:
 		"""Sets the maximum size of one block transferred during write/read operations."""
 		self._data_chunk_size = int(chunk_size)
 		self._session.chunk_size = int(chunk_size)
 
 	def _resolve_opc_timeout(self, timeout: int) -> int:
-		"""Resolves entered timeout value - if the input value is less than 1, it is replaces with opc_timeout."""
+		"""Resolves entered timeout value - if the input value is less than 1, it is replaced with opc_timeout."""
 		if timeout is None or timeout < 1:
 			return self.opc_timeout
 		else:
 			return timeout
 
 	def _set_regs_ese_sre(self, mode: WaitForOpcMode) -> WaitForOpcMode:
 		"""Based on the WaitForOpcMode, it sets the ESE and SRE register masks.
 		Returns coerced WaitForOpcMode."""
 		# Set the SRE and ESE registers accordingly
 		# No SRE is supported
+		if self.skip_status_system_setting:
+			return mode
 		self._set_ese_mask(EventStatusRegister.operation_complete)
 		self._set_sre_mask(StatusByte.NONE)
 		return mode
 
+	# noinspection PyTypeChecker
 	def _set_ese_mask(self, mask: EventStatusRegister, reset: bool = True) -> None:
 		"""Sends *ESE command with mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*ESE?'))
 			mask = current_value | mask.value
 		self.write("*ESE %d" % mask.value)
 
+	# noinspection PyTypeChecker
 	def _set_sre_mask(self, mask: StatusByte, reset: bool = True) -> None:
 		"""Sends *SRE command with StatusByte mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*SRE?'))
 			mask = current_value | mask.value
 		# Also affect the _opc_wait_mode:
 		# If the mask has event_status_byte == false, and the _opc_wait_mode is service_request, set it to stb_poll
 		# If the mask has event_status_byte == true, do not change anything
 		self.write(f'*SRE {mask.value}')
 
-	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Reads Status Byte Register and ends if the ESB bit (5) is set to 1.
 		Also works with the SOCKET and SERIAL interface by sending *STB? query.
 		In that case however, command cannot be a query.
 		Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
-		self.clear_before_read()
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
-		self.write(command + ';*OPC')
-		# Use catch to return the VISA Timeout back
+
+		if is_query is True:
+			if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.standard or self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+				self.clear_before_read()
+				self.write(command + ';*OPC')
+				if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+					end_mask |= StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.only_check_mav_err_queue:
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.cls_only_check_mav_err_queue:
+				self.clear_before_read()
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+		else:
+			self.clear_before_read()
+			self.write(command + ';*OPC')
+
 		start = time.time()
 		# STB polling loop
 		while True:
 			stb = self._read_stb()
 			elapsed = self._polling_delay(start)
 			if elapsed > timeout_secs:
 				self._narrow_down_opc_tout_error(command, is_query, timeout)
 			if end_mask & stb:
 				break
 		return stb
 
-	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int) -> StatusByte:
 		"""Queries Status Byte Register (*STB?) and ends if the ESB bit (5) is set to 1.
 			The command must not be a query. Also works with the SOCKET and SERIAL interface.
 			Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		self.clear_before_read()
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		self.write(command + ';*OPC')
 		start = time.time()
 		# STB polling loop
 		while True:
@@ -360,43 +449,47 @@
 		"""Called by the _write_and_poll_stb_vxi when the timeout expires.
 		The method tries to closer identify the cause of the timeout."""
 		stb = self._read_stb()
 		timeout = self._resolve_opc_timeout(timeout)
 		if is_query:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending query '{command.strip()}'.")
+				context = f"Query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Query '{command.strip()}'.")
 		else:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending command '{command.strip()}'.")
+				context = f"Command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Command '{command.strip()}'.")
 
 	def _narrow_down_io_tout_error(self, context: str, visa_timeout: int = 0) -> None:
 		"""Called internally after IOTimeoutException can narrow down the error to more specific exception.
-		You can define the visa_timeout value for the error message. Otherwise the current visa_timeout is reported."""
+		You can define the visa_timeout value for the error message. Otherwise, the current visa_timeout is reported."""
+		context_stripped = context.strip().rstrip("- ")
+		if self.stb_in_error_check is False:
+			raise InstrumentErrors.TimeoutException(context_stripped)
 		if self.vxi_capable:
 			stb = self._read_stb()
 		else:
 			# Non-Vxi session
 			old_tout = self.visa_timeout
 			try:
 				self.visa_timeout = 500
-				stb = self._query_stb()
+				stb = self._query_stb(False)
 			finally:
 				self.visa_timeout = old_tout
 		if visa_timeout <= 0:
 			visa_timeout = self.visa_timeout
+
 		context = context + f'VISA Timeout error occurred ({visa_timeout} milliseconds)'
 		if stb & StatusByte.error_queue_not_empty:
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context + ' and ...')
-		# In case the previous exception is not thrown
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context + ' and ...', first_exc=InstrumentErrors.TimeoutException)
+		# In case none of the previous exceptions is thrown
 		raise InstrumentErrors.TimeoutException(context)
 
 	def _polling_delay(self, start):
 		"""Generates progressive polling delay."""
 
 		elapsed = time.time() - start
 		if self._opc_wait_mode == WaitForOpcMode.stb_poll:
@@ -445,59 +538,80 @@
 			if elapsed < 20:
 				time.sleep(1)
 				return elapsed
 			time.sleep(2)
 
 		return elapsed
 
-	def query_syst_error(self) -> str or None:
-		"""Returns one response to the SYSTEM:ERROR? query."""
-		error = self.query_str('SYST:ERR?')
-		if error.startswith('0,'):
+	@staticmethod
+	def _parse_err_query_response(response: str) -> Tuple[int, str]:
+		"""
+		Parses entered response string to Tuple(code, message).
+		E.g.: response = '-110,"Command error"' returns: (-110,'Command error')
+		"""
+		m = re.match(r'([-+]?\d+).*?[\'"](.*)[\'"]', response)
+		code = 0
+		if m:
+			try:
+				code = int(m.group(1))
+			except ValueError:
+				pass
+			return code, m.group(2)
+		else:
+			return code, response
+
+	def query_syst_error(self) -> Tuple[int, str] or None:
+		"""Returns one response to the SYSTEM:ERROR? query.
+		The response is a Tuple of (code: int, message: str)"""
+		error = self._query_str_no_events('SYST:ERR?')
+		if error.startswith('0,') or error.startswith('+0,'):
 			return None
-		return error.strip()
+		return self._parse_err_query_response(error.strip())
 
-	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
+	def query_all_syst_errors(self) -> List[Tuple[int, str]] or None:
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
 		errors = []
 		while True:
 			entry = self.query_syst_error()
 			if entry is None:
 				break
 			errors.append(entry)
 			if len(errors) > 50:
 				# Safety stop
 				errors.append('query_all_syst_errors - max limit 50 of SYST:ERR? sent.')
 				break
-
 		if len(errors) == 0:
 			return None
 		else:
 			return errors
 
-	def _query_stb(self) -> StatusByte:
+	def _query_stb(self, allow_tout_error_narrow_down: bool = True) -> StatusByte:
 		"""Sends *STB? query and reads the result."""
-		return StatusByte(int(self._query_str_no_events('*STB?')))
+		return StatusByte(int(self._query_str_no_events('*STB?', allow_tout_error_narrow_down)))
 
 	def _read_stb(self) -> StatusByte:
 		"""Calls viReadStb and returns the result."""
 		return StatusByte(self._session.read_stb())
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 
 		# For NRP-Z sessions, skip this completely
-		if self.is_rsnrp_session():
+		if self.is_rsnrp_session() or self.skip_clear_status:
 			return
 
 		if not self.vxi_capable:
 			# Non-Vxi session must use *CLS in any case
 			self.write('*CLS')
 			correct = False
-			opc = self._query_str_no_events('*OPC?')
+			if self.disable_opc_query:
+				opc = '1'
+			else:
+				opc = self._query_str_no_events('*OPC?')
 			repeat = 0
 			while not correct:
 				if len(opc) <= 2:
 					opc = opc.strip()
 					correct = opc == '0' or opc == '1'
 				if not correct:
 					# Read again with a small VISA timeout
@@ -525,15 +639,15 @@
 				self.query_and_clear_esr()
 			# Check if the status byte value changed
 			previous_stb = stb
 			stb = self._query_stb()
 			if stb == previous_stb:
 				repeat += 1
 				if repeat > 10:
-					raise Exception(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
+					raise RsInstrException(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
 
 	def _flush_junk_data(self) -> None:
 		"""Reads junk bytes to clear the instrument's output buffer."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		self._read_unknown_len(StreamWriter.as_bin_var(), False)
 
@@ -568,39 +682,55 @@
 			try:
 				self._session.clear()
 			except Exception:
 				pass
 		else:
 			self._session.clear()
 
+	def is_connection_active(self) -> bool:
+		"""Returns true, if the VISA connection is active and the communication with the instrument still works.
+		This is achieved by:
+		- checking the session property timeout
+		- sending the *IDN? query"""
+		if self._session is None:
+			return False
+		# noinspection PyBroadException
+		try:
+			old_tout = self.visa_timeout
+			self.visa_timeout = 2000
+			if len(self.cmd_idn) > 0:
+				self.write(self.cmd_idn)
+				_ = self._read_str_no_events()
+			self.visa_timeout = old_tout
+			return True
+		except Exception:
+			return False
+
 	def _write_and_wait_for_opc(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Internal method to synchronise a command with OPC timeout.
 		Timeout value 0 means the OPC timeout is used."""
 		timeout = self._resolve_opc_timeout(timeout)
 
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		if is_query:
 			InstrumentErrors.assert_query_has_qmark(command, 'Query with OPC')
 		else:
 			InstrumentErrors.assert_cmd_has_no_qmark(command, 'Write with OPC')
 
 		if self._opc_wait_mode == WaitForOpcMode.opc_query:
 			if is_query:
-				raise Exception('Sending a query with OpcQuery synchronization is not possible')
+				raise RsInstrException('Sending a query with OpcQuery synchronization is not possible')
 			stb = self._write_and_query_opc(command, timeout)
 		else:
 			# STB polling
-			end_stb_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
-			if is_query:
-				end_stb_mask |= StatusByte.message_available
 			if self.vxi_capable:
-				stb = self._write_and_poll_stb_vxi(command, is_query, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_vxi(command, is_query, timeout)
 			else:
-				stb = self._write_and_poll_stb_non_vxi(command, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_non_vxi(command, timeout)
 
 		return stb
 
 	def _write_and_query_opc(self, cmd: str, timeout: int) -> StatusByte:
 		"""Internal method to write a command followed by query_opc().
 		Used for opc-synchronization if the mode is set to WaitForOpcMode.opc_query or the session is not-vxi.
 		Timeout value 0 means the OPC timeout is used."""
@@ -614,40 +744,52 @@
 			self.write(cmd)
 			self.query_opc()
 		finally:
 			if old_tout != timeout:
 				self.visa_timeout = old_tout
 		return self._query_stb()
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		if self.vxi_capable is False or self._opc_wait_mode is WaitForOpcMode.opc_query:
+			return False
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.standard:
+			return True
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.also_check_mav:
+			return True
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		if self.write_delay > 0:
 			time.sleep(self.write_delay / 1000)
 		add_tc = False
 		if self._assure_write_with_tc and not cmd.endswith(self._term_char):
 			add_tc = True
+		if self.each_cmd_prefix:
+			cmd = self.each_cmd_prefix + cmd
+		cmd_bytes = cmd.encode(self.encoding)
 		if add_tc:
-			self._session.write(cmd + self._term_char)
-		else:
-			self._session.write(cmd)
+			cmd_bytes += self._term_char.encode(self.encoding)
+		self._session.write_raw(cmd_bytes)
 
 	def _read_unknown_len(self, stream: StreamWriter, allow_chunk_events: bool, prepend_data: AnyStr = None) -> None:
 		"""Reads data of unknown length to the provided WriteStream.
 		The read is performed in an incremental chunk steps to optimize memory use (for NRP-Z session it is set to fixed self._data_chunk_size):
 			- The first read is performed with the fixed size of 1024 bytes
 			- The 2nd one reads 64 kBytes
 			- The 3rd one reads 128 kBytes
 			- The 4th one reads 256 kBytes and so on, with the max cap of self._data_chunk_size
 		:param stream: [StreamWriter] target for the read data
 		:param allow_chunk_events: [bool] if True, the method can send the chunk_events. If False, sending events is blocked.
-		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first chunk read
+		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first read chunk
 		:return: read data [bytes or string], depending on the parameter binary."""
 		with self._session.ignore_warning(pyvisa.constants.StatusCode.success_max_count_read):
 			if prepend_data and isinstance(prepend_data, str):
-				prepend_data = prepend_data.encode('utf-8')
+				prepend_data = prepend_data.encode(self.encoding)
 			chunk_ix = 0
 			eot = False
 			while not eot:
 				if self.is_rsnrp_session():
 					chunk_size = self._data_chunk_size
 				else:
 					if chunk_ix == 0:
@@ -660,15 +802,15 @@
 				if chunk_size > self._data_chunk_size:
 					chunk_size = self._data_chunk_size
 				chunk, self.last_status = self._session.visalib.read(self._session.session, chunk_size)
 				if chunk_ix == 0 and prepend_data:
 					chunk = prepend_data + chunk
 				eot = not self._last_status_more_data_available()
 				if not stream.binary:
-					chunk = chunk.decode('utf-8')
+					chunk = chunk.decode(self.encoding)
 					if eot:
 						chunk = chunk.rstrip(self._term_char)
 				stream.write(chunk)
 				if self.on_read_chunk_handler and allow_chunk_events:
 					total_size = len(stream) if eot is True else None
 					event_args = EventArgsChunk(stream.binary, chunk_ix, len(chunk), total_size, len(stream), eot, None, chunk if self.io_events_include_data else None)
 					self.on_read_chunk_handler(event_args)
@@ -683,37 +825,44 @@
 		Sending of any read events is blocked."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		stream = StreamWriter.as_string_var()
 		self._read_unknown_len(stream, False)
 		return stream.content
 
-	def _query_str_no_events(self, query: str) -> str:
+	def _query_str_no_events(self, query: str, allow_tout_error_narrow_down: bool = True) -> str:
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_no_events()
-		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+		except pyvisa.VisaIOError as e:
+			context = f"Query '{query.rstrip(self._term_char)}'"
+			if e.error_code == StatusCode.error_timeout:
+				if allow_tout_error_narrow_down:
+					self._narrow_down_io_tout_error(context + ' - ')
+				else:
+					raise InstrumentErrors.TimeoutException(context)
+			else:
+				raise InstrumentErrors.RsInstrException(context)
 		return response
 
 	def _query_str_no_events_timed(self, query: str, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Queries the instrument and reads the response as string.
 		The entered timeout sets the VISA timeout just for this call. You can suppress the timeout error.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_timed(timeout, suppress_read_tout)
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
+			self._narrow_down_io_tout_error(f"Query with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
 		return response
 
 	def _read_str_timed(self, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Reads response from the instrument with a VISA timeout temporarily set for the read.
 		The VISA timeout is set back to the previous value before the method finishes even if an exception occurs.
 		Sending of any read events is blocked."""
 		old_visa_tout = self.visa_timeout
@@ -748,15 +897,15 @@
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str()
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+			self._narrow_down_io_tout_error(f"Query '{query.rstrip(self._term_char)}' - ")
 		return response
 
 	def query_str_no_tout_err(self, query: str, tout: int) -> str:
 		"""Same as query_str, but you can set the timeout just for this one call.
 		If the timeout exception occurs, it is suppressed and the method returns Null"""
 		response = None
 		old_tout = self.visa_timeout
@@ -770,23 +919,23 @@
 		return response
 
 	def write_with_opc(self, command: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self._write_and_wait_for_opc(command, False, timeout)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		timeout = self._resolve_opc_timeout(timeout)
 		if self.vxi_capable and self._opc_wait_mode is not WaitForOpcMode.opc_query:
 			# For Vxi session, use the STB poll or SRQ wait and then read the response
 			stb = self._write_and_wait_for_opc(query, True, timeout)
-			self._check_msg_available_after_opc_wait(stb, query, timeout, 'Query String With OPC')
+			self._check_msg_available_after_opc_wait(stb, query, timeout, context)
 			response = self._read_str()
 		else:
 			# For non-Vxi sessions, use the longer VISA Timeout without the *OPC?
 			# Same is valid for WaitForOpcMode.OpcQuery
 			InstrumentErrors.assert_query_has_qmark(query, 'Query with VISA timeout')
 			self.write(query)
 			old_tout = self.visa_timeout
@@ -824,57 +973,59 @@
 		"""Used internally after _StbPolling() to check if the message is available.
 		Throws an exception in case of MAV not available."""
 		if not self.vxi_capable:
 			return
 		if stb & StatusByte.message_available:
 			return
 		# Message not available
-		context = context + f" SCPI query '{query.rstrip(self._term_char)}'"
+		context = context + f" Query '{query.rstrip(self._term_char)}'"
 		if stb & StatusByte.error_queue_not_empty:
 			# Instrument reports an error
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context)
 		else:
 			# Sometimes even if the StatusByte.MessageAvailable is false, the message is available.
 			# Try to read the STB again
 			stb = self._read_stb()
 			if not stb & StatusByte.event_status_byte:
 				# Instrument did not respond within the defined time
 				InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f'{context} No response from the instrument.')
 
 	def error_in_error_queue(self) -> bool:
 		"""Returns true, if error queue contains at least one error."""
 		stb = self._query_stb()
-		return (stb & StatusByte.error_queue_not_empty) != 0
+		if stb & StatusByte.error_queue_not_empty:
+			return True
+		return False
 
 	def reset_ese_sre(self) -> None:
 		"""Resets the status of ESE and SRE registers to default values."""
 		self._set_regs_ese_sre(self._opc_wait_mode)
 
 	def write_bin_block(self, cmd: str, data_stream: StreamReader) -> None:
 		"""Writes all the payload as binary data block to the instrument.
 		The binary data header is added at the beginning of the transmission automatically.
 		:param cmd: [str] SCPI command with which to send the data
 		:param data_stream: [StreamReader] data provider for the payload"""
 		data_size = len(data_stream)
 		len_str = f'{data_size}'
 		cmd = cmd.rstrip(self._term_char)
 		if '#' in cmd:
-			raise Exception(
+			raise RsInstrException(
 				f"Command '{cmd}' must be provided without the binary data header. "
 				f"The method 'write_bin_block' composes and prepends the binary data header automatically.")
 		if data_size <= self._std_bin_block_header_max_len:
 			# Standard bin data header for sizes below 1E9 bytes, e.g.: '#512345'
-			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode(self.encoding)
 		else:
 			# Big sizes bin data header: e.g.: '#(3000000000)'
-			cmd_plus_header = f'{cmd}#({len_str})'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#({len_str})'.encode(self.encoding)
 
 		if data_size <= self._data_chunk_size:
 			# Write all in one step
-			full_chunk = data_stream.read_as_binary()
+			full_chunk = data_stream.read_as_binary(self.encoding)
 			write_buf = cmd_plus_header + full_chunk
 			if self._add_term_char_to_write_bin_block:
 				write_buf += self._term_char_bin
 			self._session.write_raw(write_buf)
 			# Event sending
 			if self.on_write_chunk_handler:
 				event_args = EventArgsChunk(True, 0, data_size, data_size, data_size, True, 1, full_chunk if self.io_events_include_data else None)
@@ -890,24 +1041,24 @@
 					time.sleep(self.write_delay / 1000)
 				# Write bin header
 				self._session.write_raw(cmd_plus_header)
 				# Write chunks
 				while True:
 					if len(data_stream) > self._data_chunk_size:
 						#  Not the last segment
-						chunk = data_stream.read_as_binary(self._data_chunk_size)
+						chunk = data_stream.read_as_binary(self.encoding, self._data_chunk_size)
 						self._session.write_raw(chunk)
 						# Event sending
 						if self.on_write_chunk_handler:
 							event_args = EventArgsChunk(
 								True, chunk_ix, self._data_chunk_size, data_size, data_size - len(data_stream), False, total_chunks, chunk if self.io_events_include_data else None)
 							self.on_write_chunk_handler(event_args)
 					else:
 						# Last segment, indicate end of message again
-						chunk = data_stream.read_as_binary()
+						chunk = data_stream.read_as_binary(self.encoding)
 						if self._add_term_char_to_write_bin_block:
 							# Append LF
 							self._session.write_raw(chunk)
 							self._session.send_end = True
 							self._session.write_raw(self._term_char_bin)
 						else:
 							self._session.send_end = True
@@ -936,60 +1087,88 @@
 			char = self._session.read_bytes(1, break_on_termchar=True)
 			if char == b'0':
 				data_type = ReadDataType.bin_unknown_len
 				return data_type, '#0', -1
 			if char == b'(':
 				# format for big lengths i.e. > 1E9 bytes: '#(1234567890123)...'
 				data_type = ReadDataType.bin_known_len
-				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode('utf-8')
+				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode(self.encoding)
 				whole_hdr = '#(' + len_str + ')'
 				length = int(len_str)
 				return data_type, whole_hdr, length
 
 			# classic format for < 1E9 bytes: '#9123456789...'
 			data_type = ReadDataType.bin_known_len
 			len_of_len = int(char)
-			len_str = self._session.read_bytes(len_of_len).decode('utf-8')
+			len_str = self._session.read_bytes(len_of_len).decode(self.encoding)
 			length = int(len_str)
-			whole_hdr = '#' + char.decode('utf-8') + len_str
+			whole_hdr = '#' + char.decode(self.encoding) + len_str
 			return data_type, whole_hdr, length
 
 		data_type = ReadDataType.ascii
 		if char == self._term_char_bin:
 			data_type = ReadDataType.null
 		if self.vxi_capable:
 			# For Vxi session, to be sure, check whether there are more chars in the read buffer
 			stb = self._read_stb()
 			if stb & StatusByte.message_available:
 				data_type = ReadDataType.ascii
-		whole_hdr = char.decode('utf-8')
+		whole_hdr = char.decode(self.encoding)
 		if exc_if_not_bin:
 			if data_type == ReadDataType.null:
-				InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, self._term_char)
+				InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, self._term_char)
 			# Read 20 more characters to compose a better exception message
-			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode('utf-8')
+			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode(self.encoding)
 			if self.last_status == pyvisa.constants.StatusCode.success_max_count_read:
 				self._flush_junk_data()
-			InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, whole_hdr)
+			InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, whole_hdr)
 		return data_type, whole_hdr, length
 
+	def get_bin_data_length(self, query: str) -> int or None:
+		"""Returns only the length binary data header, and discards the actual data.
+		Any timeout error is suppressed, and the method returns None instead.
+		Warning!!! - for non-VXI sessions (SOCKET, ASRL) this method transfers the entire file to the control PC, which might take a long time."""
+		if self.vxi_capable and self._opc_wait_mode != WaitForOpcMode.opc_query:
+			# For Vxi session, use the STB poll and read the header
+			stb = self._write_and_wait_for_opc(query, True, 0)
+			try:
+				self._check_msg_available_after_opc_wait(stb, query, 0, 'get_bin_data_length')
+			except InstrumentErrors.StatusException:
+				return None
+			data_type, header, length = self._parse_bin_data_header(True)
+			self.clear()
+			self.clear_before_read()
+			return length
+		else:
+			with StreamWriter.as_forget() as stream:
+				old_timeout = self.visa_timeout
+				try:
+					self.visa_timeout = 2000
+					self.query_bin_block(query, stream, True)
+				except InstrumentErrors.StatusException:
+					return None
+				finally:
+					self.visa_timeout = old_timeout
+				length = stream.written_len
+		return length
+
 	def read_bin_block(self, stream: StreamWriter, exc_if_not_bin: bool) -> None:
 		"""Reads binary data block to the provided stream. \n
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: if True, the method throws exception if the received data is not binary"""
 		data_type, header, length = self._parse_bin_data_header(exc_if_not_bin)
 		if data_type == ReadDataType.ascii:
-			stream.switch_to_string_data()
+			stream.switch_to_string_data(self.encoding)
 			self._read_unknown_len(stream, True, header)
 		elif data_type == ReadDataType.null:
-			# No data, consider it ASCII, Return empty string, and False (signaling ASCII transfer)
-			stream.switch_to_string_data()
+			# No data, consider it ASCII. Change the stream type to ASCII and return empty string
+			stream.switch_to_string_data(self.encoding)
 		elif data_type == ReadDataType.bin_unknown_len:
 			if not self.vxi_capable:
-				raise Exception(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
+				raise RsInstrException(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
 			self._read_unknown_len(stream, True)
 		elif length == 0:
 			self._flush_junk_data()
 		else:
 			self._read_bin_block_known_len(stream, length)
 
 	def _read_bin_block_known_len(self, stream: StreamWriter, length: int) -> None:
@@ -1027,15 +1206,18 @@
 
 	def query_bin_block(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True) -> None:
 		"""Query binary data block and returns it as byte data. \n
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary"""
 		self.write(query)
-		self.read_bin_block(stream, exc_if_not_bin)
+		try:
+			self.read_bin_block(stream, exc_if_not_bin)
+		except pyvisa.VisaIOError:
+			self._narrow_down_io_tout_error(f"Query bin block '{query.rstrip(self._term_char)}' - ")
 		return
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data.
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary
@@ -1073,14 +1255,28 @@
 			response += char
 			if char in stop_chars:
 				break
 			if self.last_status != pyvisa.constants.StatusCode.success_max_count_read:
 				break
 		return response
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.deassert_gtl)
+		else:
+			self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.asrt_address)
+		else:
+			self.write("&GTR")
+
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
 		return self._session
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/Internal/VisaSessionSim.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/Internal/VisaSessionSim.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""VisaSession for simulated sessions."""
+
 import threading
 from typing import Callable, Dict, AnyStr
 
 from . import InstrumentSettings
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 
@@ -9,14 +11,15 @@
 # noinspection PyMethodMayBeStatic,PyUnusedLocal
 class VisaSessionSim(object):
 	"""Visa session in simulation mode.
 	Provides the properties for the simulation mode.
 	Also serves as a cache for the SCPI command values: If you query a SCPI command value, it returns the last set value by that SCPI command."""
 
 	def __init__(self, resource_name: str, settings: InstrumentSettings, direct_session=None):
+		self.reusing_session = direct_session is not None
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		# noinspection PyTypeChecker
 		self._lock: threading.RLock = None
 
 		# Event handlers
 		# noinspection PyTypeChecker
@@ -25,16 +28,17 @@
 		# noinspection PyTypeChecker
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		self.manufacturer: str = 'Rohde&Schwarz'
-		self._resource_name = resource_name
+		self.resource_name = resource_name
 		self.vxi_capable = True
+		self.encoding = settings.encoding  # default encoder between bytes and string
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self.data_chunk_size = settings.io_segment_size
 
 		self._last_cmd = None
@@ -50,14 +54,17 @@
 			rlock = direct_session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
 			# The existing session did not have a thread lock, assign a new one
 			self.assign_lock(threading.RLock())
 
+		if self.reusing_session:
+			self.resource_name = direct_session.resource_name
+
 	def assign_lock(self, lock: threading.RLock) -> None:
 		"""Assigns the provided thread lock. The lock is only used by the parent class Instrument."""
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
@@ -92,25 +99,30 @@
 		return False
 
 	def query_syst_error(self) -> str or None:
 		"""Returns one response to the SYSTEM:ERROR? query."""
 		return None
 
 	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
-		return []
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
+		return None
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 		return
 
 	def clear(self) -> None:
 		"""Perform VISA viClear conditionally based on the instrument settings."""
 		return
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		self._last_cmd = cmd
 		self._update_cmd_vals_cache(cmd)
 		return
 
 	def query_str(self, query: str) -> str:
@@ -121,15 +133,15 @@
 		return 'Simulating' if cached is None else cached
 
 	def write_with_opc(self, cmd: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self.write(cmd)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		return self.query_str(query)
 
 	def query_opc(self, timeout: int = 0) -> bool:
 		"""Sends *OPC? query and reads the result."""
@@ -160,28 +172,28 @@
 		cached = self._get_cmd_cached_value(query)
 
 		if cached is None:
 			stream.write(bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 65, 66]))
 			self.cached_to_stream = False
 		else:
 			if isinstance(cached, str):
-				stream.switch_to_string_data()
+				stream.switch_to_string_data(self.encoding)
 			stream.write(cached)
 			self.cached_to_stream = True
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data."""
 		self.query_bin_block(query, stream)
 
 	def read_up_to_char(self, stop_chars: bytes, max_cnt: int) -> bytes:
 		"""Reads until one of the stop_chars is read or the max_cnt is reached, or EOT is detected.
 		Returns the read data including the stop character."""
 		return b'Simulating'
 
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
-		return f"Simulating session, resource name '{self._resource_name}'"
+		return f"Simulating session, resource name '{self.resource_name}'"
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
 		return
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/__init__.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,30 @@
 """RsCmwLteMeas instrument driver
-	:version: 3.7.62.23
-	:copyright: 2021 by Rohde & Schwarz GMBH & Co. KG
+	:version: 4.0.110.26
+	:copyright: 2023 by Rohde & Schwarz GMBH & Co. KG
 	:license: MIT, see LICENSE for more details.
 """
 
-__version__ = '3.7.62.23'
+__version__ = '4.0.110.26'
 
 # Main class
 from RsCmwLteMeas.RsCmwLteMeas import RsCmwLteMeas
 
 # Bin data format
 from RsCmwLteMeas.Internal.Conversions import BinIntFormat, BinFloatFormat
 
 # Exceptions
 from RsCmwLteMeas.Internal.InstrumentErrors import RsInstrException, TimeoutException, StatusException, UnexpectedResponseException, ResourceError, DriverValueError
 
 # Callback Event Argument prototypes
 from RsCmwLteMeas.Internal.IoTransferEventArgs import IoTransferEventArgs
 
+# Logging Mode
+from RsCmwLteMeas.Internal.ScpiLogger import LoggingMode
+
 # enums
 from RsCmwLteMeas import enums
 
 # repcaps
 from RsCmwLteMeas import repcap
 
 # Reliability interface
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/enums.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/enums.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from enum import Enum
 
 
 # noinspection SpellCheckingInspection
 class Band(Enum):
-	"""61 Members, OB1 ... OB9"""
+	"""63 Members, OB1 ... OB9"""
 	OB1 = 0
 	OB10 = 1
 	OB11 = 2
 	OB12 = 3
 	OB13 = 4
 	OB14 = 5
 	OB15 = 6
@@ -60,15 +60,17 @@
 	OB70 = 53
 	OB71 = 54
 	OB72 = 55
 	OB73 = 56
 	OB74 = 57
 	OB8 = 58
 	OB85 = 59
-	OB9 = 60
+	OB87 = 60
+	OB88 = 61
+	OB9 = 62
 
 
 # noinspection SpellCheckingInspection
 class CarrAggrLocalOscLocation(Enum):
 	"""3 Members, AUTO ... CECC"""
 	AUTO = 0
 	CACB = 1
@@ -184,18 +186,17 @@
 	"""2 Members, EXTended ... NORMal"""
 	EXTended = 0
 	NORMal = 1
 
 
 # noinspection SpellCheckingInspection
 class DuplexMode(Enum):
-	"""3 Members, FDD ... TDD"""
+	"""2 Members, FDD ... TDD"""
 	FDD = 0
-	FTDD = 1
-	TDD = 2
+	TDD = 1
 
 
 # noinspection SpellCheckingInspection
 class FrameStructure(Enum):
 	"""2 Members, T1 ... T2"""
 	T1 = 0
 	T2 = 1
@@ -299,14 +300,23 @@
 	Q16 = 0
 	Q256 = 1
 	Q64 = 2
 	QPSK = 3
 
 
 # noinspection SpellCheckingInspection
+class Nbandwidth(Enum):
+	"""4 Members, M010 ... M080"""
+	M010 = 0
+	M020 = 1
+	M040 = 2
+	M080 = 3
+
+
+# noinspection SpellCheckingInspection
 class NetworkSigValue(Enum):
 	"""32 Members, NS01 ... NS32"""
 	NS01 = 0
 	NS02 = 1
 	NS03 = 2
 	NS04 = 3
 	NS05 = 4
@@ -636,14 +646,21 @@
 class ParameterSetMode(Enum):
 	"""2 Members, GLOBal ... LIST"""
 	GLOBal = 0
 	LIST = 1
 
 
 # noinspection SpellCheckingInspection
+class Path(Enum):
+	"""2 Members, NETWork ... STANdalone"""
+	NETWork = 0
+	STANdalone = 1
+
+
+# noinspection SpellCheckingInspection
 class PeriodPreamble(Enum):
 	"""3 Members, MS05 ... MS20"""
 	MS05 = 0
 	MS10 = 1
 	MS20 = 2
 
 
@@ -657,22 +674,23 @@
 	F2A = 4
 	F2B = 5
 	F3 = 6
 
 
 # noinspection SpellCheckingInspection
 class RbTableChannelType(Enum):
-	"""7 Members, DL ... SSUB"""
+	"""8 Members, DL ... SSUB"""
 	DL = 0
 	NONE = 1
-	PSCCh = 2
-	PSSCh = 3
-	PUCCh = 4
-	PUSCh = 5
-	SSUB = 6
+	PSBCh = 2
+	PSCCh = 3
+	PSSCh = 4
+	PUCCh = 5
+	PUSCh = 6
+	SSUB = 7
 
 
 # noinspection SpellCheckingInspection
 class Rbw(Enum):
 	"""3 Members, K030 ... M1"""
 	K030 = 0
 	K100 = 1
@@ -723,23 +741,24 @@
 	UFL = 7
 	ULEL = 8
 	ULEU = 9
 
 
 # noinspection SpellCheckingInspection
 class RetriggerFlag(Enum):
-	"""3 Members, IFPower ... ON"""
-	IFPower = 0
-	OFF = 1
-	ON = 2
+	"""4 Members, IFPNarrow ... ON"""
+	IFPNarrow = 0
+	IFPower = 1
+	OFF = 2
+	ON = 3
 
 
 # noinspection SpellCheckingInspection
 class RxConnector(Enum):
-	"""154 Members, I11I ... RH8"""
+	"""163 Members, I11I ... RH8"""
 	I11I = 0
 	I13I = 1
 	I15I = 2
 	I17I = 3
 	I21I = 4
 	I23I = 5
 	I25I = 6
@@ -748,152 +767,161 @@
 	I33I = 9
 	I35I = 10
 	I37I = 11
 	I41I = 12
 	I43I = 13
 	I45I = 14
 	I47I = 15
-	IF1 = 16
-	IF2 = 17
-	IF3 = 18
-	IQ1I = 19
-	IQ3I = 20
-	IQ5I = 21
-	IQ7I = 22
-	R11 = 23
-	R11C = 24
-	R12 = 25
-	R12C = 26
-	R12I = 27
-	R13 = 28
-	R13C = 29
-	R14 = 30
-	R14C = 31
-	R14I = 32
-	R15 = 33
-	R16 = 34
-	R17 = 35
-	R18 = 36
-	R21 = 37
-	R21C = 38
-	R22 = 39
-	R22C = 40
-	R22I = 41
-	R23 = 42
-	R23C = 43
-	R24 = 44
-	R24C = 45
-	R24I = 46
-	R25 = 47
-	R26 = 48
-	R27 = 49
-	R28 = 50
-	R31 = 51
-	R31C = 52
-	R32 = 53
-	R32C = 54
-	R32I = 55
-	R33 = 56
-	R33C = 57
-	R34 = 58
-	R34C = 59
-	R34I = 60
-	R35 = 61
-	R36 = 62
-	R37 = 63
-	R38 = 64
-	R41 = 65
-	R41C = 66
-	R42 = 67
-	R42C = 68
-	R42I = 69
-	R43 = 70
-	R43C = 71
-	R44 = 72
-	R44C = 73
-	R44I = 74
-	R45 = 75
-	R46 = 76
-	R47 = 77
-	R48 = 78
-	RA1 = 79
-	RA2 = 80
-	RA3 = 81
-	RA4 = 82
-	RA5 = 83
-	RA6 = 84
-	RA7 = 85
-	RA8 = 86
-	RB1 = 87
-	RB2 = 88
-	RB3 = 89
-	RB4 = 90
-	RB5 = 91
-	RB6 = 92
-	RB7 = 93
-	RB8 = 94
-	RC1 = 95
-	RC2 = 96
-	RC3 = 97
-	RC4 = 98
-	RC5 = 99
-	RC6 = 100
-	RC7 = 101
-	RC8 = 102
-	RD1 = 103
-	RD2 = 104
-	RD3 = 105
-	RD4 = 106
-	RD5 = 107
-	RD6 = 108
-	RD7 = 109
-	RD8 = 110
-	RE1 = 111
-	RE2 = 112
-	RE3 = 113
-	RE4 = 114
-	RE5 = 115
-	RE6 = 116
-	RE7 = 117
-	RE8 = 118
-	RF1 = 119
-	RF1C = 120
-	RF2 = 121
-	RF2C = 122
-	RF2I = 123
-	RF3 = 124
-	RF3C = 125
-	RF4 = 126
-	RF4C = 127
-	RF4I = 128
-	RF5 = 129
-	RF5C = 130
-	RF6 = 131
-	RF6C = 132
-	RF7 = 133
-	RF8 = 134
-	RFAC = 135
-	RFBC = 136
-	RFBI = 137
-	RG1 = 138
-	RG2 = 139
-	RG3 = 140
-	RG4 = 141
-	RG5 = 142
-	RG6 = 143
-	RG7 = 144
-	RG8 = 145
-	RH1 = 146
-	RH2 = 147
-	RH3 = 148
-	RH4 = 149
-	RH5 = 150
-	RH6 = 151
-	RH7 = 152
-	RH8 = 153
+	IFI1 = 16
+	IFI2 = 17
+	IFI3 = 18
+	IFI4 = 19
+	IFI5 = 20
+	IFI6 = 21
+	IQ1I = 22
+	IQ3I = 23
+	IQ5I = 24
+	IQ7I = 25
+	R10D = 26
+	R11 = 27
+	R11C = 28
+	R11D = 29
+	R12 = 30
+	R12C = 31
+	R12D = 32
+	R12I = 33
+	R13 = 34
+	R13C = 35
+	R14 = 36
+	R14C = 37
+	R14I = 38
+	R15 = 39
+	R16 = 40
+	R17 = 41
+	R18 = 42
+	R21 = 43
+	R21C = 44
+	R22 = 45
+	R22C = 46
+	R22I = 47
+	R23 = 48
+	R23C = 49
+	R24 = 50
+	R24C = 51
+	R24I = 52
+	R25 = 53
+	R26 = 54
+	R27 = 55
+	R28 = 56
+	R31 = 57
+	R31C = 58
+	R32 = 59
+	R32C = 60
+	R32I = 61
+	R33 = 62
+	R33C = 63
+	R34 = 64
+	R34C = 65
+	R34I = 66
+	R35 = 67
+	R36 = 68
+	R37 = 69
+	R38 = 70
+	R41 = 71
+	R41C = 72
+	R42 = 73
+	R42C = 74
+	R42I = 75
+	R43 = 76
+	R43C = 77
+	R44 = 78
+	R44C = 79
+	R44I = 80
+	R45 = 81
+	R46 = 82
+	R47 = 83
+	R48 = 84
+	RA1 = 85
+	RA2 = 86
+	RA3 = 87
+	RA4 = 88
+	RA5 = 89
+	RA6 = 90
+	RA7 = 91
+	RA8 = 92
+	RB1 = 93
+	RB2 = 94
+	RB3 = 95
+	RB4 = 96
+	RB5 = 97
+	RB6 = 98
+	RB7 = 99
+	RB8 = 100
+	RC1 = 101
+	RC2 = 102
+	RC3 = 103
+	RC4 = 104
+	RC5 = 105
+	RC6 = 106
+	RC7 = 107
+	RC8 = 108
+	RD1 = 109
+	RD2 = 110
+	RD3 = 111
+	RD4 = 112
+	RD5 = 113
+	RD6 = 114
+	RD7 = 115
+	RD8 = 116
+	RE1 = 117
+	RE2 = 118
+	RE3 = 119
+	RE4 = 120
+	RE5 = 121
+	RE6 = 122
+	RE7 = 123
+	RE8 = 124
+	RF1 = 125
+	RF1C = 126
+	RF2 = 127
+	RF2C = 128
+	RF2I = 129
+	RF3 = 130
+	RF3C = 131
+	RF4 = 132
+	RF4C = 133
+	RF4I = 134
+	RF5 = 135
+	RF5C = 136
+	RF6 = 137
+	RF6C = 138
+	RF7 = 139
+	RF7C = 140
+	RF8 = 141
+	RF8C = 142
+	RF9C = 143
+	RFAC = 144
+	RFBC = 145
+	RFBI = 146
+	RG1 = 147
+	RG2 = 148
+	RG3 = 149
+	RG4 = 150
+	RG5 = 151
+	RG6 = 152
+	RG7 = 153
+	RG8 = 154
+	RH1 = 155
+	RH2 = 156
+	RH3 = 157
+	RH4 = 158
+	RH5 = 159
+	RH6 = 160
+	RH7 = 161
+	RH8 = 162
 
 
 # noinspection SpellCheckingInspection
 class RxConverter(Enum):
 	"""40 Members, IRX1 ... RX44"""
 	IRX1 = 0
 	IRX11 = 1
@@ -944,27 +972,37 @@
 	MAPRotocol = 1
 	NAV = 2
 	SALone = 3
 
 
 # noinspection SpellCheckingInspection
 class SegmentChannelTypeExtended(Enum):
-	"""5 Members, AUTO ... PUSCh"""
+	"""6 Members, AUTO ... PUSCh"""
 	AUTO = 0
-	PSCCh = 1
-	PSSCh = 2
-	PUCCh = 3
-	PUSCh = 4
+	PSBCh = 1
+	PSCCh = 2
+	PSSCh = 3
+	PUCCh = 4
+	PUSCh = 5
+
+
+# noinspection SpellCheckingInspection
+class Sharing(Enum):
+	"""3 Members, FSHared ... OCONnection"""
+	FSHared = 0
+	NSHared = 1
+	OCONnection = 2
 
 
 # noinspection SpellCheckingInspection
 class SidelinkChannelType(Enum):
-	"""2 Members, PSCCh ... PSSCh"""
-	PSCCh = 0
-	PSSCh = 1
+	"""3 Members, PSBCh ... PSSCh"""
+	PSBCh = 0
+	PSCCh = 1
+	PSSCh = 2
 
 
 # noinspection SpellCheckingInspection
 class SignalSlope(Enum):
 	"""2 Members, FEDGe ... REDGe"""
 	FEDGe = 0
 	REDGe = 1
@@ -988,19 +1026,42 @@
 class SyncMode(Enum):
 	"""2 Members, ENHanced ... NORMal"""
 	ENHanced = 0
 	NORMal = 1
 
 
 # noinspection SpellCheckingInspection
+class TargetMainState(Enum):
+	"""3 Members, OFF ... RUN"""
+	OFF = 0
+	RDY = 1
+	RUN = 2
+
+
+# noinspection SpellCheckingInspection
+class TargetSyncState(Enum):
+	"""2 Members, ADJusted ... PENDing"""
+	ADJusted = 0
+	PENDing = 1
+
+
+# noinspection SpellCheckingInspection
 class TimeMask(Enum):
 	"""3 Members, GOO ... SBLanking"""
 	GOO = 0
 	PPSRs = 1
 	SBLanking = 2
 
 
 # noinspection SpellCheckingInspection
+class TraceSelect(Enum):
+	"""3 Members, AVERage ... MAXimum"""
+	AVERage = 0
+	CURRent = 1
+	MAXimum = 2
+
+
+# noinspection SpellCheckingInspection
 class UplinkChannelType(Enum):
 	"""2 Members, PUCCh ... PUSCh"""
 	PUCCh = 0
 	PUSCh = 1
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas/repcap.py` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas/repcap.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from enum import Enum
-from .Internal.RepeatedCapability import VALUE_DEFAULT
-from .Internal.RepeatedCapability import VALUE_EMPTY
+# noinspection PyPep8Naming
+from .Internal.RepeatedCapability import VALUE_DEFAULT as DefaultRepCap
+# noinspection PyPep8Naming
+from .Internal.RepeatedCapability import VALUE_EMPTY as EmptyRepCap
 
 
 # noinspection SpellCheckingInspection
 class Instance(Enum):
-	"""Global Repeated capability Instance \n
-	Selects the instrument"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Global Repeated capability Instance"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Inst1 = 1
 	Inst2 = 2
 	Inst3 = 3
 	Inst4 = 4
 	Inst5 = 5
 	Inst6 = 6
 	Inst7 = 7
@@ -24,19 +25,27 @@
 	Inst13 = 13
 	Inst14 = 14
 	Inst15 = 15
 	Inst16 = 16
 
 
 # noinspection SpellCheckingInspection
+class AbsMarker(Enum):
+	"""Repeated capability AbsMarker"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
+	Nr1 = 1
+	Nr2 = 2
+
+
+# noinspection SpellCheckingInspection
 class Area(Enum):
-	"""Repeated capability Area \n
-	Area Number"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Area"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
 	Nr4 = 4
 	Nr5 = 5
 	Nr6 = 6
 	Nr7 = 7
@@ -45,74 +54,78 @@
 	Nr10 = 10
 	Nr11 = 11
 	Nr12 = 12
 
 
 # noinspection SpellCheckingInspection
 class CarrierComponent(Enum):
-	"""Repeated capability CarrierComponent \n
-	Carrier"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability CarrierComponent"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
 	Nr4 = 4
 
 
 # noinspection SpellCheckingInspection
 class ChannelBw(Enum):
-	"""Repeated capability ChannelBw \n
-	Ch Bandwidth"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability ChannelBw"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Bw14 = 14
 	Bw30 = 30
 	Bw50 = 50
 	Bw100 = 100
 	Bw150 = 150
 	Bw200 = 200
 
 
 # noinspection SpellCheckingInspection
+class DeltaMarker(Enum):
+	"""Repeated capability DeltaMarker"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
+	Nr1 = 1
+	Nr2 = 2
+
+
+# noinspection SpellCheckingInspection
 class Difference(Enum):
-	"""Repeated capability Difference \n
-	Ripple"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Difference"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class EutraBand(Enum):
-	"""Repeated capability EutraBand \n
-	E-UTRA bands"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability EutraBand"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr30 = 30
 	Nr50 = 50
 
 
 # noinspection SpellCheckingInspection
 class FirstChannelBw(Enum):
-	"""Repeated capability FirstChannelBw \n
-	Ch Bandwidth1"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability FirstChannelBw"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
+	Bw100 = 100
 	Bw150 = 150
 	Bw200 = 200
 
 
 # noinspection SpellCheckingInspection
 class Limit(Enum):
-	"""Repeated capability Limit \n
-	Area"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Limit"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
 	Nr4 = 4
 	Nr5 = 5
 	Nr6 = 6
 	Nr7 = 7
@@ -121,38 +134,35 @@
 	Nr10 = 10
 	Nr11 = 11
 	Nr12 = 12
 
 
 # noinspection SpellCheckingInspection
 class MaxRange(Enum):
-	"""Repeated capability MaxRange \n
-	Ripple"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability MaxRange"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class MinRange(Enum):
-	"""Repeated capability MinRange \n
-	Ripple"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability MinRange"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class Preamble(Enum):
-	"""Repeated capability Preamble \n
-	Preamble Number"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Preamble"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
 	Nr4 = 4
 	Nr5 = 5
 	Nr6 = 6
 	Nr7 = 7
@@ -549,113 +559,104 @@
 	Nr398 = 398
 	Nr399 = 399
 	Nr400 = 400
 
 
 # noinspection SpellCheckingInspection
 class PreambleFormat(Enum):
-	"""Repeated capability PreambleFormat \n
-	Preamble Format"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability PreambleFormat"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Fmt1 = 1
 	Fmt2 = 2
 	Fmt3 = 3
 	Fmt4 = 4
 	Fmt5 = 5
 
 
 # noinspection SpellCheckingInspection
 class QAMmodOrder(Enum):
-	"""Repeated capability QAMmodOrder \n
-	Modulation Order"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability QAMmodOrder"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Qam16 = 16
 	Qam64 = 64
 	Qam256 = 256
 
 
 # noinspection SpellCheckingInspection
 class RBcount(Enum):
-	"""Repeated capability RBcount \n
-	Number"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability RBcount"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class RBoffset(Enum):
-	"""Repeated capability RBoffset \n
-	Number"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability RBoffset"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class RBWkHz(Enum):
-	"""Repeated capability RBWkHz \n
-	RBW in kHz"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability RBWkHz"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Rbw30 = 30
 	Rbw50 = 50
 	Rbw100 = 100
 	Rbw150 = 150
 	Rbw200 = 200
 	Rbw1000 = 1000
 
 
 # noinspection SpellCheckingInspection
 class Ripple(Enum):
-	"""Repeated capability Ripple \n
-	Ripple"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Ripple"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class SecondaryCC(Enum):
-	"""Repeated capability SecondaryCC \n
-	Carrier"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability SecondaryCC"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	CC1 = 1
 	CC2 = 2
 	CC3 = 3
 	CC4 = 4
 	CC5 = 5
 	CC6 = 6
 	CC7 = 7
 
 
 # noinspection SpellCheckingInspection
 class SecondChannelBw(Enum):
-	"""Repeated capability SecondChannelBw \n
-	Ch Bandwidth2"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability SecondChannelBw"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Bw50 = 50
 	Bw100 = 100
 	Bw150 = 150
 	Bw200 = 200
 
 
 # noinspection SpellCheckingInspection
 class Segment(Enum):
-	"""Repeated capability Segment \n
-	Segment nr."""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Segment"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
 	Nr4 = 4
 	Nr5 = 5
 	Nr6 = 6
 	Nr7 = 7
@@ -780,37 +781,34 @@
 	Nr126 = 126
 	Nr127 = 127
 	Nr128 = 128
 
 
 # noinspection SpellCheckingInspection
 class Table(Enum):
-	"""Repeated capability Table \n
-	Add Limit Table"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Table"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
 	Nr4 = 4
 	Nr5 = 5
 
 
 # noinspection SpellCheckingInspection
 class ThirdChannelBw(Enum):
-	"""Repeated capability ThirdChannelBw \n
-	Ch Bandwidth3"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability ThirdChannelBw"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Bw100 = 100
 	Bw150 = 150
 	Bw200 = 200
 
 
 # noinspection SpellCheckingInspection
 class UtraAdjChannel(Enum):
-	"""Repeated capability UtraAdjChannel \n
-	UTRA1/2"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability UtraAdjChannel"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Ch1 = 1
 	Ch2 = 2
```

### Comparing `RsCmwLteMeas-3.7.62.23/RsCmwLteMeas.egg-info/SOURCES.txt` & `RsCmwLteMeas-4.0.110/RsCmwLteMeas.egg-info/SOURCES.txt`

 * *Files 14% similar despite different names*

```diff
@@ -1,888 +1,740 @@
-README.md
+README.rst
 setup.py
 RsCmwLteMeas/RsCmwLteMeas.py
 RsCmwLteMeas/__init__.py
 RsCmwLteMeas/enums.py
 RsCmwLteMeas/repcap.py
 RsCmwLteMeas.egg-info/PKG-INFO
 RsCmwLteMeas.egg-info/SOURCES.txt
 RsCmwLteMeas.egg-info/dependency_links.txt
 RsCmwLteMeas.egg-info/requires.txt
 RsCmwLteMeas.egg-info/top_level.txt
 RsCmwLteMeas/CustomFiles/__init__.py
 RsCmwLteMeas/CustomFiles/events.py
 RsCmwLteMeas/CustomFiles/reliability.py
 RsCmwLteMeas/CustomFiles/utilities.py
-RsCmwLteMeas/Implementations/Configure.py
-RsCmwLteMeas/Implementations/MultiEval.py
-RsCmwLteMeas/Implementations/Prach.py
-RsCmwLteMeas/Implementations/Route.py
-RsCmwLteMeas/Implementations/Sense.py
-RsCmwLteMeas/Implementations/Srs.py
-RsCmwLteMeas/Implementations/Trigger.py
 RsCmwLteMeas/Implementations/__init__.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/Cc.py
-RsCmwLteMeas/Implementations/Configure_/Emtc.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval.py
-RsCmwLteMeas/Implementations/Configure_/Pcc.py
-RsCmwLteMeas/Implementations/Configure_/Prach.py
-RsCmwLteMeas/Implementations/Configure_/RfSettings.py
-RsCmwLteMeas/Implementations/Configure_/Srs.py
-RsCmwLteMeas/Implementations/Configure_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Mcarrier.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Mode.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/Aggregated.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/Scc.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/AcSpacing.py
-RsCmwLteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/Cc_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/Cc_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Bler.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/NsValue.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pcc.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Power.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Srs.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Tmode.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc_/PlcId.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Cc_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/Ocombination.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EsFlatness.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EvMagnitude.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/FreqError.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/IqOffset.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Merror.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Perror.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Sflatness.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/IqOffset.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/Ibe.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/AtTolerance.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/Ocombination.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/Sidelink.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/Ocombination.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Aclr.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Cc.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Modulation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Pmonitor.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Power.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scc.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SeMask.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Tdd.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/AcSpacing.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/Enhanced.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/Nband.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/Sidelink.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/Connector.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/Pusch.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/ChannelBw.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/AeoPower.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Nrb.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Orb.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Nrb.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Orb.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result_/EvMagnitude.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Result_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount_/Spectrum.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Scount_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/Aclr.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/SeMask.py
-RsCmwLteMeas/Implementations/Configure_/MultiEval_/Spectrum_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Limit.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/PfOffset.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Power.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Result.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Scount.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/Sindex.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/Pformat.py
-RsCmwLteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc.py
-RsCmwLteMeas/Implementations/Configure_/RfSettings_/Pcc.py
-RsCmwLteMeas/Implementations/Configure_/RfSettings_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc_/Frequency.py
-RsCmwLteMeas/Implementations/Configure_/RfSettings_/Cc_/__init__.py
-RsCmwLteMeas/Implementations/Configure_/Srs_/Limit.py
-RsCmwLteMeas/Implementations/Configure_/Srs_/Scount.py
-RsCmwLteMeas/Implementations/Configure_/Srs_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Aclr.py
-RsCmwLteMeas/Implementations/MultiEval_/Bler.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy.py
-RsCmwLteMeas/Implementations/MultiEval_/Merror.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics.py
-RsCmwLteMeas/Implementations/MultiEval_/Perror.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask.py
-RsCmwLteMeas/Implementations/MultiEval_/State.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace.py
-RsCmwLteMeas/Implementations/MultiEval_/VfThroughput.py
-RsCmwLteMeas/Implementations/MultiEval_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Aclr_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/Aclr_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/Aclr_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current_/ScIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/EsFlatness_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/Evmc_/Peak_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Sreliability.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dmodulation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/SchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Rms.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/ScIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dmodulation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/SchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Peak.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Rms.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Length.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Start.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/All.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Merror_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Merror_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Merror_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Merror_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Dmodulation.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/SchType.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/Modulation_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Perror_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Perror_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Perror_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Perror_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Dallocation.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/DchType.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Extreme.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/StandardDev.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/All.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Negativ.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Positiv.py
-RsCmwLteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/State_/All.py
-RsCmwLteMeas/Implementations/MultiEval_/State_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Evmc.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Aclr_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/Phase.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Cc.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iemissions_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/High.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/Low.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Iq_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Cc.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Cc.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/RbaTable_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/__init__.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Average.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Current.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Maximum.py
-RsCmwLteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Modulation.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics.py
-RsCmwLteMeas/Implementations/Prach_/State.py
-RsCmwLteMeas/Implementations/Prach_/Trace.py
-RsCmwLteMeas/Implementations/Prach_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Average.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Current.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Extreme.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Preamble.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/StandardDev.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset_/Preamble.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/DpfOffset_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex_/Preamble.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/DsIndex_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation_/Preamble.py
-RsCmwLteMeas/Implementations/Prach_/Modulation_/Scorrelation_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Average.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Current.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Maximum.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics_/Minimum.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics_/StandardDev.py
-RsCmwLteMeas/Implementations/Prach_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/State_/All.py
-RsCmwLteMeas/Implementations/Prach_/State_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/EvPreamble.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Evm.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Iq.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Merror.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Perror.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/PvPreamble.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Average.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Current.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/Maximum.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Evm_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Average.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Current.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/Maximum.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Merror_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Average.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Current.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/Maximum.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Average.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Current.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/Maximum.py
-RsCmwLteMeas/Implementations/Prach_/Trace_/Perror_/__init__.py
-RsCmwLteMeas/Implementations/Route_/Scenario.py
-RsCmwLteMeas/Implementations/Route_/__init__.py
-RsCmwLteMeas/Implementations/Route_/Scenario_/CombinedSignalPath.py
-RsCmwLteMeas/Implementations/Route_/Scenario_/MaProtocol.py
-RsCmwLteMeas/Implementations/Route_/Scenario_/__init__.py
-RsCmwLteMeas/Implementations/Sense_/CarrierAggregation.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval.py
-RsCmwLteMeas/Implementations/Sense_/__init__.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval_/__init__.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/__init__.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/Rbw.py
-RsCmwLteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/__init__.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics.py
-RsCmwLteMeas/Implementations/Srs_/State.py
-RsCmwLteMeas/Implementations/Srs_/Trace.py
-RsCmwLteMeas/Implementations/Srs_/__init__.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Average.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Current.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Maximum.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics_/Minimum.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics_/StandardDev.py
-RsCmwLteMeas/Implementations/Srs_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/Srs_/State_/All.py
-RsCmwLteMeas/Implementations/Srs_/State_/__init__.py
-RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics.py
-RsCmwLteMeas/Implementations/Srs_/Trace_/__init__.py
-RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Average.py
-RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Current.py
-RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/Maximum.py
-RsCmwLteMeas/Implementations/Srs_/Trace_/Pdynamics_/__init__.py
-RsCmwLteMeas/Implementations/Trigger_/MultiEval.py
-RsCmwLteMeas/Implementations/Trigger_/Prach.py
-RsCmwLteMeas/Implementations/Trigger_/Srs.py
-RsCmwLteMeas/Implementations/Trigger_/__init__.py
-RsCmwLteMeas/Implementations/Trigger_/MultiEval_/Catalog.py
-RsCmwLteMeas/Implementations/Trigger_/MultiEval_/ListPy.py
-RsCmwLteMeas/Implementations/Trigger_/MultiEval_/__init__.py
-RsCmwLteMeas/Implementations/Trigger_/Prach_/Catalog.py
-RsCmwLteMeas/Implementations/Trigger_/Prach_/__init__.py
-RsCmwLteMeas/Implementations/Trigger_/Srs_/Catalog.py
-RsCmwLteMeas/Implementations/Trigger_/Srs_/__init__.py
+RsCmwLteMeas/Implementations/Configure/Emtc.py
+RsCmwLteMeas/Implementations/Configure/Network.py
+RsCmwLteMeas/Implementations/Configure/Pcc.py
+RsCmwLteMeas/Implementations/Configure/__init__.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Mcarrier.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Mode.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/Aggregated.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Frequency/__init__.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/Scc.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Maping/__init__.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/AcSpacing.py
+RsCmwLteMeas/Implementations/Configure/CarrierAggregation/Scc/__init__.py
+RsCmwLteMeas/Implementations/Configure/Cc/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/Cc/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/MsubFrames.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/NsValue.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Pcc.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Power.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Srs.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Tmode.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/Sframes.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Bler/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/PlcId.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Cc/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/Ocombination.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/Ocombination.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Pdynamics/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/EsFlatness.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/EvMagnitude.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/FreqError.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/IqOffset.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Merror.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Perror.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Sflatness.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/IqOffset.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qam/Ibe/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/EvMagnitude.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/IqOffset.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Merror.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Perror.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Ibe/IqOffset.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/Qpsk/Ibe/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/AtTolerance.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/Ocombination.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/ChannelBw2nd.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/Sidelink.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/Ocombination.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Lrange.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/SingleCmw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Aclr.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Cc.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Cidx.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Modulation.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/PlcId.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Pmonitor.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Power.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Scc.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SeMask.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Setup.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Tdd.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/AcSpacing.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/Enhanced.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/Nband.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/Emtc/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/Sidelink.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/RbAllocation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/Connector.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/ListPy/Segment/SingleCmw/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/CarrierAggregation.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/Pusch.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EePeriods/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/ChannelBw.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Modulation/EwLength/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/AeoPower.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Nrb.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Orb.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/Nrb.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/Orb.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/RbAllocation/Mcluster/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Result/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Result/EvMagnitude/EvmSymbol.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Result/EvMagnitude/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/Spectrum.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Scount/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/SeMask.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/__init__.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/Enable.py
+RsCmwLteMeas/Implementations/Configure/MultiEval/Spectrum/Aclr/__init__.py
+RsCmwLteMeas/Implementations/Configure/Prach/PfOffset.py
+RsCmwLteMeas/Implementations/Configure/Prach/Power.py
+RsCmwLteMeas/Implementations/Configure/Prach/Result.py
+RsCmwLteMeas/Implementations/Configure/Prach/Scount.py
+RsCmwLteMeas/Implementations/Configure/Prach/__init__.py
+RsCmwLteMeas/Implementations/Configure/Prach/Limit/EvMagnitude.py
+RsCmwLteMeas/Implementations/Configure/Prach/Limit/Merror.py
+RsCmwLteMeas/Implementations/Configure/Prach/Limit/Pdynamics.py
+RsCmwLteMeas/Implementations/Configure/Prach/Limit/Perror.py
+RsCmwLteMeas/Implementations/Configure/Prach/Limit/__init__.py
+RsCmwLteMeas/Implementations/Configure/Prach/Modulation/Sindex.py
+RsCmwLteMeas/Implementations/Configure/Prach/Modulation/__init__.py
+RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/Pformat.py
+RsCmwLteMeas/Implementations/Configure/Prach/Modulation/EwLength/__init__.py
+RsCmwLteMeas/Implementations/Configure/RfSettings/Pcc.py
+RsCmwLteMeas/Implementations/Configure/RfSettings/__init__.py
+RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/Frequency.py
+RsCmwLteMeas/Implementations/Configure/RfSettings/Cc/__init__.py
+RsCmwLteMeas/Implementations/Configure/Srs/Scount.py
+RsCmwLteMeas/Implementations/Configure/Srs/__init__.py
+RsCmwLteMeas/Implementations/Configure/Srs/Limit/Pdynamics.py
+RsCmwLteMeas/Implementations/Configure/Srs/Limit/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Bler.py
+RsCmwLteMeas/Implementations/MultiEval/VfThroughput.py
+RsCmwLteMeas/Implementations/MultiEval/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Aclr/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Aclr/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Aclr/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/Aclr/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/Aclr/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/Merror.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/Pdynamics.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/Perror.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/EvMagnitude/Peak.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/EvMagnitude/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/Pmonitor/Cc.py
+RsCmwLteMeas/Implementations/MultiEval/Amarker/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/Merror.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pdynamics.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/Perror.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/EvMagnitude/Peak.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/EvMagnitude/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pmonitor/Cc.py
+RsCmwLteMeas/Implementations/MultiEval/Dmarker/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Average.py
+RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/EsFlatness/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/EsFlatness/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/ScIndex.py
+RsCmwLteMeas/Implementations/MultiEval/EsFlatness/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Average.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Current.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Average.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Current.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/EvMagnitude/Peak/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Evmc/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/Evmc/Peak/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Average.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Current/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/InbandEmission/Cc/Margin/Extreme/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Sreliability.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Negativ/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Eutra/Positiv/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Negativ/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Aclr/Utra/Positiv/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Difference/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Maxr/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Minr/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/Ripple/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/InbandEmission/Margin/RbIndex/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Dmodulation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/SchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Peak/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Evm/Rms/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/FreqError/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/IqOffset/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Peak/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Merror/Rms/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Peak/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/High/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Perror/Rms/Low/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Ppower/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Psd/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Terror/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Modulation/Tpower/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/Peak.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/Rms.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Power/TxPower/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Negativ/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Margin/Area/Positiv/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/Obw/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/SeMask/TxPower/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Aclr/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/ScIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/EsFlatness/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/RbIndex.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Dmodulation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/SchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Modulation/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Peak.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Rms.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/Length.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/Start.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Pmonitor/Array/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/Power/Cc/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Average.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Current.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/All.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/Negativ.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/Positiv.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Average/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/Negativ.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/Positiv.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Negativ.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Positiv.py
+RsCmwLteMeas/Implementations/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Merror/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Merror/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Merror/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Merror/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/Dmodulation.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/SchType.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/Modulation/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Pdynamics/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/Pdynamics/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Perror/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Perror/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Perror/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Perror/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/Minimum.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/Pmonitor/Cc/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Merror.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pdynamics.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Perror.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/EvMagnitude/Peak.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/EvMagnitude/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/Cc.py
+RsCmwLteMeas/Implementations/MultiEval/ReferenceMarker/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Average.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Current.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Dallocation.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/DchType.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Extreme.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/StandardDev.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/All.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/Negativ.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/Positiv.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Average/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/Negativ.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/Positiv.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Current/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/Negativ.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/Positiv.py
+RsCmwLteMeas/Implementations/MultiEval/SeMask/Margin/Minimum/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/State/All.py
+RsCmwLteMeas/Implementations/MultiEval/State/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Evmc.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Aclr/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/Phase.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/EsFlatness/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/EvmSymbol/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/Cc.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Iemissions/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/High.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/Low.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Iq/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/Cc.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/Pmonitor/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/Cc.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/RbaTable/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/__init__.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Average.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Current.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/Maximum.py
+RsCmwLteMeas/Implementations/MultiEval/Trace/SeMask/Rbw/__init__.py
+RsCmwLteMeas/Implementations/Prach/__init__.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Average.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Current.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Maximum.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/__init__.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/Average.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/Current.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/Maximum.py
+RsCmwLteMeas/Implementations/Prach/EvmSymbol/Peak/__init__.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Average.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Current.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Extreme.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Nsymbol.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Preamble.py
+RsCmwLteMeas/Implementations/Prach/Modulation/StandardDev.py
+RsCmwLteMeas/Implementations/Prach/Modulation/__init__.py
+RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/Preamble.py
+RsCmwLteMeas/Implementations/Prach/Modulation/DpfOffset/__init__.py
+RsCmwLteMeas/Implementations/Prach/Modulation/DsIndex/Preamble.py
+RsCmwLteMeas/Implementations/Prach/Modulation/DsIndex/__init__.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/Preamble.py
+RsCmwLteMeas/Implementations/Prach/Modulation/Scorrelation/__init__.py
+RsCmwLteMeas/Implementations/Prach/Pdynamics/Average.py
+RsCmwLteMeas/Implementations/Prach/Pdynamics/Current.py
+RsCmwLteMeas/Implementations/Prach/Pdynamics/Maximum.py
+RsCmwLteMeas/Implementations/Prach/Pdynamics/Minimum.py
+RsCmwLteMeas/Implementations/Prach/Pdynamics/StandardDev.py
+RsCmwLteMeas/Implementations/Prach/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/Prach/State/All.py
+RsCmwLteMeas/Implementations/Prach/State/__init__.py
+RsCmwLteMeas/Implementations/Prach/Trace/EvPreamble.py
+RsCmwLteMeas/Implementations/Prach/Trace/Iq.py
+RsCmwLteMeas/Implementations/Prach/Trace/PvPreamble.py
+RsCmwLteMeas/Implementations/Prach/Trace/__init__.py
+RsCmwLteMeas/Implementations/Prach/Trace/Evm/Average.py
+RsCmwLteMeas/Implementations/Prach/Trace/Evm/Current.py
+RsCmwLteMeas/Implementations/Prach/Trace/Evm/Maximum.py
+RsCmwLteMeas/Implementations/Prach/Trace/Evm/__init__.py
+RsCmwLteMeas/Implementations/Prach/Trace/Merror/Average.py
+RsCmwLteMeas/Implementations/Prach/Trace/Merror/Current.py
+RsCmwLteMeas/Implementations/Prach/Trace/Merror/Maximum.py
+RsCmwLteMeas/Implementations/Prach/Trace/Merror/__init__.py
+RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Average.py
+RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Current.py
+RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/Maximum.py
+RsCmwLteMeas/Implementations/Prach/Trace/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/Prach/Trace/Perror/Average.py
+RsCmwLteMeas/Implementations/Prach/Trace/Perror/Current.py
+RsCmwLteMeas/Implementations/Prach/Trace/Perror/Maximum.py
+RsCmwLteMeas/Implementations/Prach/Trace/Perror/__init__.py
+RsCmwLteMeas/Implementations/Route/__init__.py
+RsCmwLteMeas/Implementations/Route/Scenario/CombinedSignalPath.py
+RsCmwLteMeas/Implementations/Route/Scenario/MaProtocol.py
+RsCmwLteMeas/Implementations/Route/Scenario/Salone.py
+RsCmwLteMeas/Implementations/Route/Scenario/__init__.py
+RsCmwLteMeas/Implementations/Sense/CarrierAggregation.py
+RsCmwLteMeas/Implementations/Sense/__init__.py
+RsCmwLteMeas/Implementations/Sense/MultiEval/__init__.py
+RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/__init__.py
+RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/SeMask/Rbw.py
+RsCmwLteMeas/Implementations/Sense/MultiEval/Spectrum/SeMask/__init__.py
+RsCmwLteMeas/Implementations/Srs/__init__.py
+RsCmwLteMeas/Implementations/Srs/Pdynamics/Average.py
+RsCmwLteMeas/Implementations/Srs/Pdynamics/Current.py
+RsCmwLteMeas/Implementations/Srs/Pdynamics/Maximum.py
+RsCmwLteMeas/Implementations/Srs/Pdynamics/Minimum.py
+RsCmwLteMeas/Implementations/Srs/Pdynamics/StandardDev.py
+RsCmwLteMeas/Implementations/Srs/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/Srs/State/All.py
+RsCmwLteMeas/Implementations/Srs/State/__init__.py
+RsCmwLteMeas/Implementations/Srs/Trace/__init__.py
+RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Average.py
+RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Current.py
+RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/Maximum.py
+RsCmwLteMeas/Implementations/Srs/Trace/Pdynamics/__init__.py
+RsCmwLteMeas/Implementations/Trigger/__init__.py
+RsCmwLteMeas/Implementations/Trigger/MultiEval/Catalog.py
+RsCmwLteMeas/Implementations/Trigger/MultiEval/ListPy.py
+RsCmwLteMeas/Implementations/Trigger/MultiEval/__init__.py
+RsCmwLteMeas/Implementations/Trigger/Prach/Catalog.py
+RsCmwLteMeas/Implementations/Trigger/Prach/__init__.py
+RsCmwLteMeas/Implementations/Trigger/Srs/Catalog.py
+RsCmwLteMeas/Implementations/Trigger/Srs/__init__.py
 RsCmwLteMeas/Internal/ArgLinkedEventArgs.py
 RsCmwLteMeas/Internal/ArgSingle.py
 RsCmwLteMeas/Internal/ArgSingleList.py
 RsCmwLteMeas/Internal/ArgSingleSuppressed.py
 RsCmwLteMeas/Internal/ArgStringComposer.py
 RsCmwLteMeas/Internal/ArgStruct.py
 RsCmwLteMeas/Internal/ArgStructList.py
 RsCmwLteMeas/Internal/ArgStructStringParser.py
 RsCmwLteMeas/Internal/CommandsGroup.py
 RsCmwLteMeas/Internal/Conversions.py
 RsCmwLteMeas/Internal/ConverterFromScpiString.py
 RsCmwLteMeas/Internal/ConverterToScpiString.py
 RsCmwLteMeas/Internal/Core.py
+RsCmwLteMeas/Internal/GlobalData.py
 RsCmwLteMeas/Internal/Instrument.py
 RsCmwLteMeas/Internal/InstrumentErrors.py
 RsCmwLteMeas/Internal/InstrumentOptions.py
 RsCmwLteMeas/Internal/InstrumentSettings.py
 RsCmwLteMeas/Internal/InternalLinker.py
 RsCmwLteMeas/Internal/IoTransferEventArgs.py
+RsCmwLteMeas/Internal/Properties.py
 RsCmwLteMeas/Internal/RepeatedCapability.py
+RsCmwLteMeas/Internal/ScpiEnums.py
+RsCmwLteMeas/Internal/ScpiLogger.py
 RsCmwLteMeas/Internal/StreamReader.py
 RsCmwLteMeas/Internal/StreamWriter.py
 RsCmwLteMeas/Internal/StructBase.py
 RsCmwLteMeas/Internal/Types.py
 RsCmwLteMeas/Internal/Utilities.py
 RsCmwLteMeas/Internal/VisaPluginSocketIo.py
 RsCmwLteMeas/Internal/VisaSession.py
```

